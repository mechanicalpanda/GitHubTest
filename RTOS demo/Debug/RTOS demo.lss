
RTOS demo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003808  00400000  00400000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000008  20400000  00403808  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000bb0  20400008  00403810  00020008  2**2
                  ALLOC
  3 .heap         00000200  20400bb8  004043c0  00020008  2**0
                  ALLOC
  4 .stack        00000400  20400db8  004045c0  00020008  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  00020008  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020036  2**0
                  CONTENTS, READONLY
  7 .debug_info   000149e8  00000000  00000000  0002008f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002d83  00000000  00000000  00034a77  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00008adb  00000000  00000000  000377fa  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000008e8  00000000  00000000  000402d5  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000ba0  00000000  00000000  00040bbd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0003c6d0  00000000  00000000  0004175d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000e867  00000000  00000000  0007de2d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0014c6be  00000000  00000000  0008c694  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00001948  00000000  00000000  001d8d54  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	b8 11 40 20 e5 01 40 00 e1 01 40 00 e1 01 40 00     ..@ ..@...@...@.
  400010:	e1 01 40 00 e1 01 40 00 e1 01 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	51 12 40 00 e1 01 40 00 00 00 00 00 f1 12 40 00     Q.@...@.......@.
  40003c:	55 13 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     U.@...@...@...@.
  40004c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40005c:	e1 01 40 00 e1 01 40 00 00 00 00 00 e1 01 40 00     ..@...@.......@.
  40006c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 35 0b 40 00     ..@...@...@.5.@.
  40007c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40008c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40009c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000ac:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000bc:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000cc:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000dc:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000ec:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  4000fc:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40010c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 00 00 00 00     ..@...@...@.....
  40011c:	00 00 00 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ......@...@...@.
  40012c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40013c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40014c:	e1 01 40 00 e1 01 40 00 e1 01 40 00 e1 01 40 00     ..@...@...@...@.
  40015c:	e1 01 40 00 e1 01 40 00 e1 01 40 00                 ..@...@...@.

00400168 <__do_global_dtors_aux>:
  400168:	b510      	push	{r4, lr}
  40016a:	4c05      	ldr	r4, [pc, #20]	; (400180 <__do_global_dtors_aux+0x18>)
  40016c:	7823      	ldrb	r3, [r4, #0]
  40016e:	b933      	cbnz	r3, 40017e <__do_global_dtors_aux+0x16>
  400170:	4b04      	ldr	r3, [pc, #16]	; (400184 <__do_global_dtors_aux+0x1c>)
  400172:	b113      	cbz	r3, 40017a <__do_global_dtors_aux+0x12>
  400174:	4804      	ldr	r0, [pc, #16]	; (400188 <__do_global_dtors_aux+0x20>)
  400176:	f3af 8000 	nop.w
  40017a:	2301      	movs	r3, #1
  40017c:	7023      	strb	r3, [r4, #0]
  40017e:	bd10      	pop	{r4, pc}
  400180:	20400008 	.word	0x20400008
  400184:	00000000 	.word	0x00000000
  400188:	00403808 	.word	0x00403808

0040018c <frame_dummy>:
  40018c:	4b0c      	ldr	r3, [pc, #48]	; (4001c0 <frame_dummy+0x34>)
  40018e:	b143      	cbz	r3, 4001a2 <frame_dummy+0x16>
  400190:	480c      	ldr	r0, [pc, #48]	; (4001c4 <frame_dummy+0x38>)
  400192:	490d      	ldr	r1, [pc, #52]	; (4001c8 <frame_dummy+0x3c>)
  400194:	b510      	push	{r4, lr}
  400196:	f3af 8000 	nop.w
  40019a:	480c      	ldr	r0, [pc, #48]	; (4001cc <frame_dummy+0x40>)
  40019c:	6803      	ldr	r3, [r0, #0]
  40019e:	b923      	cbnz	r3, 4001aa <frame_dummy+0x1e>
  4001a0:	bd10      	pop	{r4, pc}
  4001a2:	480a      	ldr	r0, [pc, #40]	; (4001cc <frame_dummy+0x40>)
  4001a4:	6803      	ldr	r3, [r0, #0]
  4001a6:	b933      	cbnz	r3, 4001b6 <frame_dummy+0x2a>
  4001a8:	4770      	bx	lr
  4001aa:	4b09      	ldr	r3, [pc, #36]	; (4001d0 <frame_dummy+0x44>)
  4001ac:	2b00      	cmp	r3, #0
  4001ae:	d0f7      	beq.n	4001a0 <frame_dummy+0x14>
  4001b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  4001b4:	4718      	bx	r3
  4001b6:	4b06      	ldr	r3, [pc, #24]	; (4001d0 <frame_dummy+0x44>)
  4001b8:	2b00      	cmp	r3, #0
  4001ba:	d0f5      	beq.n	4001a8 <frame_dummy+0x1c>
  4001bc:	4718      	bx	r3
  4001be:	bf00      	nop
  4001c0:	00000000 	.word	0x00000000
  4001c4:	00403808 	.word	0x00403808
  4001c8:	2040000c 	.word	0x2040000c
  4001cc:	00403808 	.word	0x00403808
  4001d0:	00000000 	.word	0x00000000

004001d4 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
  4001d4:	b508      	push	{r3, lr}
	system_init();
  4001d6:	4b01      	ldr	r3, [pc, #4]	; (4001dc <atmel_start_init+0x8>)
  4001d8:	4798      	blx	r3
  4001da:	bd08      	pop	{r3, pc}
  4001dc:	00400325 	.word	0x00400325

004001e0 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4001e0:	e7fe      	b.n	4001e0 <Dummy_Handler>
	...

004001e4 <Reset_Handler>:
{
  4001e4:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
  4001e6:	4b17      	ldr	r3, [pc, #92]	; (400244 <Reset_Handler+0x60>)
  4001e8:	4a17      	ldr	r2, [pc, #92]	; (400248 <Reset_Handler+0x64>)
  4001ea:	429a      	cmp	r2, r3
  4001ec:	d010      	beq.n	400210 <Reset_Handler+0x2c>
                for (; pDest < &_erelocate;) {
  4001ee:	4b17      	ldr	r3, [pc, #92]	; (40024c <Reset_Handler+0x68>)
  4001f0:	4a14      	ldr	r2, [pc, #80]	; (400244 <Reset_Handler+0x60>)
  4001f2:	429a      	cmp	r2, r3
  4001f4:	d20c      	bcs.n	400210 <Reset_Handler+0x2c>
  4001f6:	3b01      	subs	r3, #1
  4001f8:	1a9b      	subs	r3, r3, r2
  4001fa:	f023 0303 	bic.w	r3, r3, #3
  4001fe:	3304      	adds	r3, #4
  400200:	4413      	add	r3, r2
  400202:	4911      	ldr	r1, [pc, #68]	; (400248 <Reset_Handler+0x64>)
                        *pDest++ = *pSrc++;
  400204:	f851 0b04 	ldr.w	r0, [r1], #4
  400208:	f842 0b04 	str.w	r0, [r2], #4
                for (; pDest < &_erelocate;) {
  40020c:	429a      	cmp	r2, r3
  40020e:	d1f9      	bne.n	400204 <Reset_Handler+0x20>
        for (pDest = &_szero; pDest < &_ezero;) {
  400210:	4b0f      	ldr	r3, [pc, #60]	; (400250 <Reset_Handler+0x6c>)
  400212:	4a10      	ldr	r2, [pc, #64]	; (400254 <Reset_Handler+0x70>)
  400214:	429a      	cmp	r2, r3
  400216:	d20a      	bcs.n	40022e <Reset_Handler+0x4a>
  400218:	3b01      	subs	r3, #1
  40021a:	1a9b      	subs	r3, r3, r2
  40021c:	f023 0303 	bic.w	r3, r3, #3
  400220:	3304      	adds	r3, #4
  400222:	4413      	add	r3, r2
                *pDest++ = 0;
  400224:	2100      	movs	r1, #0
  400226:	f842 1b04 	str.w	r1, [r2], #4
        for (pDest = &_szero; pDest < &_ezero;) {
  40022a:	4293      	cmp	r3, r2
  40022c:	d1fb      	bne.n	400226 <Reset_Handler+0x42>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  40022e:	4a0a      	ldr	r2, [pc, #40]	; (400258 <Reset_Handler+0x74>)
  400230:	4b0a      	ldr	r3, [pc, #40]	; (40025c <Reset_Handler+0x78>)
  400232:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  400236:	6093      	str	r3, [r2, #8]
        __libc_init_array();
  400238:	4b09      	ldr	r3, [pc, #36]	; (400260 <Reset_Handler+0x7c>)
  40023a:	4798      	blx	r3
        main();
  40023c:	4b09      	ldr	r3, [pc, #36]	; (400264 <Reset_Handler+0x80>)
  40023e:	4798      	blx	r3
  400240:	e7fe      	b.n	400240 <Reset_Handler+0x5c>
  400242:	bf00      	nop
  400244:	20400000 	.word	0x20400000
  400248:	00403808 	.word	0x00403808
  40024c:	20400008 	.word	0x20400008
  400250:	20400bb8 	.word	0x20400bb8
  400254:	20400008 	.word	0x20400008
  400258:	e000ed00 	.word	0xe000ed00
  40025c:	00400000 	.word	0x00400000
  400260:	004034f5 	.word	0x004034f5
  400264:	00400da5 	.word	0x00400da5

00400268 <EDBG_COM_PORT_init>:
}

static inline void hri_pio_clear_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400268:	4b0f      	ldr	r3, [pc, #60]	; (4002a8 <EDBG_COM_PORT_init+0x40>)
  40026a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  40026c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  400270:	671a      	str	r2, [r3, #112]	; 0x70
  400272:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400274:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  400278:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40027a:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  40027e:	605a      	str	r2, [r3, #4]
}

static inline void hri_matrix_set_CCFG_SYSIO_reg(const void *const hw, hri_matrix_ccfg_sysio_reg_t mask)
{
	MATRIX_CRITICAL_SECTION_ENTER();
	((Matrix *)hw)->CCFG_SYSIO |= mask;
  400280:	4a0a      	ldr	r2, [pc, #40]	; (4002ac <EDBG_COM_PORT_init+0x44>)
  400282:	f8d2 3114 	ldr.w	r3, [r2, #276]	; 0x114
  400286:	f043 0310 	orr.w	r3, r3, #16
  40028a:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40028e:	4b08      	ldr	r3, [pc, #32]	; (4002b0 <EDBG_COM_PORT_init+0x48>)
  400290:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400292:	f042 0210 	orr.w	r2, r2, #16
  400296:	671a      	str	r2, [r3, #112]	; 0x70
  400298:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40029a:	f042 0210 	orr.w	r2, r2, #16
  40029e:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4002a0:	2210      	movs	r2, #16
  4002a2:	605a      	str	r2, [r3, #4]
  4002a4:	4770      	bx	lr
  4002a6:	bf00      	nop
  4002a8:	400e0e00 	.word	0x400e0e00
  4002ac:	40088000 	.word	0x40088000
  4002b0:	400e1000 	.word	0x400e1000

004002b4 <EDBG_COM_CLOCK_init>:
}

static inline hri_pmc_pcsr0_reg_t hri_pmc_get_PCSR0_reg(const void *const hw, hri_pmc_pcsr0_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4002b4:	4b04      	ldr	r3, [pc, #16]	; (4002c8 <EDBG_COM_CLOCK_init+0x14>)
  4002b6:	699b      	ldr	r3, [r3, #24]
 *
 */
static inline void _pmc_enable_periph_clock(uint32_t periph_id)
{
	if (periph_id < 32) {
		if (!hri_pmc_get_PCSR0_reg(PMC, (1 << periph_id))) {
  4002b8:	f413 4f80 	tst.w	r3, #16384	; 0x4000
  4002bc:	d103      	bne.n	4002c6 <EDBG_COM_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4002be:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  4002c2:	4b01      	ldr	r3, [pc, #4]	; (4002c8 <EDBG_COM_CLOCK_init+0x14>)
  4002c4:	611a      	str	r2, [r3, #16]
  4002c6:	4770      	bx	lr
  4002c8:	400e0600 	.word	0x400e0600

004002cc <EDBG_COM_init>:
{
	_pmc_enable_periph_clock(ID_USART1);
}

void EDBG_COM_init(void)
{
  4002cc:	b530      	push	{r4, r5, lr}
  4002ce:	b083      	sub	sp, #12
	EDBG_COM_CLOCK_init();
  4002d0:	4b0b      	ldr	r3, [pc, #44]	; (400300 <EDBG_COM_init+0x34>)
  4002d2:	4798      	blx	r3
	usart_os_init(&EDBG_COM, USART1, EDBG_COM_buffer, EDBG_COM_BUFFER_SIZE, (void *)_usart_get_usart_async());
  4002d4:	4b0b      	ldr	r3, [pc, #44]	; (400304 <EDBG_COM_init+0x38>)
  4002d6:	4798      	blx	r3
  4002d8:	4c0b      	ldr	r4, [pc, #44]	; (400308 <EDBG_COM_init+0x3c>)
  4002da:	9000      	str	r0, [sp, #0]
  4002dc:	2310      	movs	r3, #16
  4002de:	4a0b      	ldr	r2, [pc, #44]	; (40030c <EDBG_COM_init+0x40>)
  4002e0:	490b      	ldr	r1, [pc, #44]	; (400310 <EDBG_COM_init+0x44>)
  4002e2:	4620      	mov	r0, r4
  4002e4:	4d0b      	ldr	r5, [pc, #44]	; (400314 <EDBG_COM_init+0x48>)
  4002e6:	47a8      	blx	r5
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  4002e8:	22c0      	movs	r2, #192	; 0xc0
  4002ea:	4b0b      	ldr	r3, [pc, #44]	; (400318 <EDBG_COM_init+0x4c>)
  4002ec:	f883 230e 	strb.w	r2, [r3, #782]	; 0x30e
	NVIC_SetPriority(USART1_IRQn, PERIPHERAL_INTERRUPT_PRIORITY);
	usart_os_enable(&EDBG_COM);
  4002f0:	4620      	mov	r0, r4
  4002f2:	4b0a      	ldr	r3, [pc, #40]	; (40031c <EDBG_COM_init+0x50>)
  4002f4:	4798      	blx	r3
	EDBG_COM_PORT_init();
  4002f6:	4b0a      	ldr	r3, [pc, #40]	; (400320 <EDBG_COM_init+0x54>)
  4002f8:	4798      	blx	r3
}
  4002fa:	b003      	add	sp, #12
  4002fc:	bd30      	pop	{r4, r5, pc}
  4002fe:	bf00      	nop
  400300:	004002b5 	.word	0x004002b5
  400304:	00400b31 	.word	0x00400b31
  400308:	20400b6c 	.word	0x20400b6c
  40030c:	20400b5c 	.word	0x20400b5c
  400310:	40028000 	.word	0x40028000
  400314:	00400561 	.word	0x00400561
  400318:	e000e100 	.word	0xe000e100
  40031c:	00400655 	.word	0x00400655
  400320:	00400269 	.word	0x00400269

00400324 <system_init>:

void system_init(void)
{
  400324:	b508      	push	{r3, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
  400326:	4b0c      	ldr	r3, [pc, #48]	; (400358 <system_init+0x34>)
  400328:	4798      	blx	r3
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  40032a:	4b0c      	ldr	r3, [pc, #48]	; (40035c <system_init+0x38>)
  40032c:	699b      	ldr	r3, [r3, #24]
  40032e:	f413 6f80 	tst.w	r3, #1024	; 0x400
  400332:	d103      	bne.n	40033c <system_init+0x18>
	((Pmc *)hw)->PMC_PCER0 = mask;
  400334:	f44f 6280 	mov.w	r2, #1024	; 0x400
  400338:	4b08      	ldr	r3, [pc, #32]	; (40035c <system_init+0x38>)
  40033a:	611a      	str	r2, [r3, #16]
}

static inline void hri_wdt_set_MR_WDDIS_bit(const void *const hw)
{
	WDT_CRITICAL_SECTION_ENTER();
	((Wdt *)hw)->WDT_MR |= WDT_MR_WDDIS;
  40033c:	4a08      	ldr	r2, [pc, #32]	; (400360 <system_init+0x3c>)
  40033e:	6853      	ldr	r3, [r2, #4]
  400340:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  400344:	6053      	str	r3, [r2, #4]
	((Pio *)hw)->PIO_SODR = mask;
  400346:	4b07      	ldr	r3, [pc, #28]	; (400364 <system_init+0x40>)
  400348:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  40034c:	631a      	str	r2, [r3, #48]	; 0x30
	((Pio *)hw)->PIO_OER = mask;
  40034e:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400350:	601a      	str	r2, [r3, #0]
	// Set pin direction to output
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED0, GPIO_PIN_FUNCTION_OFF);

	EDBG_COM_init();
  400352:	4b05      	ldr	r3, [pc, #20]	; (400368 <system_init+0x44>)
  400354:	4798      	blx	r3
  400356:	bd08      	pop	{r3, pc}
  400358:	00400779 	.word	0x00400779
  40035c:	400e0600 	.word	0x400e0600
  400360:	400e1850 	.word	0x400e1850
  400364:	400e0e00 	.word	0x400e0e00
  400368:	004002cd 	.word	0x004002cd

0040036c <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  40036c:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
  400370:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  400372:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  400374:	f3bf 8f5f 	dmb	sy
  400378:	4770      	bx	lr

0040037a <atomic_leave_critical>:
  40037a:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
  40037e:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  400380:	f383 8810 	msr	PRIMASK, r3
  400384:	4770      	bx	lr
	...

00400388 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
  400388:	b570      	push	{r4, r5, r6, lr}
  40038a:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
  40038c:	4604      	mov	r4, r0
  40038e:	460d      	mov	r5, r1
  400390:	2800      	cmp	r0, #0
  400392:	bf18      	it	ne
  400394:	2900      	cmpne	r1, #0
  400396:	bf14      	ite	ne
  400398:	2001      	movne	r0, #1
  40039a:	2000      	moveq	r0, #0
  40039c:	2234      	movs	r2, #52	; 0x34
  40039e:	4904      	ldr	r1, [pc, #16]	; (4003b0 <io_write+0x28>)
  4003a0:	4b04      	ldr	r3, [pc, #16]	; (4003b4 <io_write+0x2c>)
  4003a2:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
  4003a4:	6823      	ldr	r3, [r4, #0]
  4003a6:	4632      	mov	r2, r6
  4003a8:	4629      	mov	r1, r5
  4003aa:	4620      	mov	r0, r4
  4003ac:	4798      	blx	r3
}
  4003ae:	bd70      	pop	{r4, r5, r6, pc}
  4003b0:	00403584 	.word	0x00403584
  4003b4:	00400681 	.word	0x00400681

004003b8 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
  4003b8:	b570      	push	{r4, r5, r6, lr}
  4003ba:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
  4003bc:	4604      	mov	r4, r0
  4003be:	460d      	mov	r5, r1
  4003c0:	2800      	cmp	r0, #0
  4003c2:	bf18      	it	ne
  4003c4:	2900      	cmpne	r1, #0
  4003c6:	bf14      	ite	ne
  4003c8:	2001      	movne	r0, #1
  4003ca:	2000      	moveq	r0, #0
  4003cc:	223d      	movs	r2, #61	; 0x3d
  4003ce:	4904      	ldr	r1, [pc, #16]	; (4003e0 <io_read+0x28>)
  4003d0:	4b04      	ldr	r3, [pc, #16]	; (4003e4 <io_read+0x2c>)
  4003d2:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
  4003d4:	6863      	ldr	r3, [r4, #4]
  4003d6:	4632      	mov	r2, r6
  4003d8:	4629      	mov	r1, r5
  4003da:	4620      	mov	r0, r4
  4003dc:	4798      	blx	r3
}
  4003de:	bd70      	pop	{r4, r5, r6, pc}
  4003e0:	00403584 	.word	0x00403584
  4003e4:	00400681 	.word	0x00400681

004003e8 <usart_os_error>:
 * \brief Process error interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_os_error(struct _usart_async_device *device)
{
  4003e8:	b508      	push	{r3, lr}
	struct usart_os_descriptor *descr = CONTAINER_OF(device, struct usart_os_descriptor, device);

	sem_up(&descr->rx_sem);
  4003ea:	303c      	adds	r0, #60	; 0x3c
  4003ec:	4b01      	ldr	r3, [pc, #4]	; (4003f4 <usart_os_error+0xc>)
  4003ee:	4798      	blx	r3
  4003f0:	bd08      	pop	{r3, pc}
  4003f2:	bf00      	nop
  4003f4:	0040108d 	.word	0x0040108d

004003f8 <usart_os_transmission_complete>:
{
  4003f8:	b508      	push	{r3, lr}
	sem_up(&descr->tx_sem);
  4003fa:	3040      	adds	r0, #64	; 0x40
  4003fc:	4b01      	ldr	r3, [pc, #4]	; (400404 <usart_os_transmission_complete+0xc>)
  4003fe:	4798      	blx	r3
  400400:	bd08      	pop	{r3, pc}
  400402:	bf00      	nop
  400404:	0040108d 	.word	0x0040108d

00400408 <usart_os_fill_rx_buffer>:
{
  400408:	b510      	push	{r4, lr}
	if (descr->rx_buffer == NULL) {
  40040a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  40040c:	b143      	cbz	r3, 400420 <usart_os_fill_rx_buffer+0x18>
		descr->rx_buffer[descr->rx_size++] = data;
  40040e:	8e02      	ldrh	r2, [r0, #48]	; 0x30
  400410:	1c54      	adds	r4, r2, #1
  400412:	8604      	strh	r4, [r0, #48]	; 0x30
  400414:	5499      	strb	r1, [r3, r2]
		if (descr->rx_size >= descr->rx_length) {
  400416:	8e02      	ldrh	r2, [r0, #48]	; 0x30
  400418:	8e43      	ldrh	r3, [r0, #50]	; 0x32
  40041a:	429a      	cmp	r2, r3
  40041c:	d204      	bcs.n	400428 <usart_os_fill_rx_buffer+0x20>
  40041e:	bd10      	pop	{r4, pc}
		ringbuffer_put(&descr->rx, data);
  400420:	301c      	adds	r0, #28
  400422:	4b04      	ldr	r3, [pc, #16]	; (400434 <usart_os_fill_rx_buffer+0x2c>)
  400424:	4798      	blx	r3
  400426:	bd10      	pop	{r4, pc}
			descr->rx_buffer = NULL;
  400428:	2300      	movs	r3, #0
  40042a:	62c3      	str	r3, [r0, #44]	; 0x2c
			sem_up(&descr->rx_sem);
  40042c:	303c      	adds	r0, #60	; 0x3c
  40042e:	4b02      	ldr	r3, [pc, #8]	; (400438 <usart_os_fill_rx_buffer+0x30>)
  400430:	4798      	blx	r3
}
  400432:	e7f4      	b.n	40041e <usart_os_fill_rx_buffer+0x16>
  400434:	00400715 	.word	0x00400715
  400438:	0040108d 	.word	0x0040108d

0040043c <usart_os_process_byte_sent>:
{
  40043c:	b510      	push	{r4, lr}
  40043e:	4604      	mov	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
  400440:	8f03      	ldrh	r3, [r0, #56]	; 0x38
  400442:	8f42      	ldrh	r2, [r0, #58]	; 0x3a
  400444:	429a      	cmp	r2, r3
  400446:	d009      	beq.n	40045c <usart_os_process_byte_sent+0x20>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
  400448:	6b42      	ldr	r2, [r0, #52]	; 0x34
  40044a:	1c59      	adds	r1, r3, #1
  40044c:	8701      	strh	r1, [r0, #56]	; 0x38
  40044e:	5cd1      	ldrb	r1, [r2, r3]
  400450:	4b04      	ldr	r3, [pc, #16]	; (400464 <usart_os_process_byte_sent+0x28>)
  400452:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
  400454:	4620      	mov	r0, r4
  400456:	4b04      	ldr	r3, [pc, #16]	; (400468 <usart_os_process_byte_sent+0x2c>)
  400458:	4798      	blx	r3
  40045a:	bd10      	pop	{r4, pc}
		_usart_async_enable_tx_done_irq(&descr->device);
  40045c:	4b03      	ldr	r3, [pc, #12]	; (40046c <usart_os_process_byte_sent+0x30>)
  40045e:	4798      	blx	r3
  400460:	bd10      	pop	{r4, pc}
  400462:	bf00      	nop
  400464:	00400a3d 	.word	0x00400a3d
  400468:	00400a61 	.word	0x00400a61
  40046c:	00400a85 	.word	0x00400a85

00400470 <usart_os_write>:
{
  400470:	b538      	push	{r3, r4, r5, lr}
  400472:	4604      	mov	r4, r0
  400474:	4615      	mov	r5, r2
	descr->tx_buffer        = (uint8_t *)buf;
  400476:	63c1      	str	r1, [r0, #60]	; 0x3c
	descr->tx_buffer_length = length;
  400478:	f8a4 2042 	strh.w	r2, [r4, #66]	; 0x42
	descr->tx_por           = 0;
  40047c:	2300      	movs	r3, #0
  40047e:	f8a0 3040 	strh.w	r3, [r0, #64]	; 0x40
	_usart_async_enable_byte_sent_irq(&descr->device);
  400482:	3008      	adds	r0, #8
  400484:	4b06      	ldr	r3, [pc, #24]	; (4004a0 <usart_os_write+0x30>)
  400486:	4798      	blx	r3
	return sem_down(&descr->tx_sem, ~0) == 0 ? length : ERR_TIMEOUT;
  400488:	f04f 31ff 	mov.w	r1, #4294967295
  40048c:	f104 0048 	add.w	r0, r4, #72	; 0x48
  400490:	4b04      	ldr	r3, [pc, #16]	; (4004a4 <usart_os_write+0x34>)
  400492:	4798      	blx	r3
  400494:	2800      	cmp	r0, #0
}
  400496:	bf0c      	ite	eq
  400498:	4628      	moveq	r0, r5
  40049a:	f06f 0007 	mvnne.w	r0, #7
  40049e:	bd38      	pop	{r3, r4, r5, pc}
  4004a0:	00400a61 	.word	0x00400a61
  4004a4:	004010d1 	.word	0x004010d1

004004a8 <usart_os_read>:
{
  4004a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4004ac:	b082      	sub	sp, #8
  4004ae:	4604      	mov	r4, r0
  4004b0:	4690      	mov	r8, r2
	ASSERT(buf);
  4004b2:	460e      	mov	r6, r1
  4004b4:	1c08      	adds	r0, r1, #0
  4004b6:	bf18      	it	ne
  4004b8:	2001      	movne	r0, #1
  4004ba:	f44f 7292 	mov.w	r2, #292	; 0x124
  4004be:	4921      	ldr	r1, [pc, #132]	; (400544 <usart_os_read+0x9c>)
  4004c0:	4b21      	ldr	r3, [pc, #132]	; (400548 <usart_os_read+0xa0>)
  4004c2:	4798      	blx	r3
	if (ringbuffer_num(&descr->rx) < length) {
  4004c4:	f104 0524 	add.w	r5, r4, #36	; 0x24
  4004c8:	4628      	mov	r0, r5
  4004ca:	4b20      	ldr	r3, [pc, #128]	; (40054c <usart_os_read+0xa4>)
  4004cc:	4798      	blx	r3
  4004ce:	4540      	cmp	r0, r8
  4004d0:	d313      	bcc.n	4004fa <usart_os_read+0x52>
		while (was_read < length) {
  4004d2:	f1b8 0f00 	cmp.w	r8, #0
  4004d6:	d00c      	beq.n	4004f2 <usart_os_read+0x4a>
  4004d8:	4634      	mov	r4, r6
  4004da:	f108 33ff 	add.w	r3, r8, #4294967295
  4004de:	b29b      	uxth	r3, r3
  4004e0:	3301      	adds	r3, #1
  4004e2:	441e      	add	r6, r3
			ringbuffer_get(&descr->rx, &buf[was_read++]);
  4004e4:	4f1a      	ldr	r7, [pc, #104]	; (400550 <usart_os_read+0xa8>)
  4004e6:	4621      	mov	r1, r4
  4004e8:	4628      	mov	r0, r5
  4004ea:	47b8      	blx	r7
  4004ec:	3401      	adds	r4, #1
		while (was_read < length) {
  4004ee:	42b4      	cmp	r4, r6
  4004f0:	d1f9      	bne.n	4004e6 <usart_os_read+0x3e>
	return (int32_t)length;
  4004f2:	4640      	mov	r0, r8
}
  4004f4:	b002      	add	sp, #8
  4004f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		CRITICAL_SECTION_ENTER()
  4004fa:	a801      	add	r0, sp, #4
  4004fc:	4b15      	ldr	r3, [pc, #84]	; (400554 <usart_os_read+0xac>)
  4004fe:	4798      	blx	r3
		descr->rx_size   = 0;
  400500:	2300      	movs	r3, #0
  400502:	8723      	strh	r3, [r4, #56]	; 0x38
		descr->rx_length = length;
  400504:	f8a4 803a 	strh.w	r8, [r4, #58]	; 0x3a
		descr->rx_buffer = buf;
  400508:	6366      	str	r6, [r4, #52]	; 0x34
		while (ringbuffer_num(&descr->rx) > 0) {
  40050a:	4e10      	ldr	r6, [pc, #64]	; (40054c <usart_os_read+0xa4>)
			ringbuffer_get(&descr->rx, &descr->rx_buffer[descr->rx_size++]);
  40050c:	4f10      	ldr	r7, [pc, #64]	; (400550 <usart_os_read+0xa8>)
		while (ringbuffer_num(&descr->rx) > 0) {
  40050e:	e006      	b.n	40051e <usart_os_read+0x76>
			ringbuffer_get(&descr->rx, &descr->rx_buffer[descr->rx_size++]);
  400510:	6b61      	ldr	r1, [r4, #52]	; 0x34
  400512:	8f23      	ldrh	r3, [r4, #56]	; 0x38
  400514:	1c5a      	adds	r2, r3, #1
  400516:	8722      	strh	r2, [r4, #56]	; 0x38
  400518:	4419      	add	r1, r3
  40051a:	4628      	mov	r0, r5
  40051c:	47b8      	blx	r7
		while (ringbuffer_num(&descr->rx) > 0) {
  40051e:	4628      	mov	r0, r5
  400520:	47b0      	blx	r6
  400522:	2800      	cmp	r0, #0
  400524:	d1f4      	bne.n	400510 <usart_os_read+0x68>
		CRITICAL_SECTION_LEAVE()
  400526:	a801      	add	r0, sp, #4
  400528:	4b0b      	ldr	r3, [pc, #44]	; (400558 <usart_os_read+0xb0>)
  40052a:	4798      	blx	r3
		if (sem_down(&descr->rx_sem, timeout) != 0) {
  40052c:	f04f 31ff 	mov.w	r1, #4294967295
  400530:	f104 0044 	add.w	r0, r4, #68	; 0x44
  400534:	4b09      	ldr	r3, [pc, #36]	; (40055c <usart_os_read+0xb4>)
  400536:	4798      	blx	r3
  400538:	2800      	cmp	r0, #0
  40053a:	d0da      	beq.n	4004f2 <usart_os_read+0x4a>
			return ERR_TIMEOUT;
  40053c:	f06f 0007 	mvn.w	r0, #7
  400540:	e7d8      	b.n	4004f4 <usart_os_read+0x4c>
  400542:	bf00      	nop
  400544:	00403598 	.word	0x00403598
  400548:	00400681 	.word	0x00400681
  40054c:	00400755 	.word	0x00400755
  400550:	004006d1 	.word	0x004006d1
  400554:	0040036d 	.word	0x0040036d
  400558:	0040037b 	.word	0x0040037b
  40055c:	004010d1 	.word	0x004010d1

00400560 <usart_os_init>:
{
  400560:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  400564:	4615      	mov	r5, r2
  400566:	461e      	mov	r6, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
  400568:	4604      	mov	r4, r0
  40056a:	460f      	mov	r7, r1
  40056c:	2800      	cmp	r0, #0
  40056e:	bf18      	it	ne
  400570:	2900      	cmpne	r1, #0
  400572:	bf14      	ite	ne
  400574:	2001      	movne	r0, #1
  400576:	2000      	moveq	r0, #0
  400578:	d005      	beq.n	400586 <usart_os_init+0x26>
  40057a:	2a00      	cmp	r2, #0
  40057c:	bf18      	it	ne
  40057e:	2b00      	cmpne	r3, #0
  400580:	bf14      	ite	ne
  400582:	2001      	movne	r0, #1
  400584:	2000      	moveq	r0, #0
  400586:	2240      	movs	r2, #64	; 0x40
  400588:	4925      	ldr	r1, [pc, #148]	; (400620 <usart_os_init+0xc0>)
  40058a:	4b26      	ldr	r3, [pc, #152]	; (400624 <usart_os_init+0xc4>)
  40058c:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
  40058e:	4632      	mov	r2, r6
  400590:	4629      	mov	r1, r5
  400592:	f104 0024 	add.w	r0, r4, #36	; 0x24
  400596:	4b24      	ldr	r3, [pc, #144]	; (400628 <usart_os_init+0xc8>)
  400598:	4798      	blx	r3
  40059a:	2800      	cmp	r0, #0
  40059c:	d13d      	bne.n	40061a <usart_os_init+0xba>
	rc = sem_init(&descr->rx_sem, 0);
  40059e:	f104 0644 	add.w	r6, r4, #68	; 0x44
  4005a2:	2100      	movs	r1, #0
  4005a4:	4630      	mov	r0, r6
  4005a6:	4b21      	ldr	r3, [pc, #132]	; (40062c <usart_os_init+0xcc>)
  4005a8:	4798      	blx	r3
	if (rc < 0) {
  4005aa:	1e05      	subs	r5, r0, #0
  4005ac:	db28      	blt.n	400600 <usart_os_init+0xa0>
	rc = sem_init(&descr->tx_sem, 0);
  4005ae:	f104 0948 	add.w	r9, r4, #72	; 0x48
  4005b2:	2100      	movs	r1, #0
  4005b4:	4648      	mov	r0, r9
  4005b6:	4b1d      	ldr	r3, [pc, #116]	; (40062c <usart_os_init+0xcc>)
  4005b8:	4798      	blx	r3
	if (rc < 0) {
  4005ba:	1e05      	subs	r5, r0, #0
  4005bc:	db23      	blt.n	400606 <usart_os_init+0xa6>
	rc = _usart_async_init(&descr->device, hw);
  4005be:	f104 0808 	add.w	r8, r4, #8
  4005c2:	4639      	mov	r1, r7
  4005c4:	4640      	mov	r0, r8
  4005c6:	4b1a      	ldr	r3, [pc, #104]	; (400630 <usart_os_init+0xd0>)
  4005c8:	4798      	blx	r3
	if (rc) {
  4005ca:	4605      	mov	r5, r0
  4005cc:	b9f8      	cbnz	r0, 40060e <usart_os_init+0xae>
	descr->rx_buffer = NULL;
  4005ce:	2300      	movs	r3, #0
  4005d0:	6363      	str	r3, [r4, #52]	; 0x34
	descr->rx_size   = 0;
  4005d2:	8723      	strh	r3, [r4, #56]	; 0x38
	descr->rx_length = 0;
  4005d4:	8763      	strh	r3, [r4, #58]	; 0x3a
	descr->io.read  = usart_os_read;
  4005d6:	4b17      	ldr	r3, [pc, #92]	; (400634 <usart_os_init+0xd4>)
  4005d8:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_os_write;
  4005da:	4b17      	ldr	r3, [pc, #92]	; (400638 <usart_os_init+0xd8>)
  4005dc:	6023      	str	r3, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_os_process_byte_sent;
  4005de:	4b17      	ldr	r3, [pc, #92]	; (40063c <usart_os_init+0xdc>)
  4005e0:	60a3      	str	r3, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_os_fill_rx_buffer;
  4005e2:	4b17      	ldr	r3, [pc, #92]	; (400640 <usart_os_init+0xe0>)
  4005e4:	60e3      	str	r3, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_os_transmission_complete;
  4005e6:	4b17      	ldr	r3, [pc, #92]	; (400644 <usart_os_init+0xe4>)
  4005e8:	6123      	str	r3, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_os_error;
  4005ea:	4b17      	ldr	r3, [pc, #92]	; (400648 <usart_os_init+0xe8>)
  4005ec:	6163      	str	r3, [r4, #20]
	_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, true);
  4005ee:	2201      	movs	r2, #1
  4005f0:	4611      	mov	r1, r2
  4005f2:	4640      	mov	r0, r8
  4005f4:	4c15      	ldr	r4, [pc, #84]	; (40064c <usart_os_init+0xec>)
  4005f6:	47a0      	blx	r4
	_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, true);
  4005f8:	2201      	movs	r2, #1
  4005fa:	2103      	movs	r1, #3
  4005fc:	4640      	mov	r0, r8
  4005fe:	47a0      	blx	r4
}
  400600:	4628      	mov	r0, r5
  400602:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		sem_deinit(&descr->tx_sem);
  400606:	4648      	mov	r0, r9
  400608:	4b11      	ldr	r3, [pc, #68]	; (400650 <usart_os_init+0xf0>)
  40060a:	4798      	blx	r3
		return rc;
  40060c:	e7f8      	b.n	400600 <usart_os_init+0xa0>
		sem_deinit(&descr->tx_sem);
  40060e:	4648      	mov	r0, r9
  400610:	4c0f      	ldr	r4, [pc, #60]	; (400650 <usart_os_init+0xf0>)
  400612:	47a0      	blx	r4
		sem_deinit(&descr->rx_sem);
  400614:	4630      	mov	r0, r6
  400616:	47a0      	blx	r4
		return rc;
  400618:	e7f2      	b.n	400600 <usart_os_init+0xa0>
		return ERR_INVALID_ARG;
  40061a:	f06f 050c 	mvn.w	r5, #12
  40061e:	e7ef      	b.n	400600 <usart_os_init+0xa0>
  400620:	00403598 	.word	0x00403598
  400624:	00400681 	.word	0x00400681
  400628:	00400689 	.word	0x00400689
  40062c:	00401055 	.word	0x00401055
  400630:	00400955 	.word	0x00400955
  400634:	004004a9 	.word	0x004004a9
  400638:	00400471 	.word	0x00400471
  40063c:	0040043d 	.word	0x0040043d
  400640:	00400409 	.word	0x00400409
  400644:	004003f9 	.word	0x004003f9
  400648:	004003e9 	.word	0x004003e9
  40064c:	00400aad 	.word	0x00400aad
  400650:	004010e9 	.word	0x004010e9

00400654 <usart_os_enable>:
{
  400654:	b510      	push	{r4, lr}
	ASSERT(descr);
  400656:	4604      	mov	r4, r0
  400658:	227b      	movs	r2, #123	; 0x7b
  40065a:	4906      	ldr	r1, [pc, #24]	; (400674 <usart_os_enable+0x20>)
  40065c:	3000      	adds	r0, #0
  40065e:	bf18      	it	ne
  400660:	2001      	movne	r0, #1
  400662:	4b05      	ldr	r3, [pc, #20]	; (400678 <usart_os_enable+0x24>)
  400664:	4798      	blx	r3
	_usart_async_enable(&descr->device);
  400666:	f104 0008 	add.w	r0, r4, #8
  40066a:	4b04      	ldr	r3, [pc, #16]	; (40067c <usart_os_enable+0x28>)
  40066c:	4798      	blx	r3
}
  40066e:	2000      	movs	r0, #0
  400670:	bd10      	pop	{r4, pc}
  400672:	bf00      	nop
  400674:	00403598 	.word	0x00403598
  400678:	00400681 	.word	0x00400681
  40067c:	00400a09 	.word	0x00400a09

00400680 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
  400680:	b900      	cbnz	r0, 400684 <assert+0x4>
		__asm("BKPT #0");
  400682:	be00      	bkpt	0x0000
  400684:	4770      	bx	lr
	...

00400688 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
  400688:	b570      	push	{r4, r5, r6, lr}
	ASSERT(rb && buf && size);
  40068a:	460e      	mov	r6, r1
  40068c:	4615      	mov	r5, r2
  40068e:	2900      	cmp	r1, #0
  400690:	bf18      	it	ne
  400692:	2a00      	cmpne	r2, #0
  400694:	bf14      	ite	ne
  400696:	2301      	movne	r3, #1
  400698:	2300      	moveq	r3, #0
  40069a:	4604      	mov	r4, r0
  40069c:	2228      	movs	r2, #40	; 0x28
  40069e:	490a      	ldr	r1, [pc, #40]	; (4006c8 <ringbuffer_init+0x40>)
  4006a0:	2800      	cmp	r0, #0
  4006a2:	bf0c      	ite	eq
  4006a4:	2000      	moveq	r0, #0
  4006a6:	f003 0001 	andne.w	r0, r3, #1
  4006aa:	4b08      	ldr	r3, [pc, #32]	; (4006cc <ringbuffer_init+0x44>)
  4006ac:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
  4006ae:	1e6b      	subs	r3, r5, #1
  4006b0:	421d      	tst	r5, r3
  4006b2:	d105      	bne.n	4006c0 <ringbuffer_init+0x38>
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
  4006b4:	6063      	str	r3, [r4, #4]
	rb->read_index  = 0;
  4006b6:	2000      	movs	r0, #0
  4006b8:	60a0      	str	r0, [r4, #8]
	rb->write_index = rb->read_index;
  4006ba:	60e0      	str	r0, [r4, #12]
	rb->buf         = (uint8_t *)buf;
  4006bc:	6026      	str	r6, [r4, #0]

	return ERR_NONE;
  4006be:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_INVALID_ARG;
  4006c0:	f06f 000c 	mvn.w	r0, #12
}
  4006c4:	bd70      	pop	{r4, r5, r6, pc}
  4006c6:	bf00      	nop
  4006c8:	004035b4 	.word	0x004035b4
  4006cc:	00400681 	.word	0x00400681

004006d0 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
  4006d0:	b538      	push	{r3, r4, r5, lr}
	ASSERT(rb && data);
  4006d2:	4604      	mov	r4, r0
  4006d4:	460d      	mov	r5, r1
  4006d6:	2800      	cmp	r0, #0
  4006d8:	bf18      	it	ne
  4006da:	2900      	cmpne	r1, #0
  4006dc:	bf14      	ite	ne
  4006de:	2001      	movne	r0, #1
  4006e0:	2000      	moveq	r0, #0
  4006e2:	2240      	movs	r2, #64	; 0x40
  4006e4:	4909      	ldr	r1, [pc, #36]	; (40070c <ringbuffer_get+0x3c>)
  4006e6:	4b0a      	ldr	r3, [pc, #40]	; (400710 <ringbuffer_get+0x40>)
  4006e8:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
  4006ea:	68a3      	ldr	r3, [r4, #8]
  4006ec:	68e2      	ldr	r2, [r4, #12]
  4006ee:	429a      	cmp	r2, r3
  4006f0:	d009      	beq.n	400706 <ringbuffer_get+0x36>
		*data = rb->buf[rb->read_index & rb->size];
  4006f2:	6862      	ldr	r2, [r4, #4]
  4006f4:	4013      	ands	r3, r2
  4006f6:	6822      	ldr	r2, [r4, #0]
  4006f8:	5cd3      	ldrb	r3, [r2, r3]
  4006fa:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
  4006fc:	68a3      	ldr	r3, [r4, #8]
  4006fe:	3301      	adds	r3, #1
  400700:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
  400702:	2000      	movs	r0, #0
  400704:	bd38      	pop	{r3, r4, r5, pc}
	}

	return ERR_NOT_FOUND;
  400706:	f06f 0009 	mvn.w	r0, #9
}
  40070a:	bd38      	pop	{r3, r4, r5, pc}
  40070c:	004035b4 	.word	0x004035b4
  400710:	00400681 	.word	0x00400681

00400714 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
  400714:	b538      	push	{r3, r4, r5, lr}
  400716:	460d      	mov	r5, r1
	ASSERT(rb);
  400718:	4604      	mov	r4, r0
  40071a:	2251      	movs	r2, #81	; 0x51
  40071c:	490b      	ldr	r1, [pc, #44]	; (40074c <ringbuffer_put+0x38>)
  40071e:	3000      	adds	r0, #0
  400720:	bf18      	it	ne
  400722:	2001      	movne	r0, #1
  400724:	4b0a      	ldr	r3, [pc, #40]	; (400750 <ringbuffer_put+0x3c>)
  400726:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
  400728:	68e3      	ldr	r3, [r4, #12]
  40072a:	6862      	ldr	r2, [r4, #4]
  40072c:	4013      	ands	r3, r2
  40072e:	6822      	ldr	r2, [r4, #0]
  400730:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
  400732:	68e3      	ldr	r3, [r4, #12]
  400734:	6861      	ldr	r1, [r4, #4]
  400736:	68a2      	ldr	r2, [r4, #8]
  400738:	1a9a      	subs	r2, r3, r2
  40073a:	428a      	cmp	r2, r1
  40073c:	d901      	bls.n	400742 <ringbuffer_put+0x2e>
		rb->read_index = rb->write_index - rb->size;
  40073e:	1a59      	subs	r1, r3, r1
  400740:	60a1      	str	r1, [r4, #8]
	}

	rb->write_index++;
  400742:	3301      	adds	r3, #1
  400744:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
  400746:	2000      	movs	r0, #0
  400748:	bd38      	pop	{r3, r4, r5, pc}
  40074a:	bf00      	nop
  40074c:	004035b4 	.word	0x004035b4
  400750:	00400681 	.word	0x00400681

00400754 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
  400754:	b510      	push	{r4, lr}
	ASSERT(rb);
  400756:	4604      	mov	r4, r0
  400758:	2267      	movs	r2, #103	; 0x67
  40075a:	4905      	ldr	r1, [pc, #20]	; (400770 <ringbuffer_num+0x1c>)
  40075c:	3000      	adds	r0, #0
  40075e:	bf18      	it	ne
  400760:	2001      	movne	r0, #1
  400762:	4b04      	ldr	r3, [pc, #16]	; (400774 <ringbuffer_num+0x20>)
  400764:	4798      	blx	r3

	return rb->write_index - rb->read_index;
  400766:	68e0      	ldr	r0, [r4, #12]
  400768:	68a3      	ldr	r3, [r4, #8]
}
  40076a:	1ac0      	subs	r0, r0, r3
  40076c:	bd10      	pop	{r4, pc}
  40076e:	bf00      	nop
  400770:	004035b4 	.word	0x004035b4
  400774:	00400681 	.word	0x00400681

00400778 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
  400778:	b500      	push	{lr}
  40077a:	b083      	sub	sp, #12
/**
 * \brief Enable FPU
 */
static inline void _fpu_enable(void)
{
	CRITICAL_SECTION_ENTER()
  40077c:	a801      	add	r0, sp, #4
  40077e:	4b0e      	ldr	r3, [pc, #56]	; (4007b8 <_init_chip+0x40>)
  400780:	4798      	blx	r3
	/** Set bits 20-23 to enable CP10 and CP11 coprocessors */
	SCB->CPACR |= (0xFu << 20);
  400782:	4a0e      	ldr	r2, [pc, #56]	; (4007bc <_init_chip+0x44>)
  400784:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
  400788:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  40078c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
  400790:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  400794:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	CRITICAL_SECTION_LEAVE()
  400798:	a801      	add	r0, sp, #4
  40079a:	4b09      	ldr	r3, [pc, #36]	; (4007c0 <_init_chip+0x48>)
  40079c:	4798      	blx	r3

static inline void hri_efc_write_EEFC_FMR_FWS_bf(const void *const hw, hri_efc_eefc_fmr_reg_t data)
{
	uint32_t tmp;
	EFC_CRITICAL_SECTION_ENTER();
	tmp = ((Efc *)hw)->EEFC_FMR;
  40079e:	4a09      	ldr	r2, [pc, #36]	; (4007c4 <_init_chip+0x4c>)
  4007a0:	6813      	ldr	r3, [r2, #0]
	tmp &= ~EEFC_FMR_FWS_Msk;
  4007a2:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
	tmp |= EEFC_FMR_FWS(data);
  4007a6:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
	((Efc *)hw)->EEFC_FMR = tmp;
  4007aa:	6013      	str	r3, [r2, #0]
#if CONF_DMA_ENABLE
	_pmc_enable_periph_clock(ID_XDMAC);
	_dma_init();

#endif
	_pmc_init();
  4007ac:	4b06      	ldr	r3, [pc, #24]	; (4007c8 <_init_chip+0x50>)
  4007ae:	4798      	blx	r3
}
  4007b0:	b003      	add	sp, #12
  4007b2:	f85d fb04 	ldr.w	pc, [sp], #4
  4007b6:	bf00      	nop
  4007b8:	0040036d 	.word	0x0040036d
  4007bc:	e000ed00 	.word	0xe000ed00
  4007c0:	0040037b 	.word	0x0040037b
  4007c4:	400e0c00 	.word	0x400e0c00
  4007c8:	004007cd 	.word	0x004007cd

004007cc <_pmc_init>:
	PMC_CRITICAL_SECTION_LEAVE();
}

static inline hri_pmc_ckgr_mor_reg_t hri_pmc_read_CKGR_MOR_reg(const void *const hw)
{
	return ((Pmc *)hw)->CKGR_MOR;
  4007cc:	491d      	ldr	r1, [pc, #116]	; (400844 <_pmc_init+0x78>)
  4007ce:	6a0a      	ldr	r2, [r1, #32]
	/* Enable Main XTAL oscillator */
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTEN;
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY | CKGR_MOR_MOSCSEL;
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
#else
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTBY;
  4007d0:	f022 0202 	bic.w	r2, r2, #2
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(CONF_XOSC20M_STARTUP_TIME);
  4007d4:	4b1c      	ldr	r3, [pc, #112]	; (400848 <_pmc_init+0x7c>)
  4007d6:	4313      	orrs	r3, r2
	((Pmc *)hw)->CKGR_MOR = data;
  4007d8:	620b      	str	r3, [r1, #32]
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MOSCXTS) > 0;
  4007da:	460a      	mov	r2, r1
  4007dc:	6e93      	ldr	r3, [r2, #104]	; 0x68
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
	while (!hri_pmc_get_SR_MOSCXTS_bit(PMC)) {
  4007de:	f013 0f01 	tst.w	r3, #1
  4007e2:	d0fb      	beq.n	4007dc <_pmc_init+0x10>
	((Pmc *)hw)->CKGR_MOR |= mask;
  4007e4:	4b17      	ldr	r3, [pc, #92]	; (400844 <_pmc_init+0x78>)
  4007e6:	6a19      	ldr	r1, [r3, #32]
  4007e8:	4a18      	ldr	r2, [pc, #96]	; (40084c <_pmc_init+0x80>)
  4007ea:	430a      	orrs	r2, r1
  4007ec:	621a      	str	r2, [r3, #32]

static inline void hri_pmc_write_CKGR_PLLAR_MULA_bf(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->CKGR_PLLAR;
  4007ee:	6a99      	ldr	r1, [r3, #40]	; 0x28
	tmp &= ~CKGR_PLLAR_MULA_Msk;
  4007f0:	4a17      	ldr	r2, [pc, #92]	; (400850 <_pmc_init+0x84>)
  4007f2:	400a      	ands	r2, r1
	tmp |= CKGR_PLLAR_MULA(data);
	((Pmc *)hw)->CKGR_PLLAR = tmp;
  4007f4:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline void hri_pmc_write_CKGR_PLLAR_reg(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	PMC_CRITICAL_SECTION_ENTER();
	((Pmc *)hw)->CKGR_PLLAR = data;
  4007f6:	4a17      	ldr	r2, [pc, #92]	; (400854 <_pmc_init+0x88>)
  4007f8:	629a      	str	r2, [r3, #40]	; 0x28
	return (((Pmc *)hw)->PMC_SR & PMC_SR_LOCKA) > 0;
  4007fa:	461a      	mov	r2, r3
  4007fc:	6e93      	ldr	r3, [r2, #104]	; 0x68
#if (CONF_PLLACK_ENABLE == 1)
	data = CKGR_PLLAR_MULA(CONF_PLLACK_MUL - 1) | CKGR_PLLAR_DIVA(CONF_PLLACK_DIV) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
	/* Stop PLL first */
	hri_pmc_write_CKGR_PLLAR_MULA_bf(PMC, 0);
	hri_pmc_write_CKGR_PLLAR_reg(PMC, (CKGR_PLLAR_ONE | data));
	while (!hri_pmc_get_SR_LOCKA_bit(PMC)) {
  4007fe:	f013 0f02 	tst.w	r3, #2
  400802:	d0fb      	beq.n	4007fc <_pmc_init+0x30>

static inline void hri_pmc_write_MCKR_PRES_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400804:	4a0f      	ldr	r2, [pc, #60]	; (400844 <_pmc_init+0x78>)
  400806:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_PRES_Msk;
  400808:	f023 0370 	bic.w	r3, r3, #112	; 0x70
	tmp |= PMC_MCKR_PRES(data);
	((Pmc *)hw)->PMC_MCKR = tmp;
  40080c:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  40080e:	6e93      	ldr	r3, [r2, #104]	; 0x68
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
		/* Wait until master clock is ready */
	}
#elif ((CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_PLLACK) || (CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_UPLLCKDIV))
	hri_pmc_write_MCKR_PRES_bf(PMC, CONF_MCKR_PRESC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400810:	f013 0f08 	tst.w	r3, #8
  400814:	d0fb      	beq.n	40080e <_pmc_init+0x42>

static inline void hri_pmc_write_MCKR_MDIV_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400816:	4a0b      	ldr	r2, [pc, #44]	; (400844 <_pmc_init+0x78>)
  400818:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_MDIV_Msk;
  40081a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
	tmp |= PMC_MCKR_MDIV(data);
  40081e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Pmc *)hw)->PMC_MCKR = tmp;
  400822:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400824:	6e93      	ldr	r3, [r2, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_MDIV_bf(PMC, CONF_MCK_DIV);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400826:	f013 0f08 	tst.w	r3, #8
  40082a:	d0fb      	beq.n	400824 <_pmc_init+0x58>
	tmp = ((Pmc *)hw)->PMC_MCKR;
  40082c:	4a05      	ldr	r2, [pc, #20]	; (400844 <_pmc_init+0x78>)
  40082e:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_CSS_Msk;
  400830:	f023 0303 	bic.w	r3, r3, #3
	tmp |= PMC_MCKR_CSS(data);
  400834:	f043 0302 	orr.w	r3, r3, #2
	((Pmc *)hw)->PMC_MCKR = tmp;
  400838:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  40083a:	6e93      	ldr	r3, [r2, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_CSS_bf(PMC, CONF_CLK_GEN_MCKR_SRC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  40083c:	f013 0f08 	tst.w	r3, #8
  400840:	d0fb      	beq.n	40083a <_pmc_init+0x6e>
{
	_pmc_init_sources();
	_pmc_init_master_clock();
	_pmc_init_program_clock();
	_pmc_init_fs_clock();
}
  400842:	4770      	bx	lr
  400844:	400e0600 	.word	0x400e0600
  400848:	00373e01 	.word	0x00373e01
  40084c:	01370000 	.word	0x01370000
  400850:	f800ffff 	.word	0xf800ffff
  400854:	20183f01 	.word	0x20183f01

00400858 <_usart_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given usart hardware instance
 */
static uint8_t _usart_get_hardware_index(const void *const hw)
{
  400858:	b510      	push	{r4, lr}
	ASSERT(hw);
  40085a:	4604      	mov	r4, r0
  40085c:	f240 222f 	movw	r2, #559	; 0x22f
  400860:	4905      	ldr	r1, [pc, #20]	; (400878 <_usart_get_hardware_index+0x20>)
  400862:	3000      	adds	r0, #0
  400864:	bf18      	it	ne
  400866:	2001      	movne	r0, #1
  400868:	4b04      	ldr	r3, [pc, #16]	; (40087c <_usart_get_hardware_index+0x24>)
  40086a:	4798      	blx	r3

#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)USART0) / sizeof(Usart);
#endif

	return ((uint32_t)hw - (uint32_t)USART0) >> 14;
  40086c:	4804      	ldr	r0, [pc, #16]	; (400880 <_usart_get_hardware_index+0x28>)
  40086e:	4420      	add	r0, r4
}
  400870:	f3c0 3087 	ubfx	r0, r0, #14, #8
  400874:	bd10      	pop	{r4, pc}
  400876:	bf00      	nop
  400878:	004035e4 	.word	0x004035e4
  40087c:	00400681 	.word	0x00400681
  400880:	bffdc000 	.word	0xbffdc000

00400884 <_get_usart_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given usart hardware instance
 */
static uint8_t _get_usart_index(const void *const hw)
{
  400884:	b510      	push	{r4, lr}
	ASSERT(hw);
  400886:	4604      	mov	r4, r0
  400888:	f44f 722d 	mov.w	r2, #692	; 0x2b4
  40088c:	4909      	ldr	r1, [pc, #36]	; (4008b4 <_get_usart_index+0x30>)
  40088e:	3000      	adds	r0, #0
  400890:	bf18      	it	ne
  400892:	2001      	movne	r0, #1
  400894:	4b08      	ldr	r3, [pc, #32]	; (4008b8 <_get_usart_index+0x34>)
  400896:	4798      	blx	r3
	uint8_t usart_offset = _usart_get_hardware_index(hw);
  400898:	4620      	mov	r0, r4
  40089a:	4b08      	ldr	r3, [pc, #32]	; (4008bc <_get_usart_index+0x38>)
  40089c:	4798      	blx	r3
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
		if (_usarts[i].number == usart_offset) {
  40089e:	2801      	cmp	r0, #1
  4008a0:	d005      	beq.n	4008ae <_get_usart_index+0x2a>
			return i;
		}
	}

	ASSERT(false);
  4008a2:	f240 22be 	movw	r2, #702	; 0x2be
  4008a6:	4903      	ldr	r1, [pc, #12]	; (4008b4 <_get_usart_index+0x30>)
  4008a8:	2000      	movs	r0, #0
  4008aa:	4b03      	ldr	r3, [pc, #12]	; (4008b8 <_get_usart_index+0x34>)
  4008ac:	4798      	blx	r3
	return 0;
}
  4008ae:	2000      	movs	r0, #0
  4008b0:	bd10      	pop	{r4, pc}
  4008b2:	bf00      	nop
  4008b4:	004035e4 	.word	0x004035e4
  4008b8:	00400681 	.word	0x00400681
  4008bc:	00400859 	.word	0x00400859

004008c0 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
  4008c0:	b510      	push	{r4, lr}
	ASSERT(hw);
  4008c2:	4604      	mov	r4, r0
  4008c4:	f240 22cb 	movw	r2, #715	; 0x2cb
  4008c8:	4911      	ldr	r1, [pc, #68]	; (400910 <_usart_init+0x50>)
  4008ca:	3000      	adds	r0, #0
  4008cc:	bf18      	it	ne
  4008ce:	2001      	movne	r0, #1
  4008d0:	4b10      	ldr	r3, [pc, #64]	; (400914 <_usart_init+0x54>)
  4008d2:	4798      	blx	r3
	uint8_t i = _get_usart_index(hw);
  4008d4:	4620      	mov	r0, r4
  4008d6:	4b10      	ldr	r3, [pc, #64]	; (400918 <_usart_init+0x58>)
  4008d8:	4798      	blx	r3
}

static inline void hri_usart_write_US_WPMR_reg(const void *const hw, hri_usart_us_wpmr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_WPMR = data;
  4008da:	4b10      	ldr	r3, [pc, #64]	; (40091c <_usart_init+0x5c>)
  4008dc:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
	((Usart *)hw)->US_MR = data;
  4008e0:	2300      	movs	r3, #0
  4008e2:	6063      	str	r3, [r4, #4]
	((Usart *)hw)->US_RTOR = data;
  4008e4:	6263      	str	r3, [r4, #36]	; 0x24
	((Usart *)hw)->US_TTGR = data;
  4008e6:	62a3      	str	r3, [r4, #40]	; 0x28
}

static inline void hri_usart_write_US_CR_reg(const void *const hw, hri_usart_us_cr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_CR = data;
  4008e8:	22ac      	movs	r2, #172	; 0xac
  4008ea:	6022      	str	r2, [r4, #0]
  4008ec:	f44f 7280 	mov.w	r2, #256	; 0x100
  4008f0:	6022      	str	r2, [r4, #0]
  4008f2:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  4008f6:	6022      	str	r2, [r4, #0]
	/* Reset status bits. */
	hri_usart_write_US_CR_reg(hw, US_CR_RSTSTA);
	/* Turn off RTS and DTR if exist. */
	hri_usart_write_US_CR_reg(hw, US_CR_USART_RTSDIS);

	hri_usart_write_US_MR_reg(hw, _usarts[i].us_mr);
  4008f8:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  4008fc:	4a08      	ldr	r2, [pc, #32]	; (400920 <_usart_init+0x60>)
  4008fe:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  400902:	6842      	ldr	r2, [r0, #4]
	((Usart *)hw)->US_MR = data;
  400904:	6062      	str	r2, [r4, #4]
	((Usart *)hw)->US_BRGR = data;
  400906:	4a07      	ldr	r2, [pc, #28]	; (400924 <_usart_init+0x64>)
  400908:	6222      	str	r2, [r4, #32]
	hri_usart_write_US_BRGR_reg(hw, _usarts[i].us_brgr);

	return ERR_NONE;
}
  40090a:	4618      	mov	r0, r3
  40090c:	bd10      	pop	{r4, pc}
  40090e:	bf00      	nop
  400910:	004035e4 	.word	0x004035e4
  400914:	00400681 	.word	0x00400681
  400918:	00400885 	.word	0x00400885
  40091c:	55534100 	.word	0x55534100
  400920:	004035d8 	.word	0x004035d8
  400924:	000403d0 	.word	0x000403d0

00400928 <_usart_get_irq_num>:
{
  400928:	b510      	push	{r4, lr}
	ASSERT(hw);
  40092a:	4604      	mov	r4, r0
  40092c:	22ae      	movs	r2, #174	; 0xae
  40092e:	4906      	ldr	r1, [pc, #24]	; (400948 <_usart_get_irq_num+0x20>)
  400930:	3000      	adds	r0, #0
  400932:	bf18      	it	ne
  400934:	2001      	movne	r0, #1
  400936:	4b05      	ldr	r3, [pc, #20]	; (40094c <_usart_get_irq_num+0x24>)
  400938:	4798      	blx	r3
	return USART0_IRQn + _usart_get_hardware_index(hw);
  40093a:	4620      	mov	r0, r4
  40093c:	4b04      	ldr	r3, [pc, #16]	; (400950 <_usart_get_irq_num+0x28>)
  40093e:	4798      	blx	r3
  400940:	300d      	adds	r0, #13
}
  400942:	b2c0      	uxtb	r0, r0
  400944:	bd10      	pop	{r4, pc}
  400946:	bf00      	nop
  400948:	004035e4 	.word	0x004035e4
  40094c:	00400681 	.word	0x00400681
  400950:	00400859 	.word	0x00400859

00400954 <_usart_async_init>:
{
  400954:	b570      	push	{r4, r5, r6, lr}
  400956:	460c      	mov	r4, r1
	ASSERT(device);
  400958:	4606      	mov	r6, r0
  40095a:	22d1      	movs	r2, #209	; 0xd1
  40095c:	4923      	ldr	r1, [pc, #140]	; (4009ec <_usart_async_init+0x98>)
  40095e:	3000      	adds	r0, #0
  400960:	bf18      	it	ne
  400962:	2001      	movne	r0, #1
  400964:	4b22      	ldr	r3, [pc, #136]	; (4009f0 <_usart_async_init+0x9c>)
  400966:	4798      	blx	r3
	init_status = _usart_init(hw);
  400968:	4620      	mov	r0, r4
  40096a:	4b22      	ldr	r3, [pc, #136]	; (4009f4 <_usart_async_init+0xa0>)
  40096c:	4798      	blx	r3
	if (init_status) {
  40096e:	4605      	mov	r5, r0
  400970:	b108      	cbz	r0, 400976 <_usart_async_init+0x22>
}
  400972:	4628      	mov	r0, r5
  400974:	bd70      	pop	{r4, r5, r6, pc}
	device->hw = hw;
  400976:	61b4      	str	r4, [r6, #24]
	if (hw == USART1) {
  400978:	4b1f      	ldr	r3, [pc, #124]	; (4009f8 <_usart_async_init+0xa4>)
  40097a:	429c      	cmp	r4, r3
  40097c:	d033      	beq.n	4009e6 <_usart_async_init+0x92>
	NVIC_DisableIRQ((IRQn_Type)_usart_get_irq_num(hw));
  40097e:	4620      	mov	r0, r4
  400980:	4b1e      	ldr	r3, [pc, #120]	; (4009fc <_usart_async_init+0xa8>)
  400982:	4798      	blx	r3
  400984:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
  400986:	2b00      	cmp	r3, #0
  400988:	db0d      	blt.n	4009a6 <_usart_async_init+0x52>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  40098a:	095b      	lsrs	r3, r3, #5
  40098c:	f000 001f 	and.w	r0, r0, #31
  400990:	2201      	movs	r2, #1
  400992:	fa02 f000 	lsl.w	r0, r2, r0
  400996:	3320      	adds	r3, #32
  400998:	4a19      	ldr	r2, [pc, #100]	; (400a00 <_usart_async_init+0xac>)
  40099a:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
  40099e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  4009a2:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ((IRQn_Type)_usart_get_irq_num(hw));
  4009a6:	4620      	mov	r0, r4
  4009a8:	4b14      	ldr	r3, [pc, #80]	; (4009fc <_usart_async_init+0xa8>)
  4009aa:	4798      	blx	r3
  4009ac:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
  4009ae:	2b00      	cmp	r3, #0
  4009b0:	db09      	blt.n	4009c6 <_usart_async_init+0x72>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  4009b2:	095b      	lsrs	r3, r3, #5
  4009b4:	f000 001f 	and.w	r0, r0, #31
  4009b8:	2201      	movs	r2, #1
  4009ba:	fa02 f000 	lsl.w	r0, r2, r0
  4009be:	3360      	adds	r3, #96	; 0x60
  4009c0:	4a0f      	ldr	r2, [pc, #60]	; (400a00 <_usart_async_init+0xac>)
  4009c2:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
	NVIC_EnableIRQ((IRQn_Type)_usart_get_irq_num(hw));
  4009c6:	4620      	mov	r0, r4
  4009c8:	4b0c      	ldr	r3, [pc, #48]	; (4009fc <_usart_async_init+0xa8>)
  4009ca:	4798      	blx	r3
  4009cc:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
  4009ce:	2b00      	cmp	r3, #0
  4009d0:	dbcf      	blt.n	400972 <_usart_async_init+0x1e>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  4009d2:	095b      	lsrs	r3, r3, #5
  4009d4:	f000 001f 	and.w	r0, r0, #31
  4009d8:	2201      	movs	r2, #1
  4009da:	fa02 f000 	lsl.w	r0, r2, r0
  4009de:	4a08      	ldr	r2, [pc, #32]	; (400a00 <_usart_async_init+0xac>)
  4009e0:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  4009e4:	e7c5      	b.n	400972 <_usart_async_init+0x1e>
		_usart1_dev = dev;
  4009e6:	4b07      	ldr	r3, [pc, #28]	; (400a04 <_usart_async_init+0xb0>)
  4009e8:	601e      	str	r6, [r3, #0]
  4009ea:	e7c8      	b.n	40097e <_usart_async_init+0x2a>
  4009ec:	004035e4 	.word	0x004035e4
  4009f0:	00400681 	.word	0x00400681
  4009f4:	004008c1 	.word	0x004008c1
  4009f8:	40028000 	.word	0x40028000
  4009fc:	00400929 	.word	0x00400929
  400a00:	e000e100 	.word	0xe000e100
  400a04:	20400024 	.word	0x20400024

00400a08 <_usart_async_enable>:
{
  400a08:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
  400a0a:	4e0a      	ldr	r6, [pc, #40]	; (400a34 <_usart_async_enable+0x2c>)
  400a0c:	4604      	mov	r4, r0
  400a0e:	f240 1213 	movw	r2, #275	; 0x113
  400a12:	4631      	mov	r1, r6
  400a14:	3000      	adds	r0, #0
  400a16:	bf18      	it	ne
  400a18:	2001      	movne	r0, #1
  400a1a:	4d07      	ldr	r5, [pc, #28]	; (400a38 <_usart_async_enable+0x30>)
  400a1c:	47a8      	blx	r5
	_usart_enable(device->hw);
  400a1e:	69a4      	ldr	r4, [r4, #24]
 *
 * \param[in] hw The pointer to hardware instance
 */
static inline void _usart_enable(void *const hw)
{
	ASSERT(hw);
  400a20:	f44f 723d 	mov.w	r2, #756	; 0x2f4
  400a24:	4631      	mov	r1, r6
  400a26:	1c20      	adds	r0, r4, #0
  400a28:	bf18      	it	ne
  400a2a:	2001      	movne	r0, #1
  400a2c:	47a8      	blx	r5
	((Usart *)hw)->US_CR = data;
  400a2e:	2350      	movs	r3, #80	; 0x50
  400a30:	6023      	str	r3, [r4, #0]
  400a32:	bd70      	pop	{r4, r5, r6, pc}
  400a34:	004035e4 	.word	0x004035e4
  400a38:	00400681 	.word	0x00400681

00400a3c <_usart_async_write_byte>:
{
  400a3c:	b538      	push	{r3, r4, r5, lr}
  400a3e:	460c      	mov	r4, r1
	ASSERT(device);
  400a40:	4605      	mov	r5, r0
  400a42:	f240 12b5 	movw	r2, #437	; 0x1b5
  400a46:	4904      	ldr	r1, [pc, #16]	; (400a58 <_usart_async_write_byte+0x1c>)
  400a48:	3000      	adds	r0, #0
  400a4a:	bf18      	it	ne
  400a4c:	2001      	movne	r0, #1
  400a4e:	4b03      	ldr	r3, [pc, #12]	; (400a5c <_usart_async_write_byte+0x20>)
  400a50:	4798      	blx	r3
	hri_usart_write_US_THR_reg(device->hw, (hri_usart_us_thr_reg_t)data);
  400a52:	69ab      	ldr	r3, [r5, #24]
}

static inline void hri_usart_write_US_THR_reg(const void *const hw, hri_usart_us_thr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_THR = data;
  400a54:	61dc      	str	r4, [r3, #28]
  400a56:	bd38      	pop	{r3, r4, r5, pc}
  400a58:	004035e4 	.word	0x004035e4
  400a5c:	00400681 	.word	0x00400681

00400a60 <_usart_async_enable_byte_sent_irq>:
{
  400a60:	b510      	push	{r4, lr}
	ASSERT(device);
  400a62:	4604      	mov	r4, r0
  400a64:	f240 221d 	movw	r2, #541	; 0x21d
  400a68:	4904      	ldr	r1, [pc, #16]	; (400a7c <_usart_async_enable_byte_sent_irq+0x1c>)
  400a6a:	3000      	adds	r0, #0
  400a6c:	bf18      	it	ne
  400a6e:	2001      	movne	r0, #1
  400a70:	4b03      	ldr	r3, [pc, #12]	; (400a80 <_usart_async_enable_byte_sent_irq+0x20>)
  400a72:	4798      	blx	r3
	hri_usart_set_US_IMR_TXRDY_bit(device->hw);
  400a74:	69a3      	ldr	r3, [r4, #24]
	((Usart *)hw)->US_IER = US_IMR_TXRDY;
  400a76:	2202      	movs	r2, #2
  400a78:	609a      	str	r2, [r3, #8]
  400a7a:	bd10      	pop	{r4, pc}
  400a7c:	004035e4 	.word	0x004035e4
  400a80:	00400681 	.word	0x00400681

00400a84 <_usart_async_enable_tx_done_irq>:
{
  400a84:	b510      	push	{r4, lr}
	ASSERT(device);
  400a86:	4604      	mov	r4, r0
  400a88:	f240 2226 	movw	r2, #550	; 0x226
  400a8c:	4905      	ldr	r1, [pc, #20]	; (400aa4 <_usart_async_enable_tx_done_irq+0x20>)
  400a8e:	3000      	adds	r0, #0
  400a90:	bf18      	it	ne
  400a92:	2001      	movne	r0, #1
  400a94:	4b04      	ldr	r3, [pc, #16]	; (400aa8 <_usart_async_enable_tx_done_irq+0x24>)
  400a96:	4798      	blx	r3
	hri_usart_set_US_IMR_TXEMPTY_bit(device->hw);
  400a98:	69a3      	ldr	r3, [r4, #24]
	((Usart *)hw)->US_IER = US_IMR_TXEMPTY;
  400a9a:	f44f 7200 	mov.w	r2, #512	; 0x200
  400a9e:	609a      	str	r2, [r3, #8]
  400aa0:	bd10      	pop	{r4, pc}
  400aa2:	bf00      	nop
  400aa4:	004035e4 	.word	0x004035e4
  400aa8:	00400681 	.word	0x00400681

00400aac <_usart_async_set_irq_state>:
{
  400aac:	b570      	push	{r4, r5, r6, lr}
  400aae:	460c      	mov	r4, r1
  400ab0:	4616      	mov	r6, r2
	ASSERT(device);
  400ab2:	4605      	mov	r5, r0
  400ab4:	f44f 7214 	mov.w	r2, #592	; 0x250
  400ab8:	491a      	ldr	r1, [pc, #104]	; (400b24 <_usart_async_set_irq_state+0x78>)
  400aba:	3000      	adds	r0, #0
  400abc:	bf18      	it	ne
  400abe:	2001      	movne	r0, #1
  400ac0:	4b19      	ldr	r3, [pc, #100]	; (400b28 <_usart_async_set_irq_state+0x7c>)
  400ac2:	4798      	blx	r3
	if (state) {
  400ac4:	b1be      	cbz	r6, 400af6 <_usart_async_set_irq_state+0x4a>
		if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
  400ac6:	f014 0ffd 	tst.w	r4, #253	; 0xfd
  400aca:	d004      	beq.n	400ad6 <_usart_async_set_irq_state+0x2a>
		} else if (USART_ASYNC_RX_DONE == type) {
  400acc:	2c01      	cmp	r4, #1
  400ace:	d00a      	beq.n	400ae6 <_usart_async_set_irq_state+0x3a>
		} else if (USART_ASYNC_ERROR == type) {
  400ad0:	2c03      	cmp	r4, #3
  400ad2:	d00c      	beq.n	400aee <_usart_async_set_irq_state+0x42>
  400ad4:	bd70      	pop	{r4, r5, r6, pc}
			hri_usart_set_US_IMR_TXRDY_bit(device->hw);
  400ad6:	69ab      	ldr	r3, [r5, #24]
	((Usart *)hw)->US_IER = US_IMR_TXRDY;
  400ad8:	2202      	movs	r2, #2
  400ada:	609a      	str	r2, [r3, #8]
			hri_usart_set_US_IMR_TXEMPTY_bit(device->hw);
  400adc:	69ab      	ldr	r3, [r5, #24]
	((Usart *)hw)->US_IER = US_IMR_TXEMPTY;
  400ade:	f44f 7200 	mov.w	r2, #512	; 0x200
  400ae2:	609a      	str	r2, [r3, #8]
  400ae4:	bd70      	pop	{r4, r5, r6, pc}
			hri_usart_set_US_IMR_RXRDY_bit(device->hw);
  400ae6:	69ab      	ldr	r3, [r5, #24]
	((Usart *)hw)->US_IER = US_IMR_RXRDY;
  400ae8:	2201      	movs	r2, #1
  400aea:	609a      	str	r2, [r3, #8]
  400aec:	bd70      	pop	{r4, r5, r6, pc}
			    device->hw, US_CSR_OVRE | US_CSR_USART_LIN_FRAME | US_CSR_USART_LIN_PARE | US_CSR_USART_MANERR);
  400aee:	69ab      	ldr	r3, [r5, #24]
	((Usart *)hw)->US_IER = mask;
  400af0:	4a0e      	ldr	r2, [pc, #56]	; (400b2c <_usart_async_set_irq_state+0x80>)
  400af2:	609a      	str	r2, [r3, #8]
  400af4:	bd70      	pop	{r4, r5, r6, pc}
		if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
  400af6:	f014 0ffd 	tst.w	r4, #253	; 0xfd
  400afa:	d007      	beq.n	400b0c <_usart_async_set_irq_state+0x60>
		} else if (USART_ASYNC_RX_DONE == type) {
  400afc:	2c01      	cmp	r4, #1
  400afe:	d00d      	beq.n	400b1c <_usart_async_set_irq_state+0x70>
		} else if (USART_ASYNC_ERROR == type) {
  400b00:	2c03      	cmp	r4, #3
  400b02:	d1e7      	bne.n	400ad4 <_usart_async_set_irq_state+0x28>
			    device->hw, US_CSR_OVRE | US_CSR_USART_LIN_FRAME | US_CSR_USART_LIN_PARE | US_CSR_USART_MANERR);
  400b04:	69ab      	ldr	r3, [r5, #24]
	((Usart *)hw)->US_IDR = mask;
  400b06:	4a09      	ldr	r2, [pc, #36]	; (400b2c <_usart_async_set_irq_state+0x80>)
  400b08:	60da      	str	r2, [r3, #12]
}
  400b0a:	e7e3      	b.n	400ad4 <_usart_async_set_irq_state+0x28>
			hri_usart_clear_US_IMR_TXRDY_bit(device->hw);
  400b0c:	69ab      	ldr	r3, [r5, #24]
	((Usart *)hw)->US_IDR = US_IMR_TXRDY;
  400b0e:	2202      	movs	r2, #2
  400b10:	60da      	str	r2, [r3, #12]
			hri_usart_clear_US_IMR_TXEMPTY_bit(device->hw);
  400b12:	69ab      	ldr	r3, [r5, #24]
	((Usart *)hw)->US_IDR = US_IMR_TXEMPTY;
  400b14:	f44f 7200 	mov.w	r2, #512	; 0x200
  400b18:	60da      	str	r2, [r3, #12]
  400b1a:	bd70      	pop	{r4, r5, r6, pc}
			hri_usart_clear_US_IMR_RXRDY_bit(device->hw);
  400b1c:	69ab      	ldr	r3, [r5, #24]
	((Usart *)hw)->US_IDR = US_IMR_RXRDY;
  400b1e:	2201      	movs	r2, #1
  400b20:	60da      	str	r2, [r3, #12]
  400b22:	bd70      	pop	{r4, r5, r6, pc}
  400b24:	004035e4 	.word	0x004035e4
  400b28:	00400681 	.word	0x00400681
  400b2c:	010000e0 	.word	0x010000e0

00400b30 <_usart_get_usart_async>:
}
  400b30:	2000      	movs	r0, #0
  400b32:	4770      	bx	lr

00400b34 <USART1_Handler>:
{
  400b34:	b510      	push	{r4, lr}
	_usart_interrupt_handler(_usart1_dev);
  400b36:	4b25      	ldr	r3, [pc, #148]	; (400bcc <USART1_Handler+0x98>)
  400b38:	681c      	ldr	r4, [r3, #0]
	ASSERT(device);
  400b3a:	f240 2289 	movw	r2, #649	; 0x289
  400b3e:	4924      	ldr	r1, [pc, #144]	; (400bd0 <USART1_Handler+0x9c>)
  400b40:	1c20      	adds	r0, r4, #0
  400b42:	bf18      	it	ne
  400b44:	2001      	movne	r0, #1
  400b46:	4b23      	ldr	r3, [pc, #140]	; (400bd4 <USART1_Handler+0xa0>)
  400b48:	4798      	blx	r3
	void *hw = device->hw;
  400b4a:	69a3      	ldr	r3, [r4, #24]
	return (((Usart *)hw)->US_CSR & US_CSR_TXRDY) > 0;
  400b4c:	695a      	ldr	r2, [r3, #20]
	if (hri_usart_get_US_CSR_TXRDY_bit(hw) && hri_usart_get_US_IMR_TXRDY_bit(hw)) {
  400b4e:	f012 0f02 	tst.w	r2, #2
  400b52:	d003      	beq.n	400b5c <USART1_Handler+0x28>
	return (((Usart *)hw)->US_IMR & US_IMR_TXRDY) >> US_IMR_TXRDY_Pos;
  400b54:	691a      	ldr	r2, [r3, #16]
  400b56:	f012 0f02 	tst.w	r2, #2
  400b5a:	d118      	bne.n	400b8e <USART1_Handler+0x5a>
	return (((Usart *)hw)->US_CSR & US_CSR_TXEMPTY) > 0;
  400b5c:	695a      	ldr	r2, [r3, #20]
	} else if (hri_usart_get_US_CSR_TXEMPTY_bit(hw) && hri_usart_get_US_IMR_TXEMPTY_bit(hw)) {
  400b5e:	f412 7f00 	tst.w	r2, #512	; 0x200
  400b62:	d003      	beq.n	400b6c <USART1_Handler+0x38>
	return (((Usart *)hw)->US_IMR & US_IMR_TXEMPTY) >> US_IMR_TXEMPTY_Pos;
  400b64:	691a      	ldr	r2, [r3, #16]
  400b66:	f412 7f00 	tst.w	r2, #512	; 0x200
  400b6a:	d116      	bne.n	400b9a <USART1_Handler+0x66>
	return (((Usart *)hw)->US_CSR & US_CSR_RXRDY) > 0;
  400b6c:	695a      	ldr	r2, [r3, #20]
	} else if (hri_usart_get_US_CSR_RXRDY_bit(hw) && hri_usart_get_US_IMR_RXRDY_bit(hw)) {
  400b6e:	f012 0f01 	tst.w	r2, #1
  400b72:	d01f      	beq.n	400bb4 <USART1_Handler+0x80>
	return (((Usart *)hw)->US_IMR & US_IMR_RXRDY) >> US_IMR_RXRDY_Pos;
  400b74:	691a      	ldr	r2, [r3, #16]
  400b76:	f012 0f01 	tst.w	r2, #1
  400b7a:	d01b      	beq.n	400bb4 <USART1_Handler+0x80>
	return ((Usart *)hw)->US_CSR;
  400b7c:	6959      	ldr	r1, [r3, #20]
		if (hri_usart_read_US_CSR_reg(hw) &
  400b7e:	4a16      	ldr	r2, [pc, #88]	; (400bd8 <USART1_Handler+0xa4>)
  400b80:	4211      	tst	r1, r2
  400b82:	d011      	beq.n	400ba8 <USART1_Handler+0x74>
	return ((Usart *)hw)->US_RHR;
  400b84:	699a      	ldr	r2, [r3, #24]
	((Usart *)hw)->US_CR = data;
  400b86:	f44f 7280 	mov.w	r2, #256	; 0x100
  400b8a:	601a      	str	r2, [r3, #0]
  400b8c:	bd10      	pop	{r4, pc}
	((Usart *)hw)->US_IDR = US_IMR_TXRDY;
  400b8e:	2202      	movs	r2, #2
  400b90:	60da      	str	r2, [r3, #12]
		device->usart_cb.tx_byte_sent(device);
  400b92:	6823      	ldr	r3, [r4, #0]
  400b94:	4620      	mov	r0, r4
  400b96:	4798      	blx	r3
  400b98:	bd10      	pop	{r4, pc}
	((Usart *)hw)->US_IDR = US_IMR_TXEMPTY;
  400b9a:	f44f 7200 	mov.w	r2, #512	; 0x200
  400b9e:	60da      	str	r2, [r3, #12]
		device->usart_cb.tx_done_cb(device);
  400ba0:	68a3      	ldr	r3, [r4, #8]
  400ba2:	4620      	mov	r0, r4
  400ba4:	4798      	blx	r3
  400ba6:	bd10      	pop	{r4, pc}
	return ((Usart *)hw)->US_RHR;
  400ba8:	6999      	ldr	r1, [r3, #24]
		device->usart_cb.rx_done_cb(device, (uint8_t)hri_usart_read_US_RHR_reg(hw));
  400baa:	6863      	ldr	r3, [r4, #4]
  400bac:	b2c9      	uxtb	r1, r1
  400bae:	4620      	mov	r0, r4
  400bb0:	4798      	blx	r3
  400bb2:	bd10      	pop	{r4, pc}
	return ((Usart *)hw)->US_CSR;
  400bb4:	6959      	ldr	r1, [r3, #20]
	} else if (hri_usart_read_US_CSR_reg(hw) &
  400bb6:	4a08      	ldr	r2, [pc, #32]	; (400bd8 <USART1_Handler+0xa4>)
  400bb8:	4211      	tst	r1, r2
  400bba:	d100      	bne.n	400bbe <USART1_Handler+0x8a>
  400bbc:	bd10      	pop	{r4, pc}
	((Usart *)hw)->US_CR = data;
  400bbe:	f44f 7280 	mov.w	r2, #256	; 0x100
  400bc2:	601a      	str	r2, [r3, #0]
		device->usart_cb.error_cb(device);
  400bc4:	68e3      	ldr	r3, [r4, #12]
  400bc6:	4620      	mov	r0, r4
  400bc8:	4798      	blx	r3
}
  400bca:	e7f7      	b.n	400bbc <USART1_Handler+0x88>
  400bcc:	20400024 	.word	0x20400024
  400bd0:	004035e4 	.word	0x004035e4
  400bd4:	00400681 	.word	0x00400681
  400bd8:	010000e0 	.word	0x010000e0

00400bdc <task_led>:

/**
 * OS task that blinks LED
 */
static void task_led(void *p)
{
  400bdc:	b508      	push	{r3, lr}
	tmp = ((Pio *)hw)->PIO_ODSR;
  400bde:	4c07      	ldr	r4, [pc, #28]	; (400bfc <task_led+0x20>)
	(void)p;
	for (;;) {
		gpio_toggle_pin_level(LED0);
		os_sleep(500);
  400be0:	f44f 76fa 	mov.w	r6, #500	; 0x1f4
  400be4:	4d06      	ldr	r5, [pc, #24]	; (400c00 <task_led+0x24>)
  400be6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	tmp &= mask;
  400be8:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
{
	uint32_t    bits_clear, bits_set;
	void *const hw = port_to_reg(port);

	bits_clear = hri_pio_get_ODSR_reg(hw, mask);
	bits_set   = (~bits_clear) & mask;
  400bec:	43da      	mvns	r2, r3
  400bee:	f402 0200 	and.w	r2, r2, #8388608	; 0x800000
	((Pio *)hw)->PIO_SODR = mask;
  400bf2:	6322      	str	r2, [r4, #48]	; 0x30
	((Pio *)hw)->PIO_CODR = mask;
  400bf4:	6363      	str	r3, [r4, #52]	; 0x34
  400bf6:	4630      	mov	r0, r6
  400bf8:	47a8      	blx	r5
  400bfa:	e7f4      	b.n	400be6 <task_led+0xa>
  400bfc:	400e0e00 	.word	0x400e0e00
  400c00:	0040285d 	.word	0x0040285d

00400c04 <str_write>:
{
  400c04:	b510      	push	{r4, lr}
  400c06:	4604      	mov	r4, r0
	io_write(&EDBG_COM.io, (const uint8_t *)s, strlen(s));
  400c08:	4b03      	ldr	r3, [pc, #12]	; (400c18 <str_write+0x14>)
  400c0a:	4798      	blx	r3
  400c0c:	b282      	uxth	r2, r0
  400c0e:	4621      	mov	r1, r4
  400c10:	4802      	ldr	r0, [pc, #8]	; (400c1c <str_write+0x18>)
  400c12:	4b03      	ldr	r3, [pc, #12]	; (400c20 <str_write+0x1c>)
  400c14:	4798      	blx	r3
  400c16:	bd10      	pop	{r4, pc}
  400c18:	00403573 	.word	0x00403573
  400c1c:	20400b6c 	.word	0x20400b6c
  400c20:	00400389 	.word	0x00400389

00400c24 <disp_mutex_give>:
{
  400c24:	b510      	push	{r4, lr}
	xSemaphoreGive(disp_mutex);
  400c26:	2300      	movs	r3, #0
  400c28:	461a      	mov	r2, r3
  400c2a:	4619      	mov	r1, r3
  400c2c:	4802      	ldr	r0, [pc, #8]	; (400c38 <disp_mutex_give+0x14>)
  400c2e:	6800      	ldr	r0, [r0, #0]
  400c30:	4c02      	ldr	r4, [pc, #8]	; (400c3c <disp_mutex_give+0x18>)
  400c32:	47a0      	blx	r4
  400c34:	bd10      	pop	{r4, pc}
  400c36:	bf00      	nop
  400c38:	20400028 	.word	0x20400028
  400c3c:	00401945 	.word	0x00401945

00400c40 <task_console>:

/**
 * OS task that monitor console inputs and do actions
 */
static void task_console(void *p)
{
  400c40:	b5f0      	push	{r4, r5, r6, r7, lr}
  400c42:	b083      	sub	sp, #12
	while (ERR_TIMEOUT == io_read(&EDBG_COM.io, &tmp, 1)) {
  400c44:	4d49      	ldr	r5, [pc, #292]	; (400d6c <task_console+0x12c>)
}

static void task_monitor_pause(bool pause)
{
	if (pause) {
		vTaskSuspend(xCreatedMonitorTask);
  400c46:	4e4a      	ldr	r6, [pc, #296]	; (400d70 <task_console+0x130>)
	((Pio *)hw)->PIO_SODR = mask;
  400c48:	4f4a      	ldr	r7, [pc, #296]	; (400d74 <task_console+0x134>)
  400c4a:	e00a      	b.n	400c62 <task_console+0x22>
		vTaskResume(xCreatedLedTask);
  400c4c:	6870      	ldr	r0, [r6, #4]
  400c4e:	4b4a      	ldr	r3, [pc, #296]	; (400d78 <task_console+0x138>)
  400c50:	4798      	blx	r3
			str = ("- LED blink task active.\r\n");
  400c52:	4c4a      	ldr	r4, [pc, #296]	; (400d7c <task_console+0x13c>)
	return xSemaphoreTake(disp_mutex, ~0);
  400c54:	f04f 31ff 	mov.w	r1, #4294967295
  400c58:	6830      	ldr	r0, [r6, #0]
  400c5a:	4b49      	ldr	r3, [pc, #292]	; (400d80 <task_console+0x140>)
  400c5c:	4798      	blx	r3
		if (disp_mutex_take()) {
  400c5e:	2800      	cmp	r0, #0
  400c60:	d17d      	bne.n	400d5e <task_console+0x11e>
		char  ch[2] = {0, 0};
  400c62:	2300      	movs	r3, #0
  400c64:	f88d 3004 	strb.w	r3, [sp, #4]
  400c68:	f88d 3005 	strb.w	r3, [sp, #5]
	while (ERR_TIMEOUT == io_read(&EDBG_COM.io, &tmp, 1)) {
  400c6c:	4c45      	ldr	r4, [pc, #276]	; (400d84 <task_console+0x144>)
  400c6e:	2201      	movs	r2, #1
  400c70:	f10d 0103 	add.w	r1, sp, #3
  400c74:	4628      	mov	r0, r5
  400c76:	47a0      	blx	r4
  400c78:	f110 0f08 	cmn.w	r0, #8
  400c7c:	d0f7      	beq.n	400c6e <task_console+0x2e>
	return (char)tmp;
  400c7e:	f89d 3003 	ldrb.w	r3, [sp, #3]
		ch[0]       = char_read();
  400c82:	f88d 3004 	strb.w	r3, [sp, #4]
		switch (ch[0]) {
  400c86:	3b4d      	subs	r3, #77	; 0x4d
  400c88:	2b26      	cmp	r3, #38	; 0x26
  400c8a:	d866      	bhi.n	400d5a <task_console+0x11a>
  400c8c:	a201      	add	r2, pc, #4	; (adr r2, 400c94 <task_console+0x54>)
  400c8e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400c92:	bf00      	nop
  400c94:	00400d4b 	.word	0x00400d4b
  400c98:	00400d5b 	.word	0x00400d5b
  400c9c:	00400d5b 	.word	0x00400d5b
  400ca0:	00400d5b 	.word	0x00400d5b
  400ca4:	00400d5b 	.word	0x00400d5b
  400ca8:	00400d5b 	.word	0x00400d5b
  400cac:	00400d5b 	.word	0x00400d5b
  400cb0:	00400d5b 	.word	0x00400d5b
  400cb4:	00400d5b 	.word	0x00400d5b
  400cb8:	00400d5b 	.word	0x00400d5b
  400cbc:	00400d5b 	.word	0x00400d5b
  400cc0:	00400d5b 	.word	0x00400d5b
  400cc4:	00400d5b 	.word	0x00400d5b
  400cc8:	00400d5b 	.word	0x00400d5b
  400ccc:	00400d5b 	.word	0x00400d5b
  400cd0:	00400d5b 	.word	0x00400d5b
  400cd4:	00400d5b 	.word	0x00400d5b
  400cd8:	00400d5b 	.word	0x00400d5b
  400cdc:	00400d5b 	.word	0x00400d5b
  400ce0:	00400d5b 	.word	0x00400d5b
  400ce4:	00400c4d 	.word	0x00400c4d
  400ce8:	00400d5b 	.word	0x00400d5b
  400cec:	00400d5b 	.word	0x00400d5b
  400cf0:	00400d5b 	.word	0x00400d5b
  400cf4:	00400d5b 	.word	0x00400d5b
  400cf8:	00400d5b 	.word	0x00400d5b
  400cfc:	00400d5b 	.word	0x00400d5b
  400d00:	00400d5b 	.word	0x00400d5b
  400d04:	00400d5b 	.word	0x00400d5b
  400d08:	00400d5b 	.word	0x00400d5b
  400d0c:	00400d5b 	.word	0x00400d5b
  400d10:	00400d5b 	.word	0x00400d5b
  400d14:	00400d41 	.word	0x00400d41
  400d18:	00400d5b 	.word	0x00400d5b
  400d1c:	00400d5b 	.word	0x00400d5b
  400d20:	00400d5b 	.word	0x00400d5b
  400d24:	00400d5b 	.word	0x00400d5b
  400d28:	00400d5b 	.word	0x00400d5b
  400d2c:	00400d31 	.word	0x00400d31
		vTaskSuspend(xCreatedLedTask);
  400d30:	6870      	ldr	r0, [r6, #4]
  400d32:	4b15      	ldr	r3, [pc, #84]	; (400d88 <task_console+0x148>)
  400d34:	4798      	blx	r3
  400d36:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
  400d3a:	633b      	str	r3, [r7, #48]	; 0x30
			str = ("- LED OFF and blink task suspended.\r\n");
  400d3c:	4c13      	ldr	r4, [pc, #76]	; (400d8c <task_console+0x14c>)
  400d3e:	e789      	b.n	400c54 <task_console+0x14>
	} else {
		vTaskResume(xCreatedMonitorTask);
  400d40:	68b0      	ldr	r0, [r6, #8]
  400d42:	4b0d      	ldr	r3, [pc, #52]	; (400d78 <task_console+0x138>)
  400d44:	4798      	blx	r3
			str = ("- Monitor task active.\r\n");
  400d46:	4c12      	ldr	r4, [pc, #72]	; (400d90 <task_console+0x150>)
  400d48:	e784      	b.n	400c54 <task_console+0x14>
		vTaskSuspend(xCreatedMonitorTask);
  400d4a:	68b0      	ldr	r0, [r6, #8]
  400d4c:	4b0e      	ldr	r3, [pc, #56]	; (400d88 <task_console+0x148>)
  400d4e:	4798      	blx	r3
			str_write("- Monitor task suspended.\r\n");
  400d50:	4810      	ldr	r0, [pc, #64]	; (400d94 <task_console+0x154>)
  400d52:	4b11      	ldr	r3, [pc, #68]	; (400d98 <task_console+0x158>)
  400d54:	4798      	blx	r3
		char *str   = "";
  400d56:	4c11      	ldr	r4, [pc, #68]	; (400d9c <task_console+0x15c>)
			break;
  400d58:	e77c      	b.n	400c54 <task_console+0x14>
			str = ch;
  400d5a:	ac01      	add	r4, sp, #4
  400d5c:	e77a      	b.n	400c54 <task_console+0x14>
			str_write(str);
  400d5e:	4620      	mov	r0, r4
  400d60:	4b0d      	ldr	r3, [pc, #52]	; (400d98 <task_console+0x158>)
  400d62:	4798      	blx	r3
			disp_mutex_give();
  400d64:	4b0e      	ldr	r3, [pc, #56]	; (400da0 <task_console+0x160>)
  400d66:	4798      	blx	r3
	for (;;) {
  400d68:	e77b      	b.n	400c62 <task_console+0x22>
  400d6a:	bf00      	nop
  400d6c:	20400b6c 	.word	0x20400b6c
  400d70:	20400028 	.word	0x20400028
  400d74:	400e0e00 	.word	0x400e0e00
  400d78:	004024c9 	.word	0x004024c9
  400d7c:	00403628 	.word	0x00403628
  400d80:	00401ef1 	.word	0x00401ef1
  400d84:	004003b9 	.word	0x004003b9
  400d88:	00402959 	.word	0x00402959
  400d8c:	00403644 	.word	0x00403644
  400d90:	0040366c 	.word	0x0040366c
  400d94:	00403688 	.word	0x00403688
  400d98:	00400c05 	.word	0x00400c05
  400d9c:	00403684 	.word	0x00403684
  400da0:	00400c25 	.word	0x00400c25

00400da4 <main>:
{
	vTaskStartScheduler();
}

int main(void)
{
  400da4:	b510      	push	{r4, lr}
  400da6:	b082      	sub	sp, #8
	atmel_start_init();
  400da8:	4b19      	ldr	r3, [pc, #100]	; (400e10 <main+0x6c>)
  400daa:	4798      	blx	r3
	disp_mutex = xSemaphoreCreateMutex();
  400dac:	2001      	movs	r0, #1
  400dae:	4b19      	ldr	r3, [pc, #100]	; (400e14 <main+0x70>)
  400db0:	4798      	blx	r3
  400db2:	4b19      	ldr	r3, [pc, #100]	; (400e18 <main+0x74>)
  400db4:	6018      	str	r0, [r3, #0]
	if (disp_mutex == NULL) {
  400db6:	b160      	cbz	r0, 400dd2 <main+0x2e>
	if (xTaskCreate(
  400db8:	4b18      	ldr	r3, [pc, #96]	; (400e1c <main+0x78>)
  400dba:	9301      	str	r3, [sp, #4]
  400dbc:	2302      	movs	r3, #2
  400dbe:	9300      	str	r3, [sp, #0]
  400dc0:	2300      	movs	r3, #0
  400dc2:	224b      	movs	r2, #75	; 0x4b
  400dc4:	4916      	ldr	r1, [pc, #88]	; (400e20 <main+0x7c>)
  400dc6:	4817      	ldr	r0, [pc, #92]	; (400e24 <main+0x80>)
  400dc8:	4c17      	ldr	r4, [pc, #92]	; (400e28 <main+0x84>)
  400dca:	47a0      	blx	r4
  400dcc:	2801      	cmp	r0, #1
  400dce:	d001      	beq.n	400dd4 <main+0x30>
  400dd0:	e7fe      	b.n	400dd0 <main+0x2c>
  400dd2:	e7fe      	b.n	400dd2 <main+0x2e>
	if (xTaskCreate(task_led, "Led", TASK_LED_STACK_SIZE, NULL, TASK_LED_STACK_PRIORITY, &xCreatedLedTask) != pdPASS) {
  400dd4:	4b15      	ldr	r3, [pc, #84]	; (400e2c <main+0x88>)
  400dd6:	9301      	str	r3, [sp, #4]
  400dd8:	2301      	movs	r3, #1
  400dda:	9300      	str	r3, [sp, #0]
  400ddc:	2300      	movs	r3, #0
  400dde:	221b      	movs	r2, #27
  400de0:	4913      	ldr	r1, [pc, #76]	; (400e30 <main+0x8c>)
  400de2:	4814      	ldr	r0, [pc, #80]	; (400e34 <main+0x90>)
  400de4:	4c10      	ldr	r4, [pc, #64]	; (400e28 <main+0x84>)
  400de6:	47a0      	blx	r4
  400de8:	2801      	cmp	r0, #1
  400dea:	d000      	beq.n	400dee <main+0x4a>
  400dec:	e7fe      	b.n	400dec <main+0x48>
	if (xTaskCreate(task_console, "Console", TASK_CLI_STACK_SIZE, NULL, TASK_CLI_PRIORITY, &xCreatedConsoleTask)
  400dee:	4b12      	ldr	r3, [pc, #72]	; (400e38 <main+0x94>)
  400df0:	9301      	str	r3, [sp, #4]
  400df2:	2300      	movs	r3, #0
  400df4:	9300      	str	r3, [sp, #0]
  400df6:	2240      	movs	r2, #64	; 0x40
  400df8:	4910      	ldr	r1, [pc, #64]	; (400e3c <main+0x98>)
  400dfa:	4811      	ldr	r0, [pc, #68]	; (400e40 <main+0x9c>)
  400dfc:	4c0a      	ldr	r4, [pc, #40]	; (400e28 <main+0x84>)
  400dfe:	47a0      	blx	r4
  400e00:	2801      	cmp	r0, #1
  400e02:	d000      	beq.n	400e06 <main+0x62>
  400e04:	e7fe      	b.n	400e04 <main+0x60>
	vTaskStartScheduler();
  400e06:	4b0f      	ldr	r3, [pc, #60]	; (400e44 <main+0xa0>)
  400e08:	4798      	blx	r3
	task_console_create();
#endif
	tasks_run();

	return 0;
}
  400e0a:	2000      	movs	r0, #0
  400e0c:	b002      	add	sp, #8
  400e0e:	bd10      	pop	{r4, pc}
  400e10:	004001d5 	.word	0x004001d5
  400e14:	00401b35 	.word	0x00401b35
  400e18:	20400028 	.word	0x20400028
  400e1c:	20400030 	.word	0x20400030
  400e20:	004036a4 	.word	0x004036a4
  400e24:	00400fb5 	.word	0x00400fb5
  400e28:	00402279 	.word	0x00402279
  400e2c:	2040002c 	.word	0x2040002c
  400e30:	004036ac 	.word	0x004036ac
  400e34:	00400bdd 	.word	0x00400bdd
  400e38:	20400034 	.word	0x20400034
  400e3c:	004036b0 	.word	0x004036b0
  400e40:	00400c41 	.word	0x00400c41
  400e44:	00402569 	.word	0x00402569

00400e48 <sprintu>:
{
	char tmp_buf[12];
	int  i, n = 0;
	int  m;

	if (u == 0) {
  400e48:	b141      	cbz	r1, 400e5c <sprintu+0x14>
{
  400e4a:	b4f0      	push	{r4, r5, r6, r7}
  400e4c:	b084      	sub	sp, #16
  400e4e:	460a      	mov	r2, r1
  400e50:	4c1d      	ldr	r4, [pc, #116]	; (400ec8 <sprintu+0x80>)
  400e52:	ae01      	add	r6, sp, #4
  400e54:	f104 0728 	add.w	r7, r4, #40	; 0x28
	if (u == 0) {
  400e58:	4635      	mov	r5, r6
  400e5a:	e009      	b.n	400e70 <sprintu+0x28>
		*s = '0';
  400e5c:	2330      	movs	r3, #48	; 0x30
  400e5e:	7003      	strb	r3, [r0, #0]
		return 1;
  400e60:	2001      	movs	r0, #1
  400e62:	4770      	bx	lr
	}

	for (i = 0; i < 10; i++) {
		for (m = 0; m < 10; m++) {
			if (u >= m_val[i]) {
  400e64:	2300      	movs	r3, #0
				u -= m_val[i];
			} else {
				break;
			}
		}
		tmp_buf[i] = m + '0';
  400e66:	3330      	adds	r3, #48	; 0x30
  400e68:	f805 3b01 	strb.w	r3, [r5], #1
	for (i = 0; i < 10; i++) {
  400e6c:	42bc      	cmp	r4, r7
  400e6e:	d00c      	beq.n	400e8a <sprintu+0x42>
			if (u >= m_val[i]) {
  400e70:	f854 1b04 	ldr.w	r1, [r4], #4
  400e74:	428a      	cmp	r2, r1
  400e76:	d3f5      	bcc.n	400e64 <sprintu+0x1c>
				u -= m_val[i];
  400e78:	1a52      	subs	r2, r2, r1
		for (m = 0; m < 10; m++) {
  400e7a:	2301      	movs	r3, #1
			if (u >= m_val[i]) {
  400e7c:	4291      	cmp	r1, r2
  400e7e:	d8f2      	bhi.n	400e66 <sprintu+0x1e>
				u -= m_val[i];
  400e80:	1a52      	subs	r2, r2, r1
		for (m = 0; m < 10; m++) {
  400e82:	3301      	adds	r3, #1
  400e84:	2b0a      	cmp	r3, #10
  400e86:	d1f9      	bne.n	400e7c <sprintu+0x34>
  400e88:	e7ed      	b.n	400e66 <sprintu+0x1e>
	}
	for (i = 0; i < 10; i++) {
		if (tmp_buf[i] != '0') {
  400e8a:	f89d 3004 	ldrb.w	r3, [sp, #4]
  400e8e:	2b30      	cmp	r3, #48	; 0x30
  400e90:	d109      	bne.n	400ea6 <sprintu+0x5e>
	for (i = 0; i < 10; i++) {
  400e92:	2301      	movs	r3, #1
		if (tmp_buf[i] != '0') {
  400e94:	f816 2f01 	ldrb.w	r2, [r6, #1]!
  400e98:	2a30      	cmp	r2, #48	; 0x30
  400e9a:	d105      	bne.n	400ea8 <sprintu+0x60>
	for (i = 0; i < 10; i++) {
  400e9c:	3301      	adds	r3, #1
  400e9e:	2b0a      	cmp	r3, #10
  400ea0:	d1f8      	bne.n	400e94 <sprintu+0x4c>
  400ea2:	2000      	movs	r0, #0
  400ea4:	e00d      	b.n	400ec2 <sprintu+0x7a>
		if (tmp_buf[i] != '0') {
  400ea6:	2300      	movs	r3, #0
  400ea8:	aa04      	add	r2, sp, #16
  400eaa:	18d1      	adds	r1, r2, r3
  400eac:	390d      	subs	r1, #13
  400eae:	4604      	mov	r4, r0
	for (i = 0; i < 10; i++) {
  400eb0:	4602      	mov	r2, r0
			break;
		}
	}
	for (; i < 10; i++) {
		*s++ = tmp_buf[i];
  400eb2:	f811 0f01 	ldrb.w	r0, [r1, #1]!
  400eb6:	f802 0b01 	strb.w	r0, [r2], #1
  400eba:	1b10      	subs	r0, r2, r4
	for (; i < 10; i++) {
  400ebc:	3301      	adds	r3, #1
  400ebe:	2b09      	cmp	r3, #9
  400ec0:	ddf7      	ble.n	400eb2 <sprintu+0x6a>
		n++;
	}
	return n;
}
  400ec2:	b004      	add	sp, #16
  400ec4:	bcf0      	pop	{r4, r5, r6, r7}
  400ec6:	4770      	bx	lr
  400ec8:	00403600 	.word	0x00403600

00400ecc <sprintf>:

int sprintf(char *s, const char *fmt, ...)
{
  400ecc:	b40e      	push	{r1, r2, r3}
  400ece:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  400ed2:	b082      	sub	sp, #8
  400ed4:	4605      	mov	r5, r0
  400ed6:	ab09      	add	r3, sp, #36	; 0x24
  400ed8:	f853 4b04 	ldr.w	r4, [r3], #4
	int     n = 0;
	va_list ap;
	va_start(ap, fmt);
  400edc:	9301      	str	r3, [sp, #4]
	int     n = 0;
  400ede:	2600      	movs	r6, #0
				fmt++;
				break;
			}
			case 'u': {
				unsigned valu = va_arg(ap, unsigned);
				int      nc   = sprintu(s, valu);
  400ee0:	4f33      	ldr	r7, [pc, #204]	; (400fb0 <sprintf+0xe4>)
					*s++ = '-';
  400ee2:	f04f 082d 	mov.w	r8, #45	; 0x2d
	while (*fmt) {
  400ee6:	7823      	ldrb	r3, [r4, #0]
  400ee8:	2b00      	cmp	r3, #0
  400eea:	d059      	beq.n	400fa0 <sprintf+0xd4>
		if (*fmt != '%') {
  400eec:	2b25      	cmp	r3, #37	; 0x25
  400eee:	d004      	beq.n	400efa <sprintf+0x2e>
			*s = *fmt;
  400ef0:	f805 3b01 	strb.w	r3, [r5], #1
			fmt++;
  400ef4:	3401      	adds	r4, #1
			n++;
  400ef6:	3601      	adds	r6, #1
  400ef8:	e7f5      	b.n	400ee6 <sprintf+0x1a>
			switch (*fmt) {
  400efa:	7862      	ldrb	r2, [r4, #1]
  400efc:	f1a2 0363 	sub.w	r3, r2, #99	; 0x63
  400f00:	2b12      	cmp	r3, #18
  400f02:	d848      	bhi.n	400f96 <sprintf+0xca>
  400f04:	e8df f003 	tbb	[pc, r3]
  400f08:	4747130a 	.word	0x4747130a
  400f0c:	47474747 	.word	0x47474747
  400f10:	47474747 	.word	0x47474747
  400f14:	47474747 	.word	0x47474747
  400f18:	4733      	.short	0x4733
  400f1a:	29          	.byte	0x29
  400f1b:	00          	.byte	0x00
				char valch = va_arg(ap, int);
  400f1c:	9b01      	ldr	r3, [sp, #4]
  400f1e:	1d1a      	adds	r2, r3, #4
  400f20:	9201      	str	r2, [sp, #4]
  400f22:	681b      	ldr	r3, [r3, #0]
  400f24:	f805 3b01 	strb.w	r3, [r5], #1
				fmt++;
  400f28:	3402      	adds	r4, #2
				n++;
  400f2a:	3601      	adds	r6, #1
				break;
  400f2c:	e7db      	b.n	400ee6 <sprintf+0x1a>
				int vali = va_arg(ap, int);
  400f2e:	9b01      	ldr	r3, [sp, #4]
  400f30:	1d1a      	adds	r2, r3, #4
  400f32:	9201      	str	r2, [sp, #4]
  400f34:	6819      	ldr	r1, [r3, #0]
				if (vali < 0) {
  400f36:	2900      	cmp	r1, #0
  400f38:	db05      	blt.n	400f46 <sprintf+0x7a>
					nc = sprintu(s, vali);
  400f3a:	4628      	mov	r0, r5
  400f3c:	47b8      	blx	r7
				s += nc;
  400f3e:	4405      	add	r5, r0
				n += nc;
  400f40:	4406      	add	r6, r0
				fmt++;
  400f42:	3402      	adds	r4, #2
				break;
  400f44:	e7cf      	b.n	400ee6 <sprintf+0x1a>
					*s++ = '-';
  400f46:	f105 0901 	add.w	r9, r5, #1
  400f4a:	f885 8000 	strb.w	r8, [r5]
					n++;
  400f4e:	3601      	adds	r6, #1
					nc = sprintu(s, -vali);
  400f50:	4249      	negs	r1, r1
  400f52:	4648      	mov	r0, r9
  400f54:	47b8      	blx	r7
					*s++ = '-';
  400f56:	464d      	mov	r5, r9
  400f58:	e7f1      	b.n	400f3e <sprintf+0x72>
				unsigned valu = va_arg(ap, unsigned);
  400f5a:	9b01      	ldr	r3, [sp, #4]
  400f5c:	1d1a      	adds	r2, r3, #4
  400f5e:	9201      	str	r2, [sp, #4]
				int      nc   = sprintu(s, valu);
  400f60:	6819      	ldr	r1, [r3, #0]
  400f62:	4628      	mov	r0, r5
  400f64:	47b8      	blx	r7
				n += nc;
  400f66:	4406      	add	r6, r0
				s += nc;
  400f68:	4405      	add	r5, r0
				fmt++;
  400f6a:	3402      	adds	r4, #2
				break;
  400f6c:	e7bb      	b.n	400ee6 <sprintf+0x1a>
			}
			case 's': {
				char *vals = va_arg(ap, char *);
  400f6e:	9b01      	ldr	r3, [sp, #4]
  400f70:	1d1a      	adds	r2, r3, #4
  400f72:	9201      	str	r2, [sp, #4]
  400f74:	6819      	ldr	r1, [r3, #0]
				while (*vals) {
  400f76:	780b      	ldrb	r3, [r1, #0]
  400f78:	b15b      	cbz	r3, 400f92 <sprintf+0xc6>
  400f7a:	462a      	mov	r2, r5
  400f7c:	1b75      	subs	r5, r6, r5
					*s = *vals;
  400f7e:	f802 3b01 	strb.w	r3, [r2], #1
  400f82:	1956      	adds	r6, r2, r5
				while (*vals) {
  400f84:	f811 3f01 	ldrb.w	r3, [r1, #1]!
  400f88:	2b00      	cmp	r3, #0
  400f8a:	d1f8      	bne.n	400f7e <sprintf+0xb2>
					s++;
					vals++;
					n++;
				}
				fmt++;
  400f8c:	3402      	adds	r4, #2
				break;
  400f8e:	4615      	mov	r5, r2
  400f90:	e7a9      	b.n	400ee6 <sprintf+0x1a>
				while (*vals) {
  400f92:	462a      	mov	r2, r5
  400f94:	e7fa      	b.n	400f8c <sprintf+0xc0>
			}
			default:
				*s = *fmt;
  400f96:	f805 2b01 	strb.w	r2, [r5], #1
				s++;
				fmt++;
  400f9a:	3402      	adds	r4, #2
				n++;
  400f9c:	3601      	adds	r6, #1
  400f9e:	e7a2      	b.n	400ee6 <sprintf+0x1a>
			}
		}
	}
	va_end(ap);
	*s = 0;
  400fa0:	702b      	strb	r3, [r5, #0]
	return n;
}
  400fa2:	4630      	mov	r0, r6
  400fa4:	b002      	add	sp, #8
  400fa6:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  400faa:	b003      	add	sp, #12
  400fac:	4770      	bx	lr
  400fae:	bf00      	nop
  400fb0:	00400e49 	.word	0x00400e49

00400fb4 <task_monitor>:
{
  400fb4:	b580      	push	{r7, lr}
  400fb6:	b082      	sub	sp, #8
	return xSemaphoreTake(disp_mutex, ~0);
  400fb8:	4e19      	ldr	r6, [pc, #100]	; (401020 <task_monitor+0x6c>)
  400fba:	4f1a      	ldr	r7, [pc, #104]	; (401024 <task_monitor+0x70>)
	sprintf(szList, "%c%c%c%c", 0x1B, '[', '2', 'J');
  400fbc:	f106 0510 	add.w	r5, r6, #16
  400fc0:	e003      	b.n	400fca <task_monitor+0x16>
		os_sleep(5000);
  400fc2:	f241 3088 	movw	r0, #5000	; 0x1388
  400fc6:	4b18      	ldr	r3, [pc, #96]	; (401028 <task_monitor+0x74>)
  400fc8:	4798      	blx	r3
	return xSemaphoreTake(disp_mutex, ~0);
  400fca:	f04f 31ff 	mov.w	r1, #4294967295
  400fce:	6830      	ldr	r0, [r6, #0]
  400fd0:	47b8      	blx	r7
		if (disp_mutex_take()) {
  400fd2:	2800      	cmp	r0, #0
  400fd4:	d0f5      	beq.n	400fc2 <task_monitor+0xe>
	sprintf(szList, "%c%c%c%c", 0x1B, '[', '2', 'J');
  400fd6:	234a      	movs	r3, #74	; 0x4a
  400fd8:	9301      	str	r3, [sp, #4]
  400fda:	2332      	movs	r3, #50	; 0x32
  400fdc:	9300      	str	r3, [sp, #0]
  400fde:	235b      	movs	r3, #91	; 0x5b
  400fe0:	221b      	movs	r2, #27
  400fe2:	4912      	ldr	r1, [pc, #72]	; (40102c <task_monitor+0x78>)
  400fe4:	4628      	mov	r0, r5
  400fe6:	f8df 8068 	ldr.w	r8, [pc, #104]	; 401050 <task_monitor+0x9c>
  400fea:	47c0      	blx	r8
	str_write(szList);
  400fec:	4628      	mov	r0, r5
  400fee:	4c10      	ldr	r4, [pc, #64]	; (401030 <task_monitor+0x7c>)
  400ff0:	47a0      	blx	r4
	sprintf(szList, "--- Number of tasks: %u\r\n", (unsigned int)uxTaskGetNumberOfTasks());
  400ff2:	4b10      	ldr	r3, [pc, #64]	; (401034 <task_monitor+0x80>)
  400ff4:	4798      	blx	r3
  400ff6:	4602      	mov	r2, r0
  400ff8:	490f      	ldr	r1, [pc, #60]	; (401038 <task_monitor+0x84>)
  400ffa:	4628      	mov	r0, r5
  400ffc:	47c0      	blx	r8
	str_write(szList);
  400ffe:	4628      	mov	r0, r5
  401000:	47a0      	blx	r4
	str_write("> Tasks\tState\tPri\tStack\tNum\r\n");
  401002:	480e      	ldr	r0, [pc, #56]	; (40103c <task_monitor+0x88>)
  401004:	47a0      	blx	r4
	str_write("***********************************\r\n");
  401006:	480e      	ldr	r0, [pc, #56]	; (401040 <task_monitor+0x8c>)
  401008:	47a0      	blx	r4
	vTaskList(szList);
  40100a:	4628      	mov	r0, r5
  40100c:	4b0d      	ldr	r3, [pc, #52]	; (401044 <task_monitor+0x90>)
  40100e:	4798      	blx	r3
	str_write(szList);
  401010:	4628      	mov	r0, r5
  401012:	47a0      	blx	r4
	str_write("--- Press a key:\r\n"
  401014:	480c      	ldr	r0, [pc, #48]	; (401048 <task_monitor+0x94>)
  401016:	47a0      	blx	r4
			disp_mutex_give();
  401018:	4b0c      	ldr	r3, [pc, #48]	; (40104c <task_monitor+0x98>)
  40101a:	4798      	blx	r3
  40101c:	e7d1      	b.n	400fc2 <task_monitor+0xe>
  40101e:	bf00      	nop
  401020:	20400028 	.word	0x20400028
  401024:	00401ef1 	.word	0x00401ef1
  401028:	0040285d 	.word	0x0040285d
  40102c:	004036b8 	.word	0x004036b8
  401030:	00400c05 	.word	0x00400c05
  401034:	00402619 	.word	0x00402619
  401038:	004036c4 	.word	0x004036c4
  40103c:	004036e0 	.word	0x004036e0
  401040:	00403700 	.word	0x00403700
  401044:	00402fc5 	.word	0x00402fc5
  401048:	00403728 	.word	0x00403728
  40104c:	00400c25 	.word	0x00400c25
  401050:	00400ecd 	.word	0x00400ecd

00401054 <sem_init>:

/**
 * \brief Semaphore initialization
 */
int32_t sem_init(sem_t *sem, uint32_t count)
{
  401054:	b538      	push	{r3, r4, r5, lr}
  401056:	4605      	mov	r5, r0
  401058:	460c      	mov	r4, r1
	ASSERT(count <= SEMAPHORE_MAX_COUNT);
  40105a:	222b      	movs	r2, #43	; 0x2b
  40105c:	4908      	ldr	r1, [pc, #32]	; (401080 <sem_init+0x2c>)
  40105e:	2c01      	cmp	r4, #1
  401060:	bf8c      	ite	hi
  401062:	2000      	movhi	r0, #0
  401064:	2001      	movls	r0, #1
  401066:	4b07      	ldr	r3, [pc, #28]	; (401084 <sem_init+0x30>)
  401068:	4798      	blx	r3

	*sem = xSemaphoreCreateCounting((uint32_t)SEMAPHORE_MAX_COUNT, count);
  40106a:	4621      	mov	r1, r4
  40106c:	2001      	movs	r0, #1
  40106e:	4b06      	ldr	r3, [pc, #24]	; (401088 <sem_init+0x34>)
  401070:	4798      	blx	r3
  401072:	6028      	str	r0, [r5, #0]

	return *sem ? ERR_NONE : ERR_NOT_INITIALIZED;
  401074:	2800      	cmp	r0, #0
}
  401076:	bf14      	ite	ne
  401078:	2000      	movne	r0, #0
  40107a:	f06f 0013 	mvneq.w	r0, #19
  40107e:	bd38      	pop	{r3, r4, r5, pc}
  401080:	00403790 	.word	0x00403790
  401084:	00400681 	.word	0x00400681
  401088:	004018f9 	.word	0x004018f9

0040108c <sem_up>:

/**
 * \brief Semaphore up
 */
int32_t sem_up(sem_t *sem)
{
  40108c:	b510      	push	{r4, lr}
 * \brief Check if it's in ISR handling
 * \return \c true if it's in ISR
 */
static inline bool _is_in_isr(void)
{
	return (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk);
  40108e:	4b0d      	ldr	r3, [pc, #52]	; (4010c4 <sem_up+0x38>)
  401090:	685b      	ldr	r3, [r3, #4]
  401092:	f3c3 0308 	ubfx	r3, r3, #0, #9
	return is_in_isr() ? (xSemaphoreGiveFromISR(*sem, pdFALSE) ? 0 : ERR_ABORTED)
	                   : (xSemaphoreGive(*sem) ? ERR_NONE : ERR_ABORTED);
  401096:	b14b      	cbz	r3, 4010ac <sem_up+0x20>
	return is_in_isr() ? (xSemaphoreGiveFromISR(*sem, pdFALSE) ? 0 : ERR_ABORTED)
  401098:	2100      	movs	r1, #0
  40109a:	6800      	ldr	r0, [r0, #0]
  40109c:	4b0a      	ldr	r3, [pc, #40]	; (4010c8 <sem_up+0x3c>)
  40109e:	4798      	blx	r3
	                   : (xSemaphoreGive(*sem) ? ERR_NONE : ERR_ABORTED);
  4010a0:	2800      	cmp	r0, #0
  4010a2:	bf14      	ite	ne
  4010a4:	2000      	movne	r0, #0
  4010a6:	f06f 0002 	mvneq.w	r0, #2
  4010aa:	bd10      	pop	{r4, pc}
  4010ac:	2300      	movs	r3, #0
  4010ae:	461a      	mov	r2, r3
  4010b0:	4619      	mov	r1, r3
  4010b2:	6800      	ldr	r0, [r0, #0]
  4010b4:	4c05      	ldr	r4, [pc, #20]	; (4010cc <sem_up+0x40>)
  4010b6:	47a0      	blx	r4
  4010b8:	2800      	cmp	r0, #0
  4010ba:	bf14      	ite	ne
  4010bc:	2000      	movne	r0, #0
  4010be:	f06f 0002 	mvneq.w	r0, #2
}
  4010c2:	bd10      	pop	{r4, pc}
  4010c4:	e000ed00 	.word	0xe000ed00
  4010c8:	00401c75 	.word	0x00401c75
  4010cc:	00401945 	.word	0x00401945

004010d0 <sem_down>:

/**
 * \brief Semaphore down, may suspend the caller thread
 */
int32_t sem_down(sem_t *sem, uint32_t timeout)
{
  4010d0:	b508      	push	{r3, lr}
	return xSemaphoreTake(*sem, timeout) ? ERR_NONE : ERR_TIMEOUT;
  4010d2:	6800      	ldr	r0, [r0, #0]
  4010d4:	4b03      	ldr	r3, [pc, #12]	; (4010e4 <sem_down+0x14>)
  4010d6:	4798      	blx	r3
  4010d8:	2800      	cmp	r0, #0
}
  4010da:	bf14      	ite	ne
  4010dc:	2000      	movne	r0, #0
  4010de:	f06f 0007 	mvneq.w	r0, #7
  4010e2:	bd08      	pop	{r3, pc}
  4010e4:	00401ef1 	.word	0x00401ef1

004010e8 <sem_deinit>:
/**
 * \brief Semaphore deinitialization
 */
int32_t sem_deinit(sem_t *sem)
{
	if (*sem != NULL) {
  4010e8:	6803      	ldr	r3, [r0, #0]
  4010ea:	b143      	cbz	r3, 4010fe <sem_deinit+0x16>
{
  4010ec:	b510      	push	{r4, lr}
  4010ee:	4604      	mov	r4, r0
		vSemaphoreDelete(*sem);
  4010f0:	4618      	mov	r0, r3
  4010f2:	4b04      	ldr	r3, [pc, #16]	; (401104 <sem_deinit+0x1c>)
  4010f4:	4798      	blx	r3
		*sem = NULL;
  4010f6:	2300      	movs	r3, #0
  4010f8:	6023      	str	r3, [r4, #0]
	}

	return ERR_NONE;
}
  4010fa:	2000      	movs	r0, #0
  4010fc:	bd10      	pop	{r4, pc}
  4010fe:	2000      	movs	r0, #0
  401100:	4770      	bx	lr
  401102:	bf00      	nop
  401104:	004020e5 	.word	0x004020e5

00401108 <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
  401108:	f100 0308 	add.w	r3, r0, #8
  40110c:	6043      	str	r3, [r0, #4]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  40110e:	f04f 32ff 	mov.w	r2, #4294967295
  401112:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
  401114:	60c3      	str	r3, [r0, #12]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
  401116:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
  401118:	2300      	movs	r3, #0
  40111a:	6003      	str	r3, [r0, #0]
  40111c:	4770      	bx	lr

0040111e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  40111e:	2300      	movs	r3, #0
  401120:	6103      	str	r3, [r0, #16]
  401122:	4770      	bx	lr

00401124 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
  401124:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
  401126:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  401128:	689a      	ldr	r2, [r3, #8]
  40112a:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
  40112c:	689a      	ldr	r2, [r3, #8]
  40112e:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
  401130:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;
  401132:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
  401134:	6803      	ldr	r3, [r0, #0]
  401136:	3301      	adds	r3, #1
  401138:	6003      	str	r3, [r0, #0]
  40113a:	4770      	bx	lr

0040113c <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
  40113c:	b430      	push	{r4, r5}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  40113e:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
  401140:	f1b5 3fff 	cmp.w	r5, #4294967295
  401144:	d002      	beq.n	40114c <vListInsert+0x10>
		    4) Using a queue or semaphore before it has been initialised or
		       before the scheduler has been started (are interrupts firing
		       before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
  401146:	f100 0208 	add.w	r2, r0, #8
  40114a:	e002      	b.n	401152 <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
  40114c:	6902      	ldr	r2, [r0, #16]
  40114e:	e004      	b.n	40115a <vListInsert+0x1e>
		     pxIterator
		     = pxIterator
  401150:	461a      	mov	r2, r3
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
  401152:	6853      	ldr	r3, [r2, #4]
  401154:	681c      	ldr	r4, [r3, #0]
  401156:	42a5      	cmp	r5, r4
  401158:	d2fa      	bcs.n	401150 <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
  40115a:	6853      	ldr	r3, [r2, #4]
  40115c:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  40115e:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious         = pxIterator;
  401160:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
  401162:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;
  401164:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
  401166:	6803      	ldr	r3, [r0, #0]
  401168:	3301      	adds	r3, #1
  40116a:	6003      	str	r3, [r0, #0]
}
  40116c:	bc30      	pop	{r4, r5}
  40116e:	4770      	bx	lr

00401170 <uxListRemove>:

UBaseType_t uxListRemove(ListItem_t *const pxItemToRemove)
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
  401170:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  401172:	6842      	ldr	r2, [r0, #4]
  401174:	6881      	ldr	r1, [r0, #8]
  401176:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  401178:	6882      	ldr	r2, [r0, #8]
  40117a:	6841      	ldr	r1, [r0, #4]
  40117c:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
  40117e:	685a      	ldr	r2, [r3, #4]
  401180:	4290      	cmp	r0, r2
  401182:	d006      	beq.n	401192 <uxListRemove+0x22>
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
  401184:	2200      	movs	r2, #0
  401186:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
  401188:	681a      	ldr	r2, [r3, #0]
  40118a:	3a01      	subs	r2, #1
  40118c:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  40118e:	6818      	ldr	r0, [r3, #0]
}
  401190:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  401192:	6882      	ldr	r2, [r0, #8]
  401194:	605a      	str	r2, [r3, #4]
  401196:	e7f5      	b.n	401184 <uxListRemove+0x14>

00401198 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError(void)
{
  401198:	b082      	sub	sp, #8
	volatile uint32_t ulDummy = 0;
  40119a:	2300      	movs	r3, #0
  40119c:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT(uxCriticalNesting == ~0UL);
  40119e:	4b0f      	ldr	r3, [pc, #60]	; (4011dc <prvTaskExitError+0x44>)
  4011a0:	681b      	ldr	r3, [r3, #0]
  4011a2:	f1b3 3fff 	cmp.w	r3, #4294967295
  4011a6:	d00a      	beq.n	4011be <prvTaskExitError+0x26>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
  4011a8:	f04f 0380 	mov.w	r3, #128	; 0x80
  4011ac:	b672      	cpsid	i
  4011ae:	f383 8811 	msr	BASEPRI, r3
  4011b2:	f3bf 8f6f 	isb	sy
  4011b6:	f3bf 8f4f 	dsb	sy
  4011ba:	b662      	cpsie	i
  4011bc:	e7fe      	b.n	4011bc <prvTaskExitError+0x24>
  4011be:	f04f 0380 	mov.w	r3, #128	; 0x80
  4011c2:	b672      	cpsid	i
  4011c4:	f383 8811 	msr	BASEPRI, r3
  4011c8:	f3bf 8f6f 	isb	sy
  4011cc:	f3bf 8f4f 	dsb	sy
  4011d0:	b662      	cpsie	i
	portDISABLE_INTERRUPTS();
	while (ulDummy == 0) {
  4011d2:	9b01      	ldr	r3, [sp, #4]
  4011d4:	2b00      	cmp	r3, #0
  4011d6:	d0fc      	beq.n	4011d2 <prvTaskExitError+0x3a>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
  4011d8:	b002      	add	sp, #8
  4011da:	4770      	bx	lr
  4011dc:	20400000 	.word	0x20400000

004011e0 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
  4011e0:	4808      	ldr	r0, [pc, #32]	; (401204 <prvPortStartFirstTask+0x24>)
  4011e2:	6800      	ldr	r0, [r0, #0]
  4011e4:	6800      	ldr	r0, [r0, #0]
  4011e6:	f380 8808 	msr	MSP, r0
  4011ea:	f04f 0000 	mov.w	r0, #0
  4011ee:	f380 8814 	msr	CONTROL, r0
  4011f2:	b662      	cpsie	i
  4011f4:	b661      	cpsie	f
  4011f6:	f3bf 8f4f 	dsb	sy
  4011fa:	f3bf 8f6f 	isb	sy
  4011fe:	df00      	svc	0
  401200:	bf00      	nop
  401202:	0000      	.short	0x0000
  401204:	e000ed08 	.word	0xe000ed08

00401208 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
  401208:	f8df 000c 	ldr.w	r0, [pc, #12]	; 401218 <vPortEnableVFP+0x10>
  40120c:	6801      	ldr	r1, [r0, #0]
  40120e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  401212:	6001      	str	r1, [r0, #0]
  401214:	4770      	bx	lr
  401216:	0000      	.short	0x0000
  401218:	e000ed88 	.word	0xe000ed88

0040121c <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
  40121c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
  401220:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
  401224:	f021 0101 	bic.w	r1, r1, #1
  401228:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
  40122c:	4b05      	ldr	r3, [pc, #20]	; (401244 <pxPortInitialiseStack+0x28>)
  40122e:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
  401232:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
  401236:	f06f 0302 	mvn.w	r3, #2
  40123a:	f840 3c24 	str.w	r3, [r0, #-36]
}
  40123e:	3844      	subs	r0, #68	; 0x44
  401240:	4770      	bx	lr
  401242:	bf00      	nop
  401244:	00401199 	.word	0x00401199
	...

00401250 <SVCall_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
  401250:	4b07      	ldr	r3, [pc, #28]	; (401270 <pxCurrentTCBConst2>)
  401252:	6819      	ldr	r1, [r3, #0]
  401254:	6808      	ldr	r0, [r1, #0]
  401256:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40125a:	f380 8809 	msr	PSP, r0
  40125e:	f3bf 8f6f 	isb	sy
  401262:	f04f 0000 	mov.w	r0, #0
  401266:	f380 8811 	msr	BASEPRI, r0
  40126a:	4770      	bx	lr
  40126c:	f3af 8000 	nop.w

00401270 <pxCurrentTCBConst2>:
  401270:	20400acc 	.word	0x20400acc

00401274 <vPortEnterCritical>:
  401274:	f04f 0380 	mov.w	r3, #128	; 0x80
  401278:	b672      	cpsid	i
  40127a:	f383 8811 	msr	BASEPRI, r3
  40127e:	f3bf 8f6f 	isb	sy
  401282:	f3bf 8f4f 	dsb	sy
  401286:	b662      	cpsie	i
	uxCriticalNesting++;
  401288:	4a0b      	ldr	r2, [pc, #44]	; (4012b8 <vPortEnterCritical+0x44>)
  40128a:	6813      	ldr	r3, [r2, #0]
  40128c:	3301      	adds	r3, #1
  40128e:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
  401290:	2b01      	cmp	r3, #1
  401292:	d10f      	bne.n	4012b4 <vPortEnterCritical+0x40>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
  401294:	4b09      	ldr	r3, [pc, #36]	; (4012bc <vPortEnterCritical+0x48>)
  401296:	681b      	ldr	r3, [r3, #0]
  401298:	f013 0fff 	tst.w	r3, #255	; 0xff
  40129c:	d00a      	beq.n	4012b4 <vPortEnterCritical+0x40>
  40129e:	f04f 0380 	mov.w	r3, #128	; 0x80
  4012a2:	b672      	cpsid	i
  4012a4:	f383 8811 	msr	BASEPRI, r3
  4012a8:	f3bf 8f6f 	isb	sy
  4012ac:	f3bf 8f4f 	dsb	sy
  4012b0:	b662      	cpsie	i
  4012b2:	e7fe      	b.n	4012b2 <vPortEnterCritical+0x3e>
  4012b4:	4770      	bx	lr
  4012b6:	bf00      	nop
  4012b8:	20400000 	.word	0x20400000
  4012bc:	e000ed04 	.word	0xe000ed04

004012c0 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
  4012c0:	4b0a      	ldr	r3, [pc, #40]	; (4012ec <vPortExitCritical+0x2c>)
  4012c2:	681b      	ldr	r3, [r3, #0]
  4012c4:	b953      	cbnz	r3, 4012dc <vPortExitCritical+0x1c>
  4012c6:	f04f 0380 	mov.w	r3, #128	; 0x80
  4012ca:	b672      	cpsid	i
  4012cc:	f383 8811 	msr	BASEPRI, r3
  4012d0:	f3bf 8f6f 	isb	sy
  4012d4:	f3bf 8f4f 	dsb	sy
  4012d8:	b662      	cpsie	i
  4012da:	e7fe      	b.n	4012da <vPortExitCritical+0x1a>
	uxCriticalNesting--;
  4012dc:	3b01      	subs	r3, #1
  4012de:	4a03      	ldr	r2, [pc, #12]	; (4012ec <vPortExitCritical+0x2c>)
  4012e0:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
  4012e2:	b90b      	cbnz	r3, 4012e8 <vPortExitCritical+0x28>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
  4012e4:	f383 8811 	msr	BASEPRI, r3
  4012e8:	4770      	bx	lr
  4012ea:	bf00      	nop
  4012ec:	20400000 	.word	0x20400000

004012f0 <PendSV_Handler>:
	__asm volatile(
  4012f0:	f3ef 8009 	mrs	r0, PSP
  4012f4:	f3bf 8f6f 	isb	sy
  4012f8:	4b15      	ldr	r3, [pc, #84]	; (401350 <pxCurrentTCBConst>)
  4012fa:	681a      	ldr	r2, [r3, #0]
  4012fc:	f01e 0f10 	tst.w	lr, #16
  401300:	bf08      	it	eq
  401302:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
  401306:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40130a:	6010      	str	r0, [r2, #0]
  40130c:	e92d 0009 	stmdb	sp!, {r0, r3}
  401310:	f04f 0080 	mov.w	r0, #128	; 0x80
  401314:	b672      	cpsid	i
  401316:	f380 8811 	msr	BASEPRI, r0
  40131a:	f3bf 8f4f 	dsb	sy
  40131e:	f3bf 8f6f 	isb	sy
  401322:	b662      	cpsie	i
  401324:	f001 fac8 	bl	4028b8 <vTaskSwitchContext>
  401328:	f04f 0000 	mov.w	r0, #0
  40132c:	f380 8811 	msr	BASEPRI, r0
  401330:	bc09      	pop	{r0, r3}
  401332:	6819      	ldr	r1, [r3, #0]
  401334:	6808      	ldr	r0, [r1, #0]
  401336:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40133a:	f01e 0f10 	tst.w	lr, #16
  40133e:	bf08      	it	eq
  401340:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
  401344:	f380 8809 	msr	PSP, r0
  401348:	f3bf 8f6f 	isb	sy
  40134c:	4770      	bx	lr
  40134e:	bf00      	nop

00401350 <pxCurrentTCBConst>:
  401350:	20400acc 	.word	0x20400acc

00401354 <SysTick_Handler>:
{
  401354:	b508      	push	{r3, lr}
	__asm volatile("	mov %0, %1												\n"
  401356:	f04f 0380 	mov.w	r3, #128	; 0x80
  40135a:	b672      	cpsid	i
  40135c:	f383 8811 	msr	BASEPRI, r3
  401360:	f3bf 8f6f 	isb	sy
  401364:	f3bf 8f4f 	dsb	sy
  401368:	b662      	cpsie	i
		if (xTaskIncrementTick() != pdFALSE) {
  40136a:	4b05      	ldr	r3, [pc, #20]	; (401380 <SysTick_Handler+0x2c>)
  40136c:	4798      	blx	r3
  40136e:	b118      	cbz	r0, 401378 <SysTick_Handler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  401370:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401374:	4b03      	ldr	r3, [pc, #12]	; (401384 <SysTick_Handler+0x30>)
  401376:	601a      	str	r2, [r3, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
  401378:	2300      	movs	r3, #0
  40137a:	f383 8811 	msr	BASEPRI, r3
  40137e:	bd08      	pop	{r3, pc}
  401380:	00402625 	.word	0x00402625
  401384:	e000ed04 	.word	0xe000ed04

00401388 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
  401388:	4b05      	ldr	r3, [pc, #20]	; (4013a0 <vPortSetupTimerInterrupt+0x18>)
  40138a:	2200      	movs	r2, #0
  40138c:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
  40138e:	4905      	ldr	r1, [pc, #20]	; (4013a4 <vPortSetupTimerInterrupt+0x1c>)
  401390:	600a      	str	r2, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
  401392:	4905      	ldr	r1, [pc, #20]	; (4013a8 <vPortSetupTimerInterrupt+0x20>)
  401394:	4a05      	ldr	r2, [pc, #20]	; (4013ac <vPortSetupTimerInterrupt+0x24>)
  401396:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
  401398:	2207      	movs	r2, #7
  40139a:	601a      	str	r2, [r3, #0]
  40139c:	4770      	bx	lr
  40139e:	bf00      	nop
  4013a0:	e000e010 	.word	0xe000e010
  4013a4:	e000e018 	.word	0xe000e018
  4013a8:	000493df 	.word	0x000493df
  4013ac:	e000e014 	.word	0xe000e014

004013b0 <xPortStartScheduler>:
{
  4013b0:	b510      	push	{r4, lr}
  4013b2:	b082      	sub	sp, #8
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  4013b4:	4b2d      	ldr	r3, [pc, #180]	; (40146c <xPortStartScheduler+0xbc>)
  4013b6:	781a      	ldrb	r2, [r3, #0]
  4013b8:	b2d2      	uxtb	r2, r2
  4013ba:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  4013bc:	22ff      	movs	r2, #255	; 0xff
  4013be:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
  4013c0:	781b      	ldrb	r3, [r3, #0]
  4013c2:	b2db      	uxtb	r3, r3
  4013c4:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
  4013c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
  4013cc:	4a28      	ldr	r2, [pc, #160]	; (401470 <xPortStartScheduler+0xc0>)
  4013ce:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4013d2:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
  4013d4:	2307      	movs	r3, #7
  4013d6:	6053      	str	r3, [r2, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
  4013d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
  4013dc:	f013 0f80 	tst.w	r3, #128	; 0x80
  4013e0:	d012      	beq.n	401408 <xPortStartScheduler+0x58>
  4013e2:	2306      	movs	r3, #6
  4013e4:	e000      	b.n	4013e8 <xPortStartScheduler+0x38>
  4013e6:	460b      	mov	r3, r1
			ucMaxPriorityValue <<= (uint8_t)0x01;
  4013e8:	f89d 2003 	ldrb.w	r2, [sp, #3]
  4013ec:	0052      	lsls	r2, r2, #1
  4013ee:	b2d2      	uxtb	r2, r2
  4013f0:	f88d 2003 	strb.w	r2, [sp, #3]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
  4013f4:	f89d 2003 	ldrb.w	r2, [sp, #3]
  4013f8:	1e59      	subs	r1, r3, #1
  4013fa:	f012 0f80 	tst.w	r2, #128	; 0x80
  4013fe:	d1f2      	bne.n	4013e6 <xPortStartScheduler+0x36>
  401400:	4a1b      	ldr	r2, [pc, #108]	; (401470 <xPortStartScheduler+0xc0>)
  401402:	6053      	str	r3, [r2, #4]
			configASSERT((portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue) == configPRIO_BITS);
  401404:	2b04      	cmp	r3, #4
  401406:	d00a      	beq.n	40141e <xPortStartScheduler+0x6e>
	__asm volatile("	mov %0, %1												\n"
  401408:	f04f 0380 	mov.w	r3, #128	; 0x80
  40140c:	b672      	cpsid	i
  40140e:	f383 8811 	msr	BASEPRI, r3
  401412:	f3bf 8f6f 	isb	sy
  401416:	f3bf 8f4f 	dsb	sy
  40141a:	b662      	cpsie	i
  40141c:	e7fe      	b.n	40141c <xPortStartScheduler+0x6c>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
  40141e:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
  401420:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  401424:	4a12      	ldr	r2, [pc, #72]	; (401470 <xPortStartScheduler+0xc0>)
  401426:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
  401428:	9b01      	ldr	r3, [sp, #4]
  40142a:	b2db      	uxtb	r3, r3
  40142c:	4a0f      	ldr	r2, [pc, #60]	; (40146c <xPortStartScheduler+0xbc>)
  40142e:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  401430:	4b10      	ldr	r3, [pc, #64]	; (401474 <xPortStartScheduler+0xc4>)
  401432:	681a      	ldr	r2, [r3, #0]
  401434:	f442 0260 	orr.w	r2, r2, #14680064	; 0xe00000
  401438:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  40143a:	681a      	ldr	r2, [r3, #0]
  40143c:	f042 4260 	orr.w	r2, r2, #3758096384	; 0xe0000000
  401440:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
  401442:	4b0d      	ldr	r3, [pc, #52]	; (401478 <xPortStartScheduler+0xc8>)
  401444:	4798      	blx	r3
	uxCriticalNesting = 0;
  401446:	2400      	movs	r4, #0
  401448:	4b0c      	ldr	r3, [pc, #48]	; (40147c <xPortStartScheduler+0xcc>)
  40144a:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
  40144c:	4b0c      	ldr	r3, [pc, #48]	; (401480 <xPortStartScheduler+0xd0>)
  40144e:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
  401450:	4a0c      	ldr	r2, [pc, #48]	; (401484 <xPortStartScheduler+0xd4>)
  401452:	6813      	ldr	r3, [r2, #0]
  401454:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
  401458:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
  40145a:	4b0b      	ldr	r3, [pc, #44]	; (401488 <xPortStartScheduler+0xd8>)
  40145c:	4798      	blx	r3
	vTaskSwitchContext();
  40145e:	4b0b      	ldr	r3, [pc, #44]	; (40148c <xPortStartScheduler+0xdc>)
  401460:	4798      	blx	r3
	prvTaskExitError();
  401462:	4b0b      	ldr	r3, [pc, #44]	; (401490 <xPortStartScheduler+0xe0>)
  401464:	4798      	blx	r3
}
  401466:	4620      	mov	r0, r4
  401468:	b002      	add	sp, #8
  40146a:	bd10      	pop	{r4, pc}
  40146c:	e000e400 	.word	0xe000e400
  401470:	204000b8 	.word	0x204000b8
  401474:	e000ed20 	.word	0xe000ed20
  401478:	00401389 	.word	0x00401389
  40147c:	20400000 	.word	0x20400000
  401480:	00401209 	.word	0x00401209
  401484:	e000ef34 	.word	0xe000ef34
  401488:	004011e1 	.word	0x004011e1
  40148c:	004028b9 	.word	0x004028b9
  401490:	00401199 	.word	0x00401199

00401494 <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt)::"memory");
  401494:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
  401498:	2b0f      	cmp	r3, #15
  40149a:	d911      	bls.n	4014c0 <vPortValidateInterruptPriority+0x2c>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
  40149c:	4a12      	ldr	r2, [pc, #72]	; (4014e8 <vPortValidateInterruptPriority+0x54>)
  40149e:	5c9b      	ldrb	r3, [r3, r2]
  4014a0:	b2db      	uxtb	r3, r3
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
  4014a2:	4a12      	ldr	r2, [pc, #72]	; (4014ec <vPortValidateInterruptPriority+0x58>)
  4014a4:	7812      	ldrb	r2, [r2, #0]
  4014a6:	429a      	cmp	r2, r3
  4014a8:	d90a      	bls.n	4014c0 <vPortValidateInterruptPriority+0x2c>
  4014aa:	f04f 0380 	mov.w	r3, #128	; 0x80
  4014ae:	b672      	cpsid	i
  4014b0:	f383 8811 	msr	BASEPRI, r3
  4014b4:	f3bf 8f6f 	isb	sy
  4014b8:	f3bf 8f4f 	dsb	sy
  4014bc:	b662      	cpsie	i
  4014be:	e7fe      	b.n	4014be <vPortValidateInterruptPriority+0x2a>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredictable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
  4014c0:	4b0b      	ldr	r3, [pc, #44]	; (4014f0 <vPortValidateInterruptPriority+0x5c>)
  4014c2:	681b      	ldr	r3, [r3, #0]
  4014c4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  4014c8:	4a08      	ldr	r2, [pc, #32]	; (4014ec <vPortValidateInterruptPriority+0x58>)
  4014ca:	6852      	ldr	r2, [r2, #4]
  4014cc:	4293      	cmp	r3, r2
  4014ce:	d90a      	bls.n	4014e6 <vPortValidateInterruptPriority+0x52>
  4014d0:	f04f 0380 	mov.w	r3, #128	; 0x80
  4014d4:	b672      	cpsid	i
  4014d6:	f383 8811 	msr	BASEPRI, r3
  4014da:	f3bf 8f6f 	isb	sy
  4014de:	f3bf 8f4f 	dsb	sy
  4014e2:	b662      	cpsie	i
  4014e4:	e7fe      	b.n	4014e4 <vPortValidateInterruptPriority+0x50>
  4014e6:	4770      	bx	lr
  4014e8:	e000e3f0 	.word	0xe000e3f0
  4014ec:	204000b8 	.word	0x204000b8
  4014f0:	e000ed0c 	.word	0xe000ed0c

004014f4 <pvPortMalloc>:
		pxIterator->pxNextFreeBlock      = pxBlockToInsert;                                                            \
	}
/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
  4014f4:	b570      	push	{r4, r5, r6, lr}
  4014f6:	4604      	mov	r4, r0
	BlockLink_t *     pxBlock, *pxPreviousBlock, *pxNewBlockLink;
	static BaseType_t xHeapHasBeenInitialised = pdFALSE;
	void *            pvReturn                = NULL;

	vTaskSuspendAll();
  4014f8:	4b2d      	ldr	r3, [pc, #180]	; (4015b0 <pvPortMalloc+0xbc>)
  4014fa:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if (xHeapHasBeenInitialised == pdFALSE) {
  4014fc:	4b2d      	ldr	r3, [pc, #180]	; (4015b4 <pvPortMalloc+0xc0>)
  4014fe:	689b      	ldr	r3, [r3, #8]
  401500:	b18b      	cbz	r3, 401526 <pvPortMalloc+0x32>
			xHeapHasBeenInitialised = pdTRUE;
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if (xWantedSize > 0) {
  401502:	2c00      	cmp	r4, #0
  401504:	d04d      	beq.n	4015a2 <pvPortMalloc+0xae>
			xWantedSize += heapSTRUCT_SIZE;
  401506:	f104 0108 	add.w	r1, r4, #8

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if ((xWantedSize & portBYTE_ALIGNMENT_MASK) != 0) {
  40150a:	f011 0f07 	tst.w	r1, #7
  40150e:	d002      	beq.n	401516 <pvPortMalloc+0x22>
				/* Byte alignment required. */
				xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
  401510:	f021 0107 	bic.w	r1, r1, #7
  401514:	3108      	adds	r1, #8
			}
		}

		if ((xWantedSize > 0) && (xWantedSize < configADJUSTED_HEAP_SIZE)) {
  401516:	1e4a      	subs	r2, r1, #1
  401518:	f640 1356 	movw	r3, #2390	; 0x956
  40151c:	429a      	cmp	r2, r3
  40151e:	d842      	bhi.n	4015a6 <pvPortMalloc+0xb2>
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock         = xStart.pxNextFreeBlock;
  401520:	4c24      	ldr	r4, [pc, #144]	; (4015b4 <pvPortMalloc+0xc0>)
  401522:	6823      	ldr	r3, [r4, #0]
			while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
  401524:	e016      	b.n	401554 <pvPortMalloc+0x60>
{
	BlockLink_t *pxFirstFreeBlock;
	uint8_t *    pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
  401526:	4b23      	ldr	r3, [pc, #140]	; (4015b4 <pvPortMalloc+0xc0>)
  401528:	f103 0214 	add.w	r2, r3, #20
	                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
  40152c:	f022 0207 	bic.w	r2, r2, #7

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;
  401530:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize      = (size_t)0;
  401532:	2000      	movs	r0, #0
  401534:	6058      	str	r0, [r3, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize      = configADJUSTED_HEAP_SIZE;
  401536:	f640 1158 	movw	r1, #2392	; 0x958
  40153a:	f8c3 1970 	str.w	r1, [r3, #2416]	; 0x970
	xEnd.pxNextFreeBlock = NULL;
  40153e:	f8c3 096c 	str.w	r0, [r3, #2412]	; 0x96c

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock                  = (void *)pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize      = configADJUSTED_HEAP_SIZE;
  401542:	6051      	str	r1, [r2, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
  401544:	f603 116c 	addw	r1, r3, #2412	; 0x96c
  401548:	6011      	str	r1, [r2, #0]
			xHeapHasBeenInitialised = pdTRUE;
  40154a:	2201      	movs	r2, #1
  40154c:	609a      	str	r2, [r3, #8]
  40154e:	e7d8      	b.n	401502 <pvPortMalloc+0xe>
  401550:	461c      	mov	r4, r3
				pxBlock         = pxBlock->pxNextFreeBlock;
  401552:	4613      	mov	r3, r2
			while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
  401554:	685a      	ldr	r2, [r3, #4]
  401556:	4291      	cmp	r1, r2
  401558:	d902      	bls.n	401560 <pvPortMalloc+0x6c>
  40155a:	681a      	ldr	r2, [r3, #0]
  40155c:	2a00      	cmp	r2, #0
  40155e:	d1f7      	bne.n	401550 <pvPortMalloc+0x5c>
			if (pxBlock != &xEnd) {
  401560:	4a15      	ldr	r2, [pc, #84]	; (4015b8 <pvPortMalloc+0xc4>)
  401562:	4293      	cmp	r3, r2
  401564:	d021      	beq.n	4015aa <pvPortMalloc+0xb6>
				pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + heapSTRUCT_SIZE);
  401566:	6825      	ldr	r5, [r4, #0]
  401568:	3508      	adds	r5, #8
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  40156a:	681a      	ldr	r2, [r3, #0]
  40156c:	6022      	str	r2, [r4, #0]
				if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
  40156e:	685a      	ldr	r2, [r3, #4]
  401570:	1a52      	subs	r2, r2, r1
  401572:	2a10      	cmp	r2, #16
  401574:	d90c      	bls.n	401590 <pvPortMalloc+0x9c>
					pxNewBlockLink = (void *)(((uint8_t *)pxBlock) + xWantedSize);
  401576:	185e      	adds	r6, r3, r1
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  401578:	6072      	str	r2, [r6, #4]
					pxBlock->xBlockSize        = xWantedSize;
  40157a:	6059      	str	r1, [r3, #4]
					prvInsertBlockIntoFreeList((pxNewBlockLink));
  40157c:	6874      	ldr	r4, [r6, #4]
  40157e:	490d      	ldr	r1, [pc, #52]	; (4015b4 <pvPortMalloc+0xc0>)
  401580:	e000      	b.n	401584 <pvPortMalloc+0x90>
  401582:	4611      	mov	r1, r2
  401584:	680a      	ldr	r2, [r1, #0]
  401586:	6850      	ldr	r0, [r2, #4]
  401588:	4284      	cmp	r4, r0
  40158a:	d8fa      	bhi.n	401582 <pvPortMalloc+0x8e>
  40158c:	6032      	str	r2, [r6, #0]
  40158e:	600e      	str	r6, [r1, #0]
				xFreeBytesRemaining -= pxBlock->xBlockSize;
  401590:	490a      	ldr	r1, [pc, #40]	; (4015bc <pvPortMalloc+0xc8>)
  401592:	680a      	ldr	r2, [r1, #0]
  401594:	685b      	ldr	r3, [r3, #4]
  401596:	1ad2      	subs	r2, r2, r3
  401598:	600a      	str	r2, [r1, #0]
	(void)xTaskResumeAll();
  40159a:	4b09      	ldr	r3, [pc, #36]	; (4015c0 <pvPortMalloc+0xcc>)
  40159c:	4798      	blx	r3
}
  40159e:	4628      	mov	r0, r5
  4015a0:	bd70      	pop	{r4, r5, r6, pc}
	void *            pvReturn                = NULL;
  4015a2:	2500      	movs	r5, #0
  4015a4:	e7f9      	b.n	40159a <pvPortMalloc+0xa6>
  4015a6:	2500      	movs	r5, #0
  4015a8:	e7f7      	b.n	40159a <pvPortMalloc+0xa6>
  4015aa:	2500      	movs	r5, #0
  4015ac:	e7f5      	b.n	40159a <pvPortMalloc+0xa6>
  4015ae:	bf00      	nop
  4015b0:	004025f9 	.word	0x004025f9
  4015b4:	204000c0 	.word	0x204000c0
  4015b8:	20400a2c 	.word	0x20400a2c
  4015bc:	20400004 	.word	0x20400004
  4015c0:	0040274d 	.word	0x0040274d

004015c4 <vPortFree>:
	if (pv != NULL) {
  4015c4:	b1d0      	cbz	r0, 4015fc <vPortFree+0x38>
{
  4015c6:	b570      	push	{r4, r5, r6, lr}
  4015c8:	4605      	mov	r5, r0
		puc -= heapSTRUCT_SIZE;
  4015ca:	f1a0 0608 	sub.w	r6, r0, #8
		vTaskSuspendAll();
  4015ce:	4b0c      	ldr	r3, [pc, #48]	; (401600 <vPortFree+0x3c>)
  4015d0:	4798      	blx	r3
			prvInsertBlockIntoFreeList(((BlockLink_t *)pxLink));
  4015d2:	f855 4c04 	ldr.w	r4, [r5, #-4]
  4015d6:	4a0b      	ldr	r2, [pc, #44]	; (401604 <vPortFree+0x40>)
  4015d8:	e000      	b.n	4015dc <vPortFree+0x18>
  4015da:	461a      	mov	r2, r3
  4015dc:	6813      	ldr	r3, [r2, #0]
  4015de:	6859      	ldr	r1, [r3, #4]
  4015e0:	428c      	cmp	r4, r1
  4015e2:	d8fa      	bhi.n	4015da <vPortFree+0x16>
  4015e4:	f845 3c08 	str.w	r3, [r5, #-8]
  4015e8:	6016      	str	r6, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
  4015ea:	4a07      	ldr	r2, [pc, #28]	; (401608 <vPortFree+0x44>)
  4015ec:	f855 3c04 	ldr.w	r3, [r5, #-4]
  4015f0:	6811      	ldr	r1, [r2, #0]
  4015f2:	440b      	add	r3, r1
  4015f4:	6013      	str	r3, [r2, #0]
		(void)xTaskResumeAll();
  4015f6:	4b05      	ldr	r3, [pc, #20]	; (40160c <vPortFree+0x48>)
  4015f8:	4798      	blx	r3
  4015fa:	bd70      	pop	{r4, r5, r6, pc}
  4015fc:	4770      	bx	lr
  4015fe:	bf00      	nop
  401600:	004025f9 	.word	0x004025f9
  401604:	204000c0 	.word	0x204000c0
  401608:	20400004 	.word	0x20400004
  40160c:	0040274d 	.word	0x0040274d

00401610 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
  401610:	b510      	push	{r4, lr}
  401612:	4604      	mov	r4, r0
	BaseType_t xReturn;

	taskENTER_CRITICAL();
  401614:	4b04      	ldr	r3, [pc, #16]	; (401628 <prvIsQueueEmpty+0x18>)
  401616:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
  401618:	6ba4      	ldr	r4, [r4, #56]	; 0x38
			xReturn = pdTRUE;
		} else {
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
  40161a:	4b04      	ldr	r3, [pc, #16]	; (40162c <prvIsQueueEmpty+0x1c>)
  40161c:	4798      	blx	r3

	return xReturn;
}
  40161e:	fab4 f084 	clz	r0, r4
  401622:	0940      	lsrs	r0, r0, #5
  401624:	bd10      	pop	{r4, pc}
  401626:	bf00      	nop
  401628:	00401275 	.word	0x00401275
  40162c:	004012c1 	.word	0x004012c1

00401630 <prvCopyDataToQueue>:
{
  401630:	b570      	push	{r4, r5, r6, lr}
  401632:	4604      	mov	r4, r0
  401634:	4616      	mov	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  401636:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
  401638:	6c02      	ldr	r2, [r0, #64]	; 0x40
  40163a:	b952      	cbnz	r2, 401652 <prvCopyDataToQueue+0x22>
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
  40163c:	6803      	ldr	r3, [r0, #0]
  40163e:	2b00      	cmp	r3, #0
  401640:	d12a      	bne.n	401698 <prvCopyDataToQueue+0x68>
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
  401642:	6840      	ldr	r0, [r0, #4]
  401644:	4b17      	ldr	r3, [pc, #92]	; (4016a4 <prvCopyDataToQueue+0x74>)
  401646:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  401648:	2300      	movs	r3, #0
  40164a:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
  40164c:	3501      	adds	r5, #1
  40164e:	63a5      	str	r5, [r4, #56]	; 0x38
}
  401650:	bd70      	pop	{r4, r5, r6, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
  401652:	b96e      	cbnz	r6, 401670 <prvCopyDataToQueue+0x40>
		(void)memcpy((void *)pxQueue->pcWriteTo,
  401654:	6880      	ldr	r0, [r0, #8]
  401656:	4b14      	ldr	r3, [pc, #80]	; (4016a8 <prvCopyDataToQueue+0x78>)
  401658:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  40165a:	68a3      	ldr	r3, [r4, #8]
  40165c:	6c22      	ldr	r2, [r4, #64]	; 0x40
  40165e:	4413      	add	r3, r2
  401660:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
  401662:	6862      	ldr	r2, [r4, #4]
  401664:	4293      	cmp	r3, r2
  401666:	d319      	bcc.n	40169c <prvCopyDataToQueue+0x6c>
			pxQueue->pcWriteTo = pxQueue->pcHead;
  401668:	6823      	ldr	r3, [r4, #0]
  40166a:	60a3      	str	r3, [r4, #8]
	BaseType_t  xReturn = pdFALSE;
  40166c:	2000      	movs	r0, #0
  40166e:	e7ed      	b.n	40164c <prvCopyDataToQueue+0x1c>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
  401670:	68c0      	ldr	r0, [r0, #12]
  401672:	4b0d      	ldr	r3, [pc, #52]	; (4016a8 <prvCopyDataToQueue+0x78>)
  401674:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
  401676:	6c23      	ldr	r3, [r4, #64]	; 0x40
  401678:	425b      	negs	r3, r3
  40167a:	68e2      	ldr	r2, [r4, #12]
  40167c:	441a      	add	r2, r3
  40167e:	60e2      	str	r2, [r4, #12]
		if (pxQueue->u.pcReadFrom
  401680:	6821      	ldr	r1, [r4, #0]
  401682:	428a      	cmp	r2, r1
  401684:	d202      	bcs.n	40168c <prvCopyDataToQueue+0x5c>
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
  401686:	6862      	ldr	r2, [r4, #4]
  401688:	4413      	add	r3, r2
  40168a:	60e3      	str	r3, [r4, #12]
			if (uxMessagesWaiting > (UBaseType_t)0) {
  40168c:	b145      	cbz	r5, 4016a0 <prvCopyDataToQueue+0x70>
  40168e:	2e02      	cmp	r6, #2
  401690:	d106      	bne.n	4016a0 <prvCopyDataToQueue+0x70>
				--uxMessagesWaiting;
  401692:	3d01      	subs	r5, #1
	BaseType_t  xReturn = pdFALSE;
  401694:	2000      	movs	r0, #0
  401696:	e7d9      	b.n	40164c <prvCopyDataToQueue+0x1c>
  401698:	2000      	movs	r0, #0
  40169a:	e7d7      	b.n	40164c <prvCopyDataToQueue+0x1c>
  40169c:	2000      	movs	r0, #0
  40169e:	e7d5      	b.n	40164c <prvCopyDataToQueue+0x1c>
  4016a0:	2000      	movs	r0, #0
  4016a2:	e7d3      	b.n	40164c <prvCopyDataToQueue+0x1c>
  4016a4:	00402e75 	.word	0x00402e75
  4016a8:	0040353d 	.word	0x0040353d

004016ac <prvNotifyQueueSetContainer>:
	/*-----------------------------------------------------------*/

#if (configUSE_QUEUE_SETS == 1)

static BaseType_t prvNotifyQueueSetContainer(const Queue_t *const pxQueue, const BaseType_t xCopyPosition)
{
  4016ac:	b570      	push	{r4, r5, r6, lr}
  4016ae:	b082      	sub	sp, #8
  4016b0:	9001      	str	r0, [sp, #4]
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
  4016b2:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
  4016b4:	b174      	cbz	r4, 4016d4 <prvNotifyQueueSetContainer+0x28>
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
  4016b6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  4016b8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  4016ba:	429a      	cmp	r2, r3
  4016bc:	d315      	bcc.n	4016ea <prvNotifyQueueSetContainer+0x3e>
  4016be:	f04f 0380 	mov.w	r3, #128	; 0x80
  4016c2:	b672      	cpsid	i
  4016c4:	f383 8811 	msr	BASEPRI, r3
  4016c8:	f3bf 8f6f 	isb	sy
  4016cc:	f3bf 8f4f 	dsb	sy
  4016d0:	b662      	cpsie	i
  4016d2:	e7fe      	b.n	4016d2 <prvNotifyQueueSetContainer+0x26>
  4016d4:	f04f 0380 	mov.w	r3, #128	; 0x80
  4016d8:	b672      	cpsid	i
  4016da:	f383 8811 	msr	BASEPRI, r3
  4016de:	f3bf 8f6f 	isb	sy
  4016e2:	f3bf 8f4f 	dsb	sy
  4016e6:	b662      	cpsie	i
  4016e8:	e7fe      	b.n	4016e8 <prvNotifyQueueSetContainer+0x3c>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
  4016ea:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  4016ec:	4293      	cmp	r3, r2
  4016ee:	d803      	bhi.n	4016f8 <prvNotifyQueueSetContainer+0x4c>
	BaseType_t xReturn             = pdFALSE;
  4016f0:	2600      	movs	r6, #0
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
  4016f2:	4630      	mov	r0, r6
  4016f4:	b002      	add	sp, #8
  4016f6:	bd70      	pop	{r4, r5, r6, pc}
  4016f8:	460a      	mov	r2, r1
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
  4016fa:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
  4016fe:	b26d      	sxtb	r5, r5
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
  401700:	a901      	add	r1, sp, #4
  401702:	4620      	mov	r0, r4
  401704:	4b0a      	ldr	r3, [pc, #40]	; (401730 <prvNotifyQueueSetContainer+0x84>)
  401706:	4798      	blx	r3
  401708:	4606      	mov	r6, r0
		if (cTxLock == queueUNLOCKED) {
  40170a:	f1b5 3fff 	cmp.w	r5, #4294967295
  40170e:	d10a      	bne.n	401726 <prvNotifyQueueSetContainer+0x7a>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
  401710:	6a63      	ldr	r3, [r4, #36]	; 0x24
  401712:	2b00      	cmp	r3, #0
  401714:	d0ed      	beq.n	4016f2 <prvNotifyQueueSetContainer+0x46>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
  401716:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40171a:	4b06      	ldr	r3, [pc, #24]	; (401734 <prvNotifyQueueSetContainer+0x88>)
  40171c:	4798      	blx	r3
  40171e:	2800      	cmp	r0, #0
					xReturn = pdTRUE;
  401720:	bf18      	it	ne
  401722:	2601      	movne	r6, #1
  401724:	e7e5      	b.n	4016f2 <prvNotifyQueueSetContainer+0x46>
			pxQueueSetContainer->cTxLock = (int8_t)(cTxLock + 1);
  401726:	1c6b      	adds	r3, r5, #1
  401728:	b25b      	sxtb	r3, r3
  40172a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  40172e:	e7e0      	b.n	4016f2 <prvNotifyQueueSetContainer+0x46>
  401730:	00401631 	.word	0x00401631
  401734:	00402abd 	.word	0x00402abd

00401738 <prvCopyDataFromQueue>:
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
  401738:	6c02      	ldr	r2, [r0, #64]	; 0x40
  40173a:	b172      	cbz	r2, 40175a <prvCopyDataFromQueue+0x22>
{
  40173c:	b510      	push	{r4, lr}
  40173e:	4603      	mov	r3, r0
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
  401740:	68c4      	ldr	r4, [r0, #12]
  401742:	4414      	add	r4, r2
  401744:	60c4      	str	r4, [r0, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
  401746:	6840      	ldr	r0, [r0, #4]
  401748:	4284      	cmp	r4, r0
  40174a:	d301      	bcc.n	401750 <prvCopyDataFromQueue+0x18>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
  40174c:	6818      	ldr	r0, [r3, #0]
  40174e:	60d8      	str	r0, [r3, #12]
  401750:	4608      	mov	r0, r1
		(void)memcpy((void *)pvBuffer,
  401752:	68d9      	ldr	r1, [r3, #12]
  401754:	4b01      	ldr	r3, [pc, #4]	; (40175c <prvCopyDataFromQueue+0x24>)
  401756:	4798      	blx	r3
  401758:	bd10      	pop	{r4, pc}
  40175a:	4770      	bx	lr
  40175c:	0040353d 	.word	0x0040353d

00401760 <prvUnlockQueue>:
{
  401760:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401764:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
  401766:	4b23      	ldr	r3, [pc, #140]	; (4017f4 <prvUnlockQueue+0x94>)
  401768:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
  40176a:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
  40176e:	b264      	sxtb	r4, r4
		while (cTxLock > queueLOCKED_UNMODIFIED) {
  401770:	2c00      	cmp	r4, #0
  401772:	dd19      	ble.n	4017a8 <prvUnlockQueue+0x48>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
  401774:	4e20      	ldr	r6, [pc, #128]	; (4017f8 <prvUnlockQueue+0x98>)
						vTaskMissedYield();
  401776:	f8df 808c 	ldr.w	r8, [pc, #140]	; 401804 <prvUnlockQueue+0xa4>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
  40177a:	4f20      	ldr	r7, [pc, #128]	; (4017fc <prvUnlockQueue+0x9c>)
  40177c:	e008      	b.n	401790 <prvUnlockQueue+0x30>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
  40177e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  401780:	b193      	cbz	r3, 4017a8 <prvUnlockQueue+0x48>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
  401782:	f105 0024 	add.w	r0, r5, #36	; 0x24
  401786:	47b8      	blx	r7
  401788:	b960      	cbnz	r0, 4017a4 <prvUnlockQueue+0x44>
  40178a:	3c01      	subs	r4, #1
  40178c:	b264      	sxtb	r4, r4
		while (cTxLock > queueLOCKED_UNMODIFIED) {
  40178e:	b15c      	cbz	r4, 4017a8 <prvUnlockQueue+0x48>
				if (pxQueue->pxQueueSetContainer != NULL) {
  401790:	6cab      	ldr	r3, [r5, #72]	; 0x48
  401792:	2b00      	cmp	r3, #0
  401794:	d0f3      	beq.n	40177e <prvUnlockQueue+0x1e>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
  401796:	2100      	movs	r1, #0
  401798:	4628      	mov	r0, r5
  40179a:	47b0      	blx	r6
  40179c:	2800      	cmp	r0, #0
  40179e:	d0f4      	beq.n	40178a <prvUnlockQueue+0x2a>
						vTaskMissedYield();
  4017a0:	47c0      	blx	r8
  4017a2:	e7f2      	b.n	40178a <prvUnlockQueue+0x2a>
							vTaskMissedYield();
  4017a4:	47c0      	blx	r8
  4017a6:	e7f0      	b.n	40178a <prvUnlockQueue+0x2a>
		pxQueue->cTxLock = queueUNLOCKED;
  4017a8:	23ff      	movs	r3, #255	; 0xff
  4017aa:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
  4017ae:	4b14      	ldr	r3, [pc, #80]	; (401800 <prvUnlockQueue+0xa0>)
  4017b0:	4798      	blx	r3
	taskENTER_CRITICAL();
  4017b2:	4b10      	ldr	r3, [pc, #64]	; (4017f4 <prvUnlockQueue+0x94>)
  4017b4:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
  4017b6:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
  4017ba:	b264      	sxtb	r4, r4
		while (cRxLock > queueLOCKED_UNMODIFIED) {
  4017bc:	2c00      	cmp	r4, #0
  4017be:	dd12      	ble.n	4017e6 <prvUnlockQueue+0x86>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
  4017c0:	692b      	ldr	r3, [r5, #16]
  4017c2:	b183      	cbz	r3, 4017e6 <prvUnlockQueue+0x86>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
  4017c4:	f105 0710 	add.w	r7, r5, #16
  4017c8:	4e0c      	ldr	r6, [pc, #48]	; (4017fc <prvUnlockQueue+0x9c>)
					vTaskMissedYield();
  4017ca:	f8df 8038 	ldr.w	r8, [pc, #56]	; 401804 <prvUnlockQueue+0xa4>
  4017ce:	e004      	b.n	4017da <prvUnlockQueue+0x7a>
  4017d0:	3c01      	subs	r4, #1
  4017d2:	b264      	sxtb	r4, r4
		while (cRxLock > queueLOCKED_UNMODIFIED) {
  4017d4:	b13c      	cbz	r4, 4017e6 <prvUnlockQueue+0x86>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
  4017d6:	692b      	ldr	r3, [r5, #16]
  4017d8:	b12b      	cbz	r3, 4017e6 <prvUnlockQueue+0x86>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
  4017da:	4638      	mov	r0, r7
  4017dc:	47b0      	blx	r6
  4017de:	2800      	cmp	r0, #0
  4017e0:	d0f6      	beq.n	4017d0 <prvUnlockQueue+0x70>
					vTaskMissedYield();
  4017e2:	47c0      	blx	r8
  4017e4:	e7f4      	b.n	4017d0 <prvUnlockQueue+0x70>
		pxQueue->cRxLock = queueUNLOCKED;
  4017e6:	23ff      	movs	r3, #255	; 0xff
  4017e8:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	taskEXIT_CRITICAL();
  4017ec:	4b04      	ldr	r3, [pc, #16]	; (401800 <prvUnlockQueue+0xa0>)
  4017ee:	4798      	blx	r3
  4017f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4017f4:	00401275 	.word	0x00401275
  4017f8:	004016ad 	.word	0x004016ad
  4017fc:	00402abd 	.word	0x00402abd
  401800:	004012c1 	.word	0x004012c1
  401804:	00402bf9 	.word	0x00402bf9

00401808 <xQueueGenericReset>:
{
  401808:	b538      	push	{r3, r4, r5, lr}
	configASSERT(pxQueue);
  40180a:	b330      	cbz	r0, 40185a <xQueueGenericReset+0x52>
  40180c:	4604      	mov	r4, r0
  40180e:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
  401810:	4b1d      	ldr	r3, [pc, #116]	; (401888 <xQueueGenericReset+0x80>)
  401812:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
  401814:	6822      	ldr	r2, [r4, #0]
  401816:	6c21      	ldr	r1, [r4, #64]	; 0x40
  401818:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  40181a:	fb03 f301 	mul.w	r3, r3, r1
  40181e:	18d0      	adds	r0, r2, r3
  401820:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
  401822:	2000      	movs	r0, #0
  401824:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo         = pxQueue->pcHead;
  401826:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
  401828:	1a5b      	subs	r3, r3, r1
  40182a:	4413      	add	r3, r2
  40182c:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock           = queueUNLOCKED;
  40182e:	23ff      	movs	r3, #255	; 0xff
  401830:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock           = queueUNLOCKED;
  401834:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if (xNewQueue == pdFALSE) {
  401838:	b9d5      	cbnz	r5, 401870 <xQueueGenericReset+0x68>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
  40183a:	6923      	ldr	r3, [r4, #16]
  40183c:	b1fb      	cbz	r3, 40187e <xQueueGenericReset+0x76>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
  40183e:	f104 0010 	add.w	r0, r4, #16
  401842:	4b12      	ldr	r3, [pc, #72]	; (40188c <xQueueGenericReset+0x84>)
  401844:	4798      	blx	r3
  401846:	b1d0      	cbz	r0, 40187e <xQueueGenericReset+0x76>
					queueYIELD_IF_USING_PREEMPTION();
  401848:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40184c:	4b10      	ldr	r3, [pc, #64]	; (401890 <xQueueGenericReset+0x88>)
  40184e:	601a      	str	r2, [r3, #0]
  401850:	f3bf 8f4f 	dsb	sy
  401854:	f3bf 8f6f 	isb	sy
  401858:	e011      	b.n	40187e <xQueueGenericReset+0x76>
  40185a:	f04f 0380 	mov.w	r3, #128	; 0x80
  40185e:	b672      	cpsid	i
  401860:	f383 8811 	msr	BASEPRI, r3
  401864:	f3bf 8f6f 	isb	sy
  401868:	f3bf 8f4f 	dsb	sy
  40186c:	b662      	cpsie	i
  40186e:	e7fe      	b.n	40186e <xQueueGenericReset+0x66>
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
  401870:	f104 0010 	add.w	r0, r4, #16
  401874:	4d07      	ldr	r5, [pc, #28]	; (401894 <xQueueGenericReset+0x8c>)
  401876:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
  401878:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40187c:	47a8      	blx	r5
	taskEXIT_CRITICAL();
  40187e:	4b06      	ldr	r3, [pc, #24]	; (401898 <xQueueGenericReset+0x90>)
  401880:	4798      	blx	r3
}
  401882:	2001      	movs	r0, #1
  401884:	bd38      	pop	{r3, r4, r5, pc}
  401886:	bf00      	nop
  401888:	00401275 	.word	0x00401275
  40188c:	00402abd 	.word	0x00402abd
  401890:	e000ed04 	.word	0xe000ed04
  401894:	00401109 	.word	0x00401109
  401898:	004012c1 	.word	0x004012c1

0040189c <xQueueGenericCreate>:
{
  40189c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT(uxQueueLength > (UBaseType_t)0);
  40189e:	b950      	cbnz	r0, 4018b6 <xQueueGenericCreate+0x1a>
  4018a0:	f04f 0380 	mov.w	r3, #128	; 0x80
  4018a4:	b672      	cpsid	i
  4018a6:	f383 8811 	msr	BASEPRI, r3
  4018aa:	f3bf 8f6f 	isb	sy
  4018ae:	f3bf 8f4f 	dsb	sy
  4018b2:	b662      	cpsie	i
  4018b4:	e7fe      	b.n	4018b4 <xQueueGenericCreate+0x18>
  4018b6:	4606      	mov	r6, r0
  4018b8:	4617      	mov	r7, r2
  4018ba:	460d      	mov	r5, r1
		xQueueSizeInBytes = (size_t)(
  4018bc:	fb01 f000 	mul.w	r0, r1, r0
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
  4018c0:	3054      	adds	r0, #84	; 0x54
  4018c2:	4b0b      	ldr	r3, [pc, #44]	; (4018f0 <xQueueGenericCreate+0x54>)
  4018c4:	4798      	blx	r3
	if (pxNewQueue != NULL) {
  4018c6:	4604      	mov	r4, r0
  4018c8:	b178      	cbz	r0, 4018ea <xQueueGenericCreate+0x4e>
	if (uxItemSize == (UBaseType_t)0) {
  4018ca:	b11d      	cbz	r5, 4018d4 <xQueueGenericCreate+0x38>
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
  4018cc:	f100 0354 	add.w	r3, r0, #84	; 0x54
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
  4018d0:	6003      	str	r3, [r0, #0]
  4018d2:	e000      	b.n	4018d6 <xQueueGenericCreate+0x3a>
		pxNewQueue->pcHead = (int8_t *)pxNewQueue;
  4018d4:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength   = uxQueueLength;
  4018d6:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
  4018d8:	6425      	str	r5, [r4, #64]	; 0x40
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
  4018da:	2101      	movs	r1, #1
  4018dc:	4620      	mov	r0, r4
  4018de:	4b05      	ldr	r3, [pc, #20]	; (4018f4 <xQueueGenericCreate+0x58>)
  4018e0:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
  4018e2:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewQueue->pxQueueSetContainer = NULL;
  4018e6:	2300      	movs	r3, #0
  4018e8:	64a3      	str	r3, [r4, #72]	; 0x48
}
  4018ea:	4620      	mov	r0, r4
  4018ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4018ee:	bf00      	nop
  4018f0:	004014f5 	.word	0x004014f5
  4018f4:	00401809 	.word	0x00401809

004018f8 <xQueueCreateCountingSemaphore>:
	configASSERT(uxMaxCount != 0);
  4018f8:	b950      	cbnz	r0, 401910 <xQueueCreateCountingSemaphore+0x18>
  4018fa:	f04f 0380 	mov.w	r3, #128	; 0x80
  4018fe:	b672      	cpsid	i
  401900:	f383 8811 	msr	BASEPRI, r3
  401904:	f3bf 8f6f 	isb	sy
  401908:	f3bf 8f4f 	dsb	sy
  40190c:	b662      	cpsie	i
  40190e:	e7fe      	b.n	40190e <xQueueCreateCountingSemaphore+0x16>
	configASSERT(uxInitialCount <= uxMaxCount);
  401910:	4288      	cmp	r0, r1
  401912:	d20a      	bcs.n	40192a <xQueueCreateCountingSemaphore+0x32>
  401914:	f04f 0380 	mov.w	r3, #128	; 0x80
  401918:	b672      	cpsid	i
  40191a:	f383 8811 	msr	BASEPRI, r3
  40191e:	f3bf 8f6f 	isb	sy
  401922:	f3bf 8f4f 	dsb	sy
  401926:	b662      	cpsie	i
  401928:	e7fe      	b.n	401928 <xQueueCreateCountingSemaphore+0x30>
{
  40192a:	b510      	push	{r4, lr}
  40192c:	460c      	mov	r4, r1
	xHandle = xQueueGenericCreate(uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE);
  40192e:	2202      	movs	r2, #2
  401930:	2100      	movs	r1, #0
  401932:	4b03      	ldr	r3, [pc, #12]	; (401940 <xQueueCreateCountingSemaphore+0x48>)
  401934:	4798      	blx	r3
	if (xHandle != NULL) {
  401936:	4603      	mov	r3, r0
  401938:	b100      	cbz	r0, 40193c <xQueueCreateCountingSemaphore+0x44>
		((Queue_t *)xHandle)->uxMessagesWaiting = uxInitialCount;
  40193a:	6384      	str	r4, [r0, #56]	; 0x38
}
  40193c:	4618      	mov	r0, r3
  40193e:	bd10      	pop	{r4, pc}
  401940:	0040189d 	.word	0x0040189d

00401944 <xQueueGenericSend>:
{
  401944:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401948:	b085      	sub	sp, #20
  40194a:	9201      	str	r2, [sp, #4]
	configASSERT(pxQueue);
  40194c:	b1b8      	cbz	r0, 40197e <xQueueGenericSend+0x3a>
  40194e:	4604      	mov	r4, r0
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
  401950:	b301      	cbz	r1, 401994 <xQueueGenericSend+0x50>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
  401952:	2b02      	cmp	r3, #2
  401954:	d02c      	beq.n	4019b0 <xQueueGenericSend+0x6c>
  401956:	461e      	mov	r6, r3
  401958:	460f      	mov	r7, r1
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
  40195a:	4b69      	ldr	r3, [pc, #420]	; (401b00 <xQueueGenericSend+0x1bc>)
  40195c:	4798      	blx	r3
  40195e:	2800      	cmp	r0, #0
  401960:	d134      	bne.n	4019cc <xQueueGenericSend+0x88>
  401962:	9b01      	ldr	r3, [sp, #4]
  401964:	2b00      	cmp	r3, #0
  401966:	d039      	beq.n	4019dc <xQueueGenericSend+0x98>
  401968:	f04f 0380 	mov.w	r3, #128	; 0x80
  40196c:	b672      	cpsid	i
  40196e:	f383 8811 	msr	BASEPRI, r3
  401972:	f3bf 8f6f 	isb	sy
  401976:	f3bf 8f4f 	dsb	sy
  40197a:	b662      	cpsie	i
  40197c:	e7fe      	b.n	40197c <xQueueGenericSend+0x38>
  40197e:	f04f 0380 	mov.w	r3, #128	; 0x80
  401982:	b672      	cpsid	i
  401984:	f383 8811 	msr	BASEPRI, r3
  401988:	f3bf 8f6f 	isb	sy
  40198c:	f3bf 8f4f 	dsb	sy
  401990:	b662      	cpsie	i
  401992:	e7fe      	b.n	401992 <xQueueGenericSend+0x4e>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
  401994:	6c02      	ldr	r2, [r0, #64]	; 0x40
  401996:	2a00      	cmp	r2, #0
  401998:	d0db      	beq.n	401952 <xQueueGenericSend+0xe>
  40199a:	f04f 0380 	mov.w	r3, #128	; 0x80
  40199e:	b672      	cpsid	i
  4019a0:	f383 8811 	msr	BASEPRI, r3
  4019a4:	f3bf 8f6f 	isb	sy
  4019a8:	f3bf 8f4f 	dsb	sy
  4019ac:	b662      	cpsie	i
  4019ae:	e7fe      	b.n	4019ae <xQueueGenericSend+0x6a>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
  4019b0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
  4019b2:	2a01      	cmp	r2, #1
  4019b4:	d0cf      	beq.n	401956 <xQueueGenericSend+0x12>
  4019b6:	f04f 0380 	mov.w	r3, #128	; 0x80
  4019ba:	b672      	cpsid	i
  4019bc:	f383 8811 	msr	BASEPRI, r3
  4019c0:	f3bf 8f6f 	isb	sy
  4019c4:	f3bf 8f4f 	dsb	sy
  4019c8:	b662      	cpsie	i
  4019ca:	e7fe      	b.n	4019ca <xQueueGenericSend+0x86>
  4019cc:	2500      	movs	r5, #0
		taskENTER_CRITICAL();
  4019ce:	f8df 815c 	ldr.w	r8, [pc, #348]	; 401b2c <xQueueGenericSend+0x1e8>
					vTaskInternalSetTimeOutState(&xTimeOut);
  4019d2:	f8df a15c 	ldr.w	sl, [pc, #348]	; 401b30 <xQueueGenericSend+0x1ec>
					portYIELD_WITHIN_API();
  4019d6:	f8df 9134 	ldr.w	r9, [pc, #308]	; 401b0c <xQueueGenericSend+0x1c8>
  4019da:	e041      	b.n	401a60 <xQueueGenericSend+0x11c>
  4019dc:	2500      	movs	r5, #0
  4019de:	e7f6      	b.n	4019ce <xQueueGenericSend+0x8a>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
  4019e0:	4632      	mov	r2, r6
  4019e2:	4639      	mov	r1, r7
  4019e4:	4620      	mov	r0, r4
  4019e6:	4b47      	ldr	r3, [pc, #284]	; (401b04 <xQueueGenericSend+0x1c0>)
  4019e8:	4798      	blx	r3
					if (pxQueue->pxQueueSetContainer != NULL) {
  4019ea:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4019ec:	b193      	cbz	r3, 401a14 <xQueueGenericSend+0xd0>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
  4019ee:	4631      	mov	r1, r6
  4019f0:	4620      	mov	r0, r4
  4019f2:	4b45      	ldr	r3, [pc, #276]	; (401b08 <xQueueGenericSend+0x1c4>)
  4019f4:	4798      	blx	r3
  4019f6:	b138      	cbz	r0, 401a08 <xQueueGenericSend+0xc4>
							queueYIELD_IF_USING_PREEMPTION();
  4019f8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4019fc:	4b43      	ldr	r3, [pc, #268]	; (401b0c <xQueueGenericSend+0x1c8>)
  4019fe:	601a      	str	r2, [r3, #0]
  401a00:	f3bf 8f4f 	dsb	sy
  401a04:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
  401a08:	4b41      	ldr	r3, [pc, #260]	; (401b10 <xQueueGenericSend+0x1cc>)
  401a0a:	4798      	blx	r3
				return pdPASS;
  401a0c:	2001      	movs	r0, #1
}
  401a0e:	b005      	add	sp, #20
  401a10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
  401a14:	6a63      	ldr	r3, [r4, #36]	; 0x24
  401a16:	b173      	cbz	r3, 401a36 <xQueueGenericSend+0xf2>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
  401a18:	f104 0024 	add.w	r0, r4, #36	; 0x24
  401a1c:	4b3d      	ldr	r3, [pc, #244]	; (401b14 <xQueueGenericSend+0x1d0>)
  401a1e:	4798      	blx	r3
  401a20:	2800      	cmp	r0, #0
  401a22:	d0f1      	beq.n	401a08 <xQueueGenericSend+0xc4>
								queueYIELD_IF_USING_PREEMPTION();
  401a24:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401a28:	4b38      	ldr	r3, [pc, #224]	; (401b0c <xQueueGenericSend+0x1c8>)
  401a2a:	601a      	str	r2, [r3, #0]
  401a2c:	f3bf 8f4f 	dsb	sy
  401a30:	f3bf 8f6f 	isb	sy
  401a34:	e7e8      	b.n	401a08 <xQueueGenericSend+0xc4>
						} else if (xYieldRequired != pdFALSE) {
  401a36:	2800      	cmp	r0, #0
  401a38:	d0e6      	beq.n	401a08 <xQueueGenericSend+0xc4>
							queueYIELD_IF_USING_PREEMPTION();
  401a3a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401a3e:	4b33      	ldr	r3, [pc, #204]	; (401b0c <xQueueGenericSend+0x1c8>)
  401a40:	601a      	str	r2, [r3, #0]
  401a42:	f3bf 8f4f 	dsb	sy
  401a46:	f3bf 8f6f 	isb	sy
  401a4a:	e7dd      	b.n	401a08 <xQueueGenericSend+0xc4>
					taskEXIT_CRITICAL();
  401a4c:	4b30      	ldr	r3, [pc, #192]	; (401b10 <xQueueGenericSend+0x1cc>)
  401a4e:	4798      	blx	r3
					return errQUEUE_FULL;
  401a50:	2000      	movs	r0, #0
  401a52:	e7dc      	b.n	401a0e <xQueueGenericSend+0xca>
				prvUnlockQueue(pxQueue);
  401a54:	4620      	mov	r0, r4
  401a56:	4b30      	ldr	r3, [pc, #192]	; (401b18 <xQueueGenericSend+0x1d4>)
  401a58:	4798      	blx	r3
				(void)xTaskResumeAll();
  401a5a:	4b30      	ldr	r3, [pc, #192]	; (401b1c <xQueueGenericSend+0x1d8>)
  401a5c:	4798      	blx	r3
  401a5e:	2501      	movs	r5, #1
		taskENTER_CRITICAL();
  401a60:	47c0      	blx	r8
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
  401a62:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  401a64:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  401a66:	429a      	cmp	r2, r3
  401a68:	d3ba      	bcc.n	4019e0 <xQueueGenericSend+0x9c>
  401a6a:	2e02      	cmp	r6, #2
  401a6c:	d0b8      	beq.n	4019e0 <xQueueGenericSend+0x9c>
				if (xTicksToWait == (TickType_t)0) {
  401a6e:	9b01      	ldr	r3, [sp, #4]
  401a70:	2b00      	cmp	r3, #0
  401a72:	d0eb      	beq.n	401a4c <xQueueGenericSend+0x108>
				} else if (xEntryTimeSet == pdFALSE) {
  401a74:	b90d      	cbnz	r5, 401a7a <xQueueGenericSend+0x136>
					vTaskInternalSetTimeOutState(&xTimeOut);
  401a76:	a802      	add	r0, sp, #8
  401a78:	47d0      	blx	sl
		taskEXIT_CRITICAL();
  401a7a:	4b25      	ldr	r3, [pc, #148]	; (401b10 <xQueueGenericSend+0x1cc>)
  401a7c:	4798      	blx	r3
		vTaskSuspendAll();
  401a7e:	4b28      	ldr	r3, [pc, #160]	; (401b20 <xQueueGenericSend+0x1dc>)
  401a80:	4798      	blx	r3
		prvLockQueue(pxQueue);
  401a82:	47c0      	blx	r8
  401a84:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  401a88:	b25b      	sxtb	r3, r3
  401a8a:	f1b3 3fff 	cmp.w	r3, #4294967295
  401a8e:	d102      	bne.n	401a96 <xQueueGenericSend+0x152>
  401a90:	2300      	movs	r3, #0
  401a92:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  401a96:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  401a9a:	b25b      	sxtb	r3, r3
  401a9c:	f1b3 3fff 	cmp.w	r3, #4294967295
  401aa0:	d102      	bne.n	401aa8 <xQueueGenericSend+0x164>
  401aa2:	2300      	movs	r3, #0
  401aa4:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  401aa8:	4b19      	ldr	r3, [pc, #100]	; (401b10 <xQueueGenericSend+0x1cc>)
  401aaa:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
  401aac:	a901      	add	r1, sp, #4
  401aae:	a802      	add	r0, sp, #8
  401ab0:	4b1c      	ldr	r3, [pc, #112]	; (401b24 <xQueueGenericSend+0x1e0>)
  401ab2:	4798      	blx	r3
  401ab4:	b9e0      	cbnz	r0, 401af0 <xQueueGenericSend+0x1ac>
	taskENTER_CRITICAL();
  401ab6:	47c0      	blx	r8
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
  401ab8:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
  401abc:	6be5      	ldr	r5, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
  401abe:	4b14      	ldr	r3, [pc, #80]	; (401b10 <xQueueGenericSend+0x1cc>)
  401ac0:	4798      	blx	r3
			if (prvIsQueueFull(pxQueue) != pdFALSE) {
  401ac2:	45ab      	cmp	fp, r5
  401ac4:	d1c6      	bne.n	401a54 <xQueueGenericSend+0x110>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
  401ac6:	9901      	ldr	r1, [sp, #4]
  401ac8:	f104 0010 	add.w	r0, r4, #16
  401acc:	4b16      	ldr	r3, [pc, #88]	; (401b28 <xQueueGenericSend+0x1e4>)
  401ace:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
  401ad0:	4620      	mov	r0, r4
  401ad2:	4b11      	ldr	r3, [pc, #68]	; (401b18 <xQueueGenericSend+0x1d4>)
  401ad4:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
  401ad6:	4b11      	ldr	r3, [pc, #68]	; (401b1c <xQueueGenericSend+0x1d8>)
  401ad8:	4798      	blx	r3
  401ada:	2800      	cmp	r0, #0
  401adc:	d1bf      	bne.n	401a5e <xQueueGenericSend+0x11a>
					portYIELD_WITHIN_API();
  401ade:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  401ae2:	f8c9 3000 	str.w	r3, [r9]
  401ae6:	f3bf 8f4f 	dsb	sy
  401aea:	f3bf 8f6f 	isb	sy
  401aee:	e7b6      	b.n	401a5e <xQueueGenericSend+0x11a>
			prvUnlockQueue(pxQueue);
  401af0:	4620      	mov	r0, r4
  401af2:	4b09      	ldr	r3, [pc, #36]	; (401b18 <xQueueGenericSend+0x1d4>)
  401af4:	4798      	blx	r3
			(void)xTaskResumeAll();
  401af6:	4b09      	ldr	r3, [pc, #36]	; (401b1c <xQueueGenericSend+0x1d8>)
  401af8:	4798      	blx	r3
			return errQUEUE_FULL;
  401afa:	2000      	movs	r0, #0
  401afc:	e787      	b.n	401a0e <xQueueGenericSend+0xca>
  401afe:	bf00      	nop
  401b00:	00402db1 	.word	0x00402db1
  401b04:	00401631 	.word	0x00401631
  401b08:	004016ad 	.word	0x004016ad
  401b0c:	e000ed04 	.word	0xe000ed04
  401b10:	004012c1 	.word	0x004012c1
  401b14:	00402abd 	.word	0x00402abd
  401b18:	00401761 	.word	0x00401761
  401b1c:	0040274d 	.word	0x0040274d
  401b20:	004025f9 	.word	0x004025f9
  401b24:	00402b65 	.word	0x00402b65
  401b28:	00402a35 	.word	0x00402a35
  401b2c:	00401275 	.word	0x00401275
  401b30:	00402b51 	.word	0x00402b51

00401b34 <xQueueCreateMutex>:
{
  401b34:	b538      	push	{r3, r4, r5, lr}
	pxNewQueue = (Queue_t *)xQueueGenericCreate(uxMutexLength, uxMutexSize, ucQueueType);
  401b36:	4602      	mov	r2, r0
  401b38:	2100      	movs	r1, #0
  401b3a:	2001      	movs	r0, #1
  401b3c:	4b06      	ldr	r3, [pc, #24]	; (401b58 <xQueueCreateMutex+0x24>)
  401b3e:	4798      	blx	r3
	if (pxNewQueue != NULL) {
  401b40:	4604      	mov	r4, r0
  401b42:	b138      	cbz	r0, 401b54 <xQueueCreateMutex+0x20>
		pxNewQueue->pxMutexHolder = NULL;
  401b44:	2100      	movs	r1, #0
  401b46:	6041      	str	r1, [r0, #4]
		pxNewQueue->uxQueueType   = queueQUEUE_IS_MUTEX;
  401b48:	6001      	str	r1, [r0, #0]
		pxNewQueue->u.uxRecursiveCallCount = 0;
  401b4a:	60c1      	str	r1, [r0, #12]
		(void)xQueueGenericSend(pxNewQueue, NULL, (TickType_t)0U, queueSEND_TO_BACK);
  401b4c:	460b      	mov	r3, r1
  401b4e:	460a      	mov	r2, r1
  401b50:	4d02      	ldr	r5, [pc, #8]	; (401b5c <xQueueCreateMutex+0x28>)
  401b52:	47a8      	blx	r5
}
  401b54:	4620      	mov	r0, r4
  401b56:	bd38      	pop	{r3, r4, r5, pc}
  401b58:	0040189d 	.word	0x0040189d
  401b5c:	00401945 	.word	0x00401945

00401b60 <xQueueGenericSendFromISR>:
{
  401b60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT(pxQueue);
  401b64:	2800      	cmp	r0, #0
  401b66:	d039      	beq.n	401bdc <xQueueGenericSendFromISR+0x7c>
  401b68:	4604      	mov	r4, r0
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
  401b6a:	2900      	cmp	r1, #0
  401b6c:	d041      	beq.n	401bf2 <xQueueGenericSendFromISR+0x92>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
  401b6e:	2b02      	cmp	r3, #2
  401b70:	d04d      	beq.n	401c0e <xQueueGenericSendFromISR+0xae>
  401b72:	461f      	mov	r7, r3
  401b74:	4690      	mov	r8, r2
  401b76:	4689      	mov	r9, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  401b78:	4b3a      	ldr	r3, [pc, #232]	; (401c64 <xQueueGenericSendFromISR+0x104>)
  401b7a:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
  401b7c:	f3ef 8611 	mrs	r6, BASEPRI
  401b80:	f04f 0380 	mov.w	r3, #128	; 0x80
  401b84:	b672      	cpsid	i
  401b86:	f383 8811 	msr	BASEPRI, r3
  401b8a:	f3bf 8f6f 	isb	sy
  401b8e:	f3bf 8f4f 	dsb	sy
  401b92:	b662      	cpsie	i
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
  401b94:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  401b96:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  401b98:	429a      	cmp	r2, r3
  401b9a:	d301      	bcc.n	401ba0 <xQueueGenericSendFromISR+0x40>
  401b9c:	2f02      	cmp	r7, #2
  401b9e:	d158      	bne.n	401c52 <xQueueGenericSendFromISR+0xf2>
			const int8_t cTxLock = pxQueue->cTxLock;
  401ba0:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
  401ba4:	b26d      	sxtb	r5, r5
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
  401ba6:	463a      	mov	r2, r7
  401ba8:	4649      	mov	r1, r9
  401baa:	4620      	mov	r0, r4
  401bac:	4b2e      	ldr	r3, [pc, #184]	; (401c68 <xQueueGenericSendFromISR+0x108>)
  401bae:	4798      	blx	r3
			if (cTxLock == queueUNLOCKED) {
  401bb0:	f1b5 3fff 	cmp.w	r5, #4294967295
  401bb4:	d147      	bne.n	401c46 <xQueueGenericSendFromISR+0xe6>
					if (pxQueue->pxQueueSetContainer != NULL) {
  401bb6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  401bb8:	2b00      	cmp	r3, #0
  401bba:	d036      	beq.n	401c2a <xQueueGenericSendFromISR+0xca>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
  401bbc:	4639      	mov	r1, r7
  401bbe:	4620      	mov	r0, r4
  401bc0:	4b2a      	ldr	r3, [pc, #168]	; (401c6c <xQueueGenericSendFromISR+0x10c>)
  401bc2:	4798      	blx	r3
							if (pxHigherPriorityTaskWoken != NULL) {
  401bc4:	f1b8 0f00 	cmp.w	r8, #0
  401bc8:	d045      	beq.n	401c56 <xQueueGenericSendFromISR+0xf6>
  401bca:	2800      	cmp	r0, #0
  401bcc:	d043      	beq.n	401c56 <xQueueGenericSendFromISR+0xf6>
								*pxHigherPriorityTaskWoken = pdTRUE;
  401bce:	2001      	movs	r0, #1
  401bd0:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
  401bd4:	f386 8811 	msr	BASEPRI, r6
}
  401bd8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__asm volatile("	mov %0, %1												\n"
  401bdc:	f04f 0380 	mov.w	r3, #128	; 0x80
  401be0:	b672      	cpsid	i
  401be2:	f383 8811 	msr	BASEPRI, r3
  401be6:	f3bf 8f6f 	isb	sy
  401bea:	f3bf 8f4f 	dsb	sy
  401bee:	b662      	cpsie	i
  401bf0:	e7fe      	b.n	401bf0 <xQueueGenericSendFromISR+0x90>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
  401bf2:	6c00      	ldr	r0, [r0, #64]	; 0x40
  401bf4:	2800      	cmp	r0, #0
  401bf6:	d0ba      	beq.n	401b6e <xQueueGenericSendFromISR+0xe>
  401bf8:	f04f 0380 	mov.w	r3, #128	; 0x80
  401bfc:	b672      	cpsid	i
  401bfe:	f383 8811 	msr	BASEPRI, r3
  401c02:	f3bf 8f6f 	isb	sy
  401c06:	f3bf 8f4f 	dsb	sy
  401c0a:	b662      	cpsie	i
  401c0c:	e7fe      	b.n	401c0c <xQueueGenericSendFromISR+0xac>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
  401c0e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
  401c10:	2801      	cmp	r0, #1
  401c12:	d0ae      	beq.n	401b72 <xQueueGenericSendFromISR+0x12>
  401c14:	f04f 0380 	mov.w	r3, #128	; 0x80
  401c18:	b672      	cpsid	i
  401c1a:	f383 8811 	msr	BASEPRI, r3
  401c1e:	f3bf 8f6f 	isb	sy
  401c22:	f3bf 8f4f 	dsb	sy
  401c26:	b662      	cpsie	i
  401c28:	e7fe      	b.n	401c28 <xQueueGenericSendFromISR+0xc8>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
  401c2a:	6a63      	ldr	r3, [r4, #36]	; 0x24
  401c2c:	b1ab      	cbz	r3, 401c5a <xQueueGenericSendFromISR+0xfa>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
  401c2e:	f104 0024 	add.w	r0, r4, #36	; 0x24
  401c32:	4b0f      	ldr	r3, [pc, #60]	; (401c70 <xQueueGenericSendFromISR+0x110>)
  401c34:	4798      	blx	r3
								if (pxHigherPriorityTaskWoken != NULL) {
  401c36:	f1b8 0f00 	cmp.w	r8, #0
  401c3a:	d010      	beq.n	401c5e <xQueueGenericSendFromISR+0xfe>
  401c3c:	b178      	cbz	r0, 401c5e <xQueueGenericSendFromISR+0xfe>
									*pxHigherPriorityTaskWoken = pdTRUE;
  401c3e:	2001      	movs	r0, #1
  401c40:	f8c8 0000 	str.w	r0, [r8]
  401c44:	e7c6      	b.n	401bd4 <xQueueGenericSendFromISR+0x74>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
  401c46:	1c6b      	adds	r3, r5, #1
  401c48:	b25b      	sxtb	r3, r3
  401c4a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
  401c4e:	2001      	movs	r0, #1
  401c50:	e7c0      	b.n	401bd4 <xQueueGenericSendFromISR+0x74>
			xReturn = errQUEUE_FULL;
  401c52:	2000      	movs	r0, #0
  401c54:	e7be      	b.n	401bd4 <xQueueGenericSendFromISR+0x74>
			xReturn = pdPASS;
  401c56:	2001      	movs	r0, #1
  401c58:	e7bc      	b.n	401bd4 <xQueueGenericSendFromISR+0x74>
  401c5a:	2001      	movs	r0, #1
  401c5c:	e7ba      	b.n	401bd4 <xQueueGenericSendFromISR+0x74>
  401c5e:	2001      	movs	r0, #1
  401c60:	e7b8      	b.n	401bd4 <xQueueGenericSendFromISR+0x74>
  401c62:	bf00      	nop
  401c64:	00401495 	.word	0x00401495
  401c68:	00401631 	.word	0x00401631
  401c6c:	004016ad 	.word	0x004016ad
  401c70:	00402abd 	.word	0x00402abd

00401c74 <xQueueGiveFromISR>:
	configASSERT(pxQueue);
  401c74:	b170      	cbz	r0, 401c94 <xQueueGiveFromISR+0x20>
{
  401c76:	b570      	push	{r4, r5, r6, lr}
  401c78:	4604      	mov	r4, r0
	configASSERT(pxQueue->uxItemSize == 0);
  401c7a:	6c03      	ldr	r3, [r0, #64]	; 0x40
  401c7c:	b1ab      	cbz	r3, 401caa <xQueueGiveFromISR+0x36>
  401c7e:	f04f 0380 	mov.w	r3, #128	; 0x80
  401c82:	b672      	cpsid	i
  401c84:	f383 8811 	msr	BASEPRI, r3
  401c88:	f3bf 8f6f 	isb	sy
  401c8c:	f3bf 8f4f 	dsb	sy
  401c90:	b662      	cpsie	i
  401c92:	e7fe      	b.n	401c92 <xQueueGiveFromISR+0x1e>
  401c94:	f04f 0380 	mov.w	r3, #128	; 0x80
  401c98:	b672      	cpsid	i
  401c9a:	f383 8811 	msr	BASEPRI, r3
  401c9e:	f3bf 8f6f 	isb	sy
  401ca2:	f3bf 8f4f 	dsb	sy
  401ca6:	b662      	cpsie	i
  401ca8:	e7fe      	b.n	401ca8 <xQueueGiveFromISR+0x34>
	configASSERT(!((pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) && (pxQueue->pxMutexHolder != NULL)));
  401caa:	6803      	ldr	r3, [r0, #0]
  401cac:	b33b      	cbz	r3, 401cfe <xQueueGiveFromISR+0x8a>
  401cae:	460e      	mov	r6, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  401cb0:	4b26      	ldr	r3, [pc, #152]	; (401d4c <xQueueGiveFromISR+0xd8>)
  401cb2:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
  401cb4:	f3ef 8511 	mrs	r5, BASEPRI
  401cb8:	f04f 0380 	mov.w	r3, #128	; 0x80
  401cbc:	b672      	cpsid	i
  401cbe:	f383 8811 	msr	BASEPRI, r3
  401cc2:	f3bf 8f6f 	isb	sy
  401cc6:	f3bf 8f4f 	dsb	sy
  401cca:	b662      	cpsie	i
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  401ccc:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if (uxMessagesWaiting < pxQueue->uxLength) {
  401cce:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  401cd0:	429a      	cmp	r2, r3
  401cd2:	d233      	bcs.n	401d3c <xQueueGiveFromISR+0xc8>
			const int8_t cTxLock = pxQueue->cTxLock;
  401cd4:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  401cd8:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
  401cda:	3201      	adds	r2, #1
  401cdc:	63a2      	str	r2, [r4, #56]	; 0x38
			if (cTxLock == queueUNLOCKED) {
  401cde:	f1b3 3fff 	cmp.w	r3, #4294967295
  401ce2:	d125      	bne.n	401d30 <xQueueGiveFromISR+0xbc>
					if (pxQueue->pxQueueSetContainer != NULL) {
  401ce4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  401ce6:	b1c3      	cbz	r3, 401d1a <xQueueGiveFromISR+0xa6>
						if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
  401ce8:	2100      	movs	r1, #0
  401cea:	4620      	mov	r0, r4
  401cec:	4b18      	ldr	r3, [pc, #96]	; (401d50 <xQueueGiveFromISR+0xdc>)
  401cee:	4798      	blx	r3
							if (pxHigherPriorityTaskWoken != NULL) {
  401cf0:	b336      	cbz	r6, 401d40 <xQueueGiveFromISR+0xcc>
  401cf2:	b328      	cbz	r0, 401d40 <xQueueGiveFromISR+0xcc>
								*pxHigherPriorityTaskWoken = pdTRUE;
  401cf4:	2001      	movs	r0, #1
  401cf6:	6030      	str	r0, [r6, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
  401cf8:	f385 8811 	msr	BASEPRI, r5
}
  401cfc:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(!((pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) && (pxQueue->pxMutexHolder != NULL)));
  401cfe:	6843      	ldr	r3, [r0, #4]
  401d00:	2b00      	cmp	r3, #0
  401d02:	d0d4      	beq.n	401cae <xQueueGiveFromISR+0x3a>
	__asm volatile("	mov %0, %1												\n"
  401d04:	f04f 0380 	mov.w	r3, #128	; 0x80
  401d08:	b672      	cpsid	i
  401d0a:	f383 8811 	msr	BASEPRI, r3
  401d0e:	f3bf 8f6f 	isb	sy
  401d12:	f3bf 8f4f 	dsb	sy
  401d16:	b662      	cpsie	i
  401d18:	e7fe      	b.n	401d18 <xQueueGiveFromISR+0xa4>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
  401d1a:	6a63      	ldr	r3, [r4, #36]	; 0x24
  401d1c:	b193      	cbz	r3, 401d44 <xQueueGiveFromISR+0xd0>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
  401d1e:	f104 0024 	add.w	r0, r4, #36	; 0x24
  401d22:	4b0c      	ldr	r3, [pc, #48]	; (401d54 <xQueueGiveFromISR+0xe0>)
  401d24:	4798      	blx	r3
								if (pxHigherPriorityTaskWoken != NULL) {
  401d26:	b17e      	cbz	r6, 401d48 <xQueueGiveFromISR+0xd4>
  401d28:	b170      	cbz	r0, 401d48 <xQueueGiveFromISR+0xd4>
									*pxHigherPriorityTaskWoken = pdTRUE;
  401d2a:	2001      	movs	r0, #1
  401d2c:	6030      	str	r0, [r6, #0]
  401d2e:	e7e3      	b.n	401cf8 <xQueueGiveFromISR+0x84>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
  401d30:	3301      	adds	r3, #1
  401d32:	b25b      	sxtb	r3, r3
  401d34:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
  401d38:	2001      	movs	r0, #1
  401d3a:	e7dd      	b.n	401cf8 <xQueueGiveFromISR+0x84>
			xReturn = errQUEUE_FULL;
  401d3c:	2000      	movs	r0, #0
  401d3e:	e7db      	b.n	401cf8 <xQueueGiveFromISR+0x84>
			xReturn = pdPASS;
  401d40:	2001      	movs	r0, #1
  401d42:	e7d9      	b.n	401cf8 <xQueueGiveFromISR+0x84>
  401d44:	2001      	movs	r0, #1
  401d46:	e7d7      	b.n	401cf8 <xQueueGiveFromISR+0x84>
  401d48:	2001      	movs	r0, #1
  401d4a:	e7d5      	b.n	401cf8 <xQueueGiveFromISR+0x84>
  401d4c:	00401495 	.word	0x00401495
  401d50:	004016ad 	.word	0x004016ad
  401d54:	00402abd 	.word	0x00402abd

00401d58 <xQueueReceive>:
{
  401d58:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  401d5c:	b084      	sub	sp, #16
  401d5e:	9201      	str	r2, [sp, #4]
	configASSERT((pxQueue));
  401d60:	b190      	cbz	r0, 401d88 <xQueueReceive+0x30>
  401d62:	4604      	mov	r4, r0
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
  401d64:	b1d9      	cbz	r1, 401d9e <xQueueReceive+0x46>
  401d66:	460e      	mov	r6, r1
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
  401d68:	4b54      	ldr	r3, [pc, #336]	; (401ebc <xQueueReceive+0x164>)
  401d6a:	4798      	blx	r3
  401d6c:	bb28      	cbnz	r0, 401dba <xQueueReceive+0x62>
  401d6e:	9b01      	ldr	r3, [sp, #4]
  401d70:	b35b      	cbz	r3, 401dca <xQueueReceive+0x72>
  401d72:	f04f 0380 	mov.w	r3, #128	; 0x80
  401d76:	b672      	cpsid	i
  401d78:	f383 8811 	msr	BASEPRI, r3
  401d7c:	f3bf 8f6f 	isb	sy
  401d80:	f3bf 8f4f 	dsb	sy
  401d84:	b662      	cpsie	i
  401d86:	e7fe      	b.n	401d86 <xQueueReceive+0x2e>
  401d88:	f04f 0380 	mov.w	r3, #128	; 0x80
  401d8c:	b672      	cpsid	i
  401d8e:	f383 8811 	msr	BASEPRI, r3
  401d92:	f3bf 8f6f 	isb	sy
  401d96:	f3bf 8f4f 	dsb	sy
  401d9a:	b662      	cpsie	i
  401d9c:	e7fe      	b.n	401d9c <xQueueReceive+0x44>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
  401d9e:	6c03      	ldr	r3, [r0, #64]	; 0x40
  401da0:	2b00      	cmp	r3, #0
  401da2:	d0e0      	beq.n	401d66 <xQueueReceive+0xe>
  401da4:	f04f 0380 	mov.w	r3, #128	; 0x80
  401da8:	b672      	cpsid	i
  401daa:	f383 8811 	msr	BASEPRI, r3
  401dae:	f3bf 8f6f 	isb	sy
  401db2:	f3bf 8f4f 	dsb	sy
  401db6:	b662      	cpsie	i
  401db8:	e7fe      	b.n	401db8 <xQueueReceive+0x60>
  401dba:	2700      	movs	r7, #0
		taskENTER_CRITICAL();
  401dbc:	f8df 8128 	ldr.w	r8, [pc, #296]	; 401ee8 <xQueueReceive+0x190>
					vTaskInternalSetTimeOutState(&xTimeOut);
  401dc0:	f8df a128 	ldr.w	sl, [pc, #296]	; 401eec <xQueueReceive+0x194>
					portYIELD_WITHIN_API();
  401dc4:	f8df 9100 	ldr.w	r9, [pc, #256]	; 401ec8 <xQueueReceive+0x170>
  401dc8:	e031      	b.n	401e2e <xQueueReceive+0xd6>
  401dca:	2700      	movs	r7, #0
  401dcc:	e7f6      	b.n	401dbc <xQueueReceive+0x64>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
  401dce:	4631      	mov	r1, r6
  401dd0:	4620      	mov	r0, r4
  401dd2:	4b3b      	ldr	r3, [pc, #236]	; (401ec0 <xQueueReceive+0x168>)
  401dd4:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
  401dd6:	3d01      	subs	r5, #1
  401dd8:	63a5      	str	r5, [r4, #56]	; 0x38
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
  401dda:	6923      	ldr	r3, [r4, #16]
  401ddc:	b163      	cbz	r3, 401df8 <xQueueReceive+0xa0>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
  401dde:	f104 0010 	add.w	r0, r4, #16
  401de2:	4b38      	ldr	r3, [pc, #224]	; (401ec4 <xQueueReceive+0x16c>)
  401de4:	4798      	blx	r3
  401de6:	b138      	cbz	r0, 401df8 <xQueueReceive+0xa0>
						queueYIELD_IF_USING_PREEMPTION();
  401de8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401dec:	4b36      	ldr	r3, [pc, #216]	; (401ec8 <xQueueReceive+0x170>)
  401dee:	601a      	str	r2, [r3, #0]
  401df0:	f3bf 8f4f 	dsb	sy
  401df4:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
  401df8:	4b34      	ldr	r3, [pc, #208]	; (401ecc <xQueueReceive+0x174>)
  401dfa:	4798      	blx	r3
				return pdPASS;
  401dfc:	2001      	movs	r0, #1
}
  401dfe:	b004      	add	sp, #16
  401e00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					taskEXIT_CRITICAL();
  401e04:	4b31      	ldr	r3, [pc, #196]	; (401ecc <xQueueReceive+0x174>)
  401e06:	4798      	blx	r3
					return errQUEUE_EMPTY;
  401e08:	2000      	movs	r0, #0
  401e0a:	e7f8      	b.n	401dfe <xQueueReceive+0xa6>
					vTaskInternalSetTimeOutState(&xTimeOut);
  401e0c:	a802      	add	r0, sp, #8
  401e0e:	47d0      	blx	sl
  401e10:	e016      	b.n	401e40 <xQueueReceive+0xe8>
		prvLockQueue(pxQueue);
  401e12:	2300      	movs	r3, #0
  401e14:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  401e18:	e01d      	b.n	401e56 <xQueueReceive+0xfe>
  401e1a:	2300      	movs	r3, #0
  401e1c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  401e20:	e01f      	b.n	401e62 <xQueueReceive+0x10a>
				prvUnlockQueue(pxQueue);
  401e22:	4620      	mov	r0, r4
  401e24:	4b2a      	ldr	r3, [pc, #168]	; (401ed0 <xQueueReceive+0x178>)
  401e26:	4798      	blx	r3
				(void)xTaskResumeAll();
  401e28:	4b2a      	ldr	r3, [pc, #168]	; (401ed4 <xQueueReceive+0x17c>)
  401e2a:	4798      	blx	r3
  401e2c:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
  401e2e:	47c0      	blx	r8
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  401e30:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if (uxMessagesWaiting > (UBaseType_t)0) {
  401e32:	2d00      	cmp	r5, #0
  401e34:	d1cb      	bne.n	401dce <xQueueReceive+0x76>
				if (xTicksToWait == (TickType_t)0) {
  401e36:	9b01      	ldr	r3, [sp, #4]
  401e38:	2b00      	cmp	r3, #0
  401e3a:	d0e3      	beq.n	401e04 <xQueueReceive+0xac>
				} else if (xEntryTimeSet == pdFALSE) {
  401e3c:	2f00      	cmp	r7, #0
  401e3e:	d0e5      	beq.n	401e0c <xQueueReceive+0xb4>
		taskEXIT_CRITICAL();
  401e40:	4b22      	ldr	r3, [pc, #136]	; (401ecc <xQueueReceive+0x174>)
  401e42:	4798      	blx	r3
		vTaskSuspendAll();
  401e44:	4b24      	ldr	r3, [pc, #144]	; (401ed8 <xQueueReceive+0x180>)
  401e46:	4798      	blx	r3
		prvLockQueue(pxQueue);
  401e48:	47c0      	blx	r8
  401e4a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  401e4e:	b25b      	sxtb	r3, r3
  401e50:	f1b3 3fff 	cmp.w	r3, #4294967295
  401e54:	d0dd      	beq.n	401e12 <xQueueReceive+0xba>
  401e56:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  401e5a:	b25b      	sxtb	r3, r3
  401e5c:	f1b3 3fff 	cmp.w	r3, #4294967295
  401e60:	d0db      	beq.n	401e1a <xQueueReceive+0xc2>
  401e62:	4b1a      	ldr	r3, [pc, #104]	; (401ecc <xQueueReceive+0x174>)
  401e64:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
  401e66:	a901      	add	r1, sp, #4
  401e68:	a802      	add	r0, sp, #8
  401e6a:	4b1c      	ldr	r3, [pc, #112]	; (401edc <xQueueReceive+0x184>)
  401e6c:	4798      	blx	r3
  401e6e:	b9c8      	cbnz	r0, 401ea4 <xQueueReceive+0x14c>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
  401e70:	4620      	mov	r0, r4
  401e72:	4b1b      	ldr	r3, [pc, #108]	; (401ee0 <xQueueReceive+0x188>)
  401e74:	4798      	blx	r3
  401e76:	2800      	cmp	r0, #0
  401e78:	d0d3      	beq.n	401e22 <xQueueReceive+0xca>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
  401e7a:	9901      	ldr	r1, [sp, #4]
  401e7c:	f104 0024 	add.w	r0, r4, #36	; 0x24
  401e80:	4b18      	ldr	r3, [pc, #96]	; (401ee4 <xQueueReceive+0x18c>)
  401e82:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
  401e84:	4620      	mov	r0, r4
  401e86:	4b12      	ldr	r3, [pc, #72]	; (401ed0 <xQueueReceive+0x178>)
  401e88:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
  401e8a:	4b12      	ldr	r3, [pc, #72]	; (401ed4 <xQueueReceive+0x17c>)
  401e8c:	4798      	blx	r3
  401e8e:	2800      	cmp	r0, #0
  401e90:	d1cc      	bne.n	401e2c <xQueueReceive+0xd4>
					portYIELD_WITHIN_API();
  401e92:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  401e96:	f8c9 3000 	str.w	r3, [r9]
  401e9a:	f3bf 8f4f 	dsb	sy
  401e9e:	f3bf 8f6f 	isb	sy
  401ea2:	e7c3      	b.n	401e2c <xQueueReceive+0xd4>
			prvUnlockQueue(pxQueue);
  401ea4:	4620      	mov	r0, r4
  401ea6:	4b0a      	ldr	r3, [pc, #40]	; (401ed0 <xQueueReceive+0x178>)
  401ea8:	4798      	blx	r3
			(void)xTaskResumeAll();
  401eaa:	4b0a      	ldr	r3, [pc, #40]	; (401ed4 <xQueueReceive+0x17c>)
  401eac:	4798      	blx	r3
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
  401eae:	4620      	mov	r0, r4
  401eb0:	4b0b      	ldr	r3, [pc, #44]	; (401ee0 <xQueueReceive+0x188>)
  401eb2:	4798      	blx	r3
  401eb4:	2800      	cmp	r0, #0
  401eb6:	d0b9      	beq.n	401e2c <xQueueReceive+0xd4>
				return errQUEUE_EMPTY;
  401eb8:	2000      	movs	r0, #0
  401eba:	e7a0      	b.n	401dfe <xQueueReceive+0xa6>
  401ebc:	00402db1 	.word	0x00402db1
  401ec0:	00401739 	.word	0x00401739
  401ec4:	00402abd 	.word	0x00402abd
  401ec8:	e000ed04 	.word	0xe000ed04
  401ecc:	004012c1 	.word	0x004012c1
  401ed0:	00401761 	.word	0x00401761
  401ed4:	0040274d 	.word	0x0040274d
  401ed8:	004025f9 	.word	0x004025f9
  401edc:	00402b65 	.word	0x00402b65
  401ee0:	00401611 	.word	0x00401611
  401ee4:	00402a35 	.word	0x00402a35
  401ee8:	00401275 	.word	0x00401275
  401eec:	00402b51 	.word	0x00402b51

00401ef0 <xQueueSemaphoreTake>:
{
  401ef0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  401ef4:	b085      	sub	sp, #20
  401ef6:	9101      	str	r1, [sp, #4]
	configASSERT((pxQueue));
  401ef8:	b168      	cbz	r0, 401f16 <xQueueSemaphoreTake+0x26>
  401efa:	4604      	mov	r4, r0
	configASSERT(pxQueue->uxItemSize == 0);
  401efc:	6c03      	ldr	r3, [r0, #64]	; 0x40
  401efe:	b1ab      	cbz	r3, 401f2c <xQueueSemaphoreTake+0x3c>
  401f00:	f04f 0380 	mov.w	r3, #128	; 0x80
  401f04:	b672      	cpsid	i
  401f06:	f383 8811 	msr	BASEPRI, r3
  401f0a:	f3bf 8f6f 	isb	sy
  401f0e:	f3bf 8f4f 	dsb	sy
  401f12:	b662      	cpsie	i
  401f14:	e7fe      	b.n	401f14 <xQueueSemaphoreTake+0x24>
  401f16:	f04f 0380 	mov.w	r3, #128	; 0x80
  401f1a:	b672      	cpsid	i
  401f1c:	f383 8811 	msr	BASEPRI, r3
  401f20:	f3bf 8f6f 	isb	sy
  401f24:	f3bf 8f4f 	dsb	sy
  401f28:	b662      	cpsie	i
  401f2a:	e7fe      	b.n	401f2a <xQueueSemaphoreTake+0x3a>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
  401f2c:	4b5e      	ldr	r3, [pc, #376]	; (4020a8 <xQueueSemaphoreTake+0x1b8>)
  401f2e:	4798      	blx	r3
  401f30:	b960      	cbnz	r0, 401f4c <xQueueSemaphoreTake+0x5c>
  401f32:	9b01      	ldr	r3, [sp, #4]
  401f34:	b193      	cbz	r3, 401f5c <xQueueSemaphoreTake+0x6c>
  401f36:	f04f 0380 	mov.w	r3, #128	; 0x80
  401f3a:	b672      	cpsid	i
  401f3c:	f383 8811 	msr	BASEPRI, r3
  401f40:	f3bf 8f6f 	isb	sy
  401f44:	f3bf 8f4f 	dsb	sy
  401f48:	b662      	cpsie	i
  401f4a:	e7fe      	b.n	401f4a <xQueueSemaphoreTake+0x5a>
  401f4c:	2500      	movs	r5, #0
  401f4e:	462f      	mov	r7, r5
		taskENTER_CRITICAL();
  401f50:	4e56      	ldr	r6, [pc, #344]	; (4020ac <xQueueSemaphoreTake+0x1bc>)
					vTaskInternalSetTimeOutState(&xTimeOut);
  401f52:	f8df 918c 	ldr.w	r9, [pc, #396]	; 4020e0 <xQueueSemaphoreTake+0x1f0>
					portYIELD_WITHIN_API();
  401f56:	f8df 8160 	ldr.w	r8, [pc, #352]	; 4020b8 <xQueueSemaphoreTake+0x1c8>
  401f5a:	e052      	b.n	402002 <xQueueSemaphoreTake+0x112>
  401f5c:	2500      	movs	r5, #0
  401f5e:	462f      	mov	r7, r5
  401f60:	e7f6      	b.n	401f50 <xQueueSemaphoreTake+0x60>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - (UBaseType_t)1;
  401f62:	3b01      	subs	r3, #1
  401f64:	63a3      	str	r3, [r4, #56]	; 0x38
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
  401f66:	6823      	ldr	r3, [r4, #0]
  401f68:	b913      	cbnz	r3, 401f70 <xQueueSemaphoreTake+0x80>
						    = (int8_t *)pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as
  401f6a:	4b51      	ldr	r3, [pc, #324]	; (4020b0 <xQueueSemaphoreTake+0x1c0>)
  401f6c:	4798      	blx	r3
  401f6e:	6060      	str	r0, [r4, #4]
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
  401f70:	6923      	ldr	r3, [r4, #16]
  401f72:	b163      	cbz	r3, 401f8e <xQueueSemaphoreTake+0x9e>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
  401f74:	f104 0010 	add.w	r0, r4, #16
  401f78:	4b4e      	ldr	r3, [pc, #312]	; (4020b4 <xQueueSemaphoreTake+0x1c4>)
  401f7a:	4798      	blx	r3
  401f7c:	b138      	cbz	r0, 401f8e <xQueueSemaphoreTake+0x9e>
						queueYIELD_IF_USING_PREEMPTION();
  401f7e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  401f82:	4b4d      	ldr	r3, [pc, #308]	; (4020b8 <xQueueSemaphoreTake+0x1c8>)
  401f84:	601a      	str	r2, [r3, #0]
  401f86:	f3bf 8f4f 	dsb	sy
  401f8a:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
  401f8e:	4b4b      	ldr	r3, [pc, #300]	; (4020bc <xQueueSemaphoreTake+0x1cc>)
  401f90:	4798      	blx	r3
				return pdPASS;
  401f92:	2501      	movs	r5, #1
}
  401f94:	4628      	mov	r0, r5
  401f96:	b005      	add	sp, #20
  401f98:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
						configASSERT(xInheritanceOccurred == pdFALSE);
  401f9c:	b155      	cbz	r5, 401fb4 <xQueueSemaphoreTake+0xc4>
  401f9e:	f04f 0380 	mov.w	r3, #128	; 0x80
  401fa2:	b672      	cpsid	i
  401fa4:	f383 8811 	msr	BASEPRI, r3
  401fa8:	f3bf 8f6f 	isb	sy
  401fac:	f3bf 8f4f 	dsb	sy
  401fb0:	b662      	cpsie	i
  401fb2:	e7fe      	b.n	401fb2 <xQueueSemaphoreTake+0xc2>
					taskEXIT_CRITICAL();
  401fb4:	4b41      	ldr	r3, [pc, #260]	; (4020bc <xQueueSemaphoreTake+0x1cc>)
  401fb6:	4798      	blx	r3
					return errQUEUE_EMPTY;
  401fb8:	e7ec      	b.n	401f94 <xQueueSemaphoreTake+0xa4>
					vTaskInternalSetTimeOutState(&xTimeOut);
  401fba:	a802      	add	r0, sp, #8
  401fbc:	47c8      	blx	r9
  401fbe:	e029      	b.n	402014 <xQueueSemaphoreTake+0x124>
		prvLockQueue(pxQueue);
  401fc0:	2300      	movs	r3, #0
  401fc2:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  401fc6:	e030      	b.n	40202a <xQueueSemaphoreTake+0x13a>
  401fc8:	2300      	movs	r3, #0
  401fca:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  401fce:	e032      	b.n	402036 <xQueueSemaphoreTake+0x146>
						taskENTER_CRITICAL();
  401fd0:	47b0      	blx	r6
							xInheritanceOccurred = xTaskPriorityInherit((void *)pxQueue->pxMutexHolder);
  401fd2:	6860      	ldr	r0, [r4, #4]
  401fd4:	4b3a      	ldr	r3, [pc, #232]	; (4020c0 <xQueueSemaphoreTake+0x1d0>)
  401fd6:	4798      	blx	r3
  401fd8:	4605      	mov	r5, r0
						taskEXIT_CRITICAL();
  401fda:	4b38      	ldr	r3, [pc, #224]	; (4020bc <xQueueSemaphoreTake+0x1cc>)
  401fdc:	4798      	blx	r3
  401fde:	e03a      	b.n	402056 <xQueueSemaphoreTake+0x166>
				prvUnlockQueue(pxQueue);
  401fe0:	4620      	mov	r0, r4
  401fe2:	4b38      	ldr	r3, [pc, #224]	; (4020c4 <xQueueSemaphoreTake+0x1d4>)
  401fe4:	4798      	blx	r3
				(void)xTaskResumeAll();
  401fe6:	4b38      	ldr	r3, [pc, #224]	; (4020c8 <xQueueSemaphoreTake+0x1d8>)
  401fe8:	4798      	blx	r3
  401fea:	e009      	b.n	402000 <xQueueSemaphoreTake+0x110>
			prvUnlockQueue(pxQueue);
  401fec:	4620      	mov	r0, r4
  401fee:	4b35      	ldr	r3, [pc, #212]	; (4020c4 <xQueueSemaphoreTake+0x1d4>)
  401ff0:	4798      	blx	r3
			(void)xTaskResumeAll();
  401ff2:	4b35      	ldr	r3, [pc, #212]	; (4020c8 <xQueueSemaphoreTake+0x1d8>)
  401ff4:	4798      	blx	r3
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
  401ff6:	4620      	mov	r0, r4
  401ff8:	4b34      	ldr	r3, [pc, #208]	; (4020cc <xQueueSemaphoreTake+0x1dc>)
  401ffa:	4798      	blx	r3
  401ffc:	2800      	cmp	r0, #0
  401ffe:	d13f      	bne.n	402080 <xQueueSemaphoreTake+0x190>
  402000:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
  402002:	47b0      	blx	r6
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
  402004:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if (uxSemaphoreCount > (UBaseType_t)0) {
  402006:	2b00      	cmp	r3, #0
  402008:	d1ab      	bne.n	401f62 <xQueueSemaphoreTake+0x72>
				if (xTicksToWait == (TickType_t)0) {
  40200a:	9b01      	ldr	r3, [sp, #4]
  40200c:	2b00      	cmp	r3, #0
  40200e:	d0c5      	beq.n	401f9c <xQueueSemaphoreTake+0xac>
				} else if (xEntryTimeSet == pdFALSE) {
  402010:	2f00      	cmp	r7, #0
  402012:	d0d2      	beq.n	401fba <xQueueSemaphoreTake+0xca>
		taskEXIT_CRITICAL();
  402014:	4b29      	ldr	r3, [pc, #164]	; (4020bc <xQueueSemaphoreTake+0x1cc>)
  402016:	4798      	blx	r3
		vTaskSuspendAll();
  402018:	4b2d      	ldr	r3, [pc, #180]	; (4020d0 <xQueueSemaphoreTake+0x1e0>)
  40201a:	4798      	blx	r3
		prvLockQueue(pxQueue);
  40201c:	47b0      	blx	r6
  40201e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  402022:	b25b      	sxtb	r3, r3
  402024:	f1b3 3fff 	cmp.w	r3, #4294967295
  402028:	d0ca      	beq.n	401fc0 <xQueueSemaphoreTake+0xd0>
  40202a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  40202e:	b25b      	sxtb	r3, r3
  402030:	f1b3 3fff 	cmp.w	r3, #4294967295
  402034:	d0c8      	beq.n	401fc8 <xQueueSemaphoreTake+0xd8>
  402036:	4b21      	ldr	r3, [pc, #132]	; (4020bc <xQueueSemaphoreTake+0x1cc>)
  402038:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
  40203a:	a901      	add	r1, sp, #4
  40203c:	a802      	add	r0, sp, #8
  40203e:	4b25      	ldr	r3, [pc, #148]	; (4020d4 <xQueueSemaphoreTake+0x1e4>)
  402040:	4798      	blx	r3
  402042:	2800      	cmp	r0, #0
  402044:	d1d2      	bne.n	401fec <xQueueSemaphoreTake+0xfc>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
  402046:	4620      	mov	r0, r4
  402048:	4b20      	ldr	r3, [pc, #128]	; (4020cc <xQueueSemaphoreTake+0x1dc>)
  40204a:	4798      	blx	r3
  40204c:	2800      	cmp	r0, #0
  40204e:	d0c7      	beq.n	401fe0 <xQueueSemaphoreTake+0xf0>
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
  402050:	6823      	ldr	r3, [r4, #0]
  402052:	2b00      	cmp	r3, #0
  402054:	d0bc      	beq.n	401fd0 <xQueueSemaphoreTake+0xe0>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
  402056:	9901      	ldr	r1, [sp, #4]
  402058:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40205c:	4b1e      	ldr	r3, [pc, #120]	; (4020d8 <xQueueSemaphoreTake+0x1e8>)
  40205e:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
  402060:	4620      	mov	r0, r4
  402062:	4b18      	ldr	r3, [pc, #96]	; (4020c4 <xQueueSemaphoreTake+0x1d4>)
  402064:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
  402066:	4b18      	ldr	r3, [pc, #96]	; (4020c8 <xQueueSemaphoreTake+0x1d8>)
  402068:	4798      	blx	r3
  40206a:	2800      	cmp	r0, #0
  40206c:	d1c8      	bne.n	402000 <xQueueSemaphoreTake+0x110>
					portYIELD_WITHIN_API();
  40206e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  402072:	f8c8 3000 	str.w	r3, [r8]
  402076:	f3bf 8f4f 	dsb	sy
  40207a:	f3bf 8f6f 	isb	sy
  40207e:	e7bf      	b.n	402000 <xQueueSemaphoreTake+0x110>
					if (xInheritanceOccurred != pdFALSE) {
  402080:	2d00      	cmp	r5, #0
  402082:	d087      	beq.n	401f94 <xQueueSemaphoreTake+0xa4>
						taskENTER_CRITICAL();
  402084:	4b09      	ldr	r3, [pc, #36]	; (4020ac <xQueueSemaphoreTake+0x1bc>)
  402086:	4798      	blx	r3
	if (listCURRENT_LIST_LENGTH(&(pxQueue->xTasksWaitingToReceive)) > 0) {
  402088:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40208a:	b153      	cbz	r3, 4020a2 <xQueueSemaphoreTake+0x1b2>
		    = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY(&(pxQueue->xTasksWaitingToReceive));
  40208c:	6b23      	ldr	r3, [r4, #48]	; 0x30
  40208e:	6819      	ldr	r1, [r3, #0]
  402090:	f1c1 0105 	rsb	r1, r1, #5
							vTaskPriorityDisinheritAfterTimeout((void *)pxQueue->pxMutexHolder,
  402094:	6860      	ldr	r0, [r4, #4]
  402096:	4b11      	ldr	r3, [pc, #68]	; (4020dc <xQueueSemaphoreTake+0x1ec>)
  402098:	4798      	blx	r3
						taskEXIT_CRITICAL();
  40209a:	4b08      	ldr	r3, [pc, #32]	; (4020bc <xQueueSemaphoreTake+0x1cc>)
  40209c:	4798      	blx	r3
				return errQUEUE_EMPTY;
  40209e:	2500      	movs	r5, #0
  4020a0:	e778      	b.n	401f94 <xQueueSemaphoreTake+0xa4>
		uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
  4020a2:	2100      	movs	r1, #0
  4020a4:	e7f6      	b.n	402094 <xQueueSemaphoreTake+0x1a4>
  4020a6:	bf00      	nop
  4020a8:	00402db1 	.word	0x00402db1
  4020ac:	00401275 	.word	0x00401275
  4020b0:	004030ed 	.word	0x004030ed
  4020b4:	00402abd 	.word	0x00402abd
  4020b8:	e000ed04 	.word	0xe000ed04
  4020bc:	004012c1 	.word	0x004012c1
  4020c0:	00402dd1 	.word	0x00402dd1
  4020c4:	00401761 	.word	0x00401761
  4020c8:	0040274d 	.word	0x0040274d
  4020cc:	00401611 	.word	0x00401611
  4020d0:	004025f9 	.word	0x004025f9
  4020d4:	00402b65 	.word	0x00402b65
  4020d8:	00402a35 	.word	0x00402a35
  4020dc:	00402f15 	.word	0x00402f15
  4020e0:	00402b51 	.word	0x00402b51

004020e4 <vQueueDelete>:
{
  4020e4:	b508      	push	{r3, lr}
	configASSERT(pxQueue);
  4020e6:	b950      	cbnz	r0, 4020fe <vQueueDelete+0x1a>
  4020e8:	f04f 0380 	mov.w	r3, #128	; 0x80
  4020ec:	b672      	cpsid	i
  4020ee:	f383 8811 	msr	BASEPRI, r3
  4020f2:	f3bf 8f6f 	isb	sy
  4020f6:	f3bf 8f4f 	dsb	sy
  4020fa:	b662      	cpsie	i
  4020fc:	e7fe      	b.n	4020fc <vQueueDelete+0x18>
		vPortFree(pxQueue);
  4020fe:	4b01      	ldr	r3, [pc, #4]	; (402104 <vQueueDelete+0x20>)
  402100:	4798      	blx	r3
  402102:	bd08      	pop	{r3, pc}
  402104:	004015c5 	.word	0x004015c5

00402108 <vQueueWaitForMessageRestricted>:
{
  402108:	b570      	push	{r4, r5, r6, lr}
  40210a:	4604      	mov	r4, r0
  40210c:	460d      	mov	r5, r1
  40210e:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
  402110:	4b12      	ldr	r3, [pc, #72]	; (40215c <vQueueWaitForMessageRestricted+0x54>)
  402112:	4798      	blx	r3
  402114:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  402118:	b25b      	sxtb	r3, r3
  40211a:	f1b3 3fff 	cmp.w	r3, #4294967295
  40211e:	d00d      	beq.n	40213c <vQueueWaitForMessageRestricted+0x34>
  402120:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  402124:	b25b      	sxtb	r3, r3
  402126:	f1b3 3fff 	cmp.w	r3, #4294967295
  40212a:	d00b      	beq.n	402144 <vQueueWaitForMessageRestricted+0x3c>
  40212c:	4b0c      	ldr	r3, [pc, #48]	; (402160 <vQueueWaitForMessageRestricted+0x58>)
  40212e:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
  402130:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  402132:	b15b      	cbz	r3, 40214c <vQueueWaitForMessageRestricted+0x44>
	prvUnlockQueue(pxQueue);
  402134:	4620      	mov	r0, r4
  402136:	4b0b      	ldr	r3, [pc, #44]	; (402164 <vQueueWaitForMessageRestricted+0x5c>)
  402138:	4798      	blx	r3
  40213a:	bd70      	pop	{r4, r5, r6, pc}
	prvLockQueue(pxQueue);
  40213c:	2300      	movs	r3, #0
  40213e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  402142:	e7ed      	b.n	402120 <vQueueWaitForMessageRestricted+0x18>
  402144:	2300      	movs	r3, #0
  402146:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  40214a:	e7ef      	b.n	40212c <vQueueWaitForMessageRestricted+0x24>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
  40214c:	4632      	mov	r2, r6
  40214e:	4629      	mov	r1, r5
  402150:	f104 0024 	add.w	r0, r4, #36	; 0x24
  402154:	4b04      	ldr	r3, [pc, #16]	; (402168 <vQueueWaitForMessageRestricted+0x60>)
  402156:	4798      	blx	r3
  402158:	e7ec      	b.n	402134 <vQueueWaitForMessageRestricted+0x2c>
  40215a:	bf00      	nop
  40215c:	00401275 	.word	0x00401275
  402160:	004012c1 	.word	0x004012c1
  402164:	00401761 	.word	0x00401761
  402168:	00402a75 	.word	0x00402a75

0040216c <prvTaskIsTaskSuspended>:

	/* Accesses xPendingReadyList so must be called from a critical
	section. */

	/* It does not make sense to check if the calling task is suspended. */
	configASSERT(xTask);
  40216c:	b160      	cbz	r0, 402188 <prvTaskIsTaskSuspended+0x1c>

	/* Is the task being resumed actually in the suspended list? */
	if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) != pdFALSE) {
  40216e:	6941      	ldr	r1, [r0, #20]
  402170:	4a0d      	ldr	r2, [pc, #52]	; (4021a8 <prvTaskIsTaskSuspended+0x3c>)
  402172:	4291      	cmp	r1, r2
  402174:	d113      	bne.n	40219e <prvTaskIsTaskSuspended+0x32>
		/* Has the task already been resumed from within an ISR? */
		if (listIS_CONTAINED_WITHIN(&xPendingReadyList, &(pxTCB->xEventListItem)) == pdFALSE) {
  402176:	6a80      	ldr	r0, [r0, #40]	; 0x28
  402178:	f102 0314 	add.w	r3, r2, #20
  40217c:	4298      	cmp	r0, r3
  40217e:	d010      	beq.n	4021a2 <prvTaskIsTaskSuspended+0x36>
			/* Is it in the suspended list because it is in the	Suspended
			state, or because is is blocked with no timeout? */
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTCB->xEventListItem))
			    != pdFALSE) /*lint !e961.  The cast is only redundant when NULL is used. */
  402180:	fab0 f080 	clz	r0, r0
  402184:	0940      	lsrs	r0, r0, #5
  402186:	4770      	bx	lr
  402188:	f04f 0380 	mov.w	r3, #128	; 0x80
  40218c:	b672      	cpsid	i
  40218e:	f383 8811 	msr	BASEPRI, r3
  402192:	f3bf 8f6f 	isb	sy
  402196:	f3bf 8f4f 	dsb	sy
  40219a:	b662      	cpsie	i
  40219c:	e7fe      	b.n	40219c <prvTaskIsTaskSuspended+0x30>
	BaseType_t         xReturn = pdFALSE;
  40219e:	2000      	movs	r0, #0
  4021a0:	4770      	bx	lr
  4021a2:	2000      	movs	r0, #0
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
  4021a4:	4770      	bx	lr
  4021a6:	bf00      	nop
  4021a8:	20400a34 	.word	0x20400a34

004021ac <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
  4021ac:	4a06      	ldr	r2, [pc, #24]	; (4021c8 <prvIdleTask+0x1c>)
				taskYIELD();
  4021ae:	4807      	ldr	r0, [pc, #28]	; (4021cc <prvIdleTask+0x20>)
  4021b0:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
  4021b4:	6a93      	ldr	r3, [r2, #40]	; 0x28
  4021b6:	2b01      	cmp	r3, #1
  4021b8:	d9fc      	bls.n	4021b4 <prvIdleTask+0x8>
				taskYIELD();
  4021ba:	6001      	str	r1, [r0, #0]
  4021bc:	f3bf 8f4f 	dsb	sy
  4021c0:	f3bf 8f6f 	isb	sy
  4021c4:	e7f6      	b.n	4021b4 <prvIdleTask+0x8>
  4021c6:	bf00      	nop
  4021c8:	20400a34 	.word	0x20400a34
  4021cc:	e000ed04 	.word	0xe000ed04

004021d0 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
  4021d0:	4b09      	ldr	r3, [pc, #36]	; (4021f8 <prvResetNextTaskUnblockTime+0x28>)
  4021d2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  4021d6:	681b      	ldr	r3, [r3, #0]
  4021d8:	b143      	cbz	r3, 4021ec <prvResetNextTaskUnblockTime+0x1c>
	} else {
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
  4021da:	4b07      	ldr	r3, [pc, #28]	; (4021f8 <prvResetNextTaskUnblockTime+0x28>)
  4021dc:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
  4021e0:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
  4021e2:	68d2      	ldr	r2, [r2, #12]
  4021e4:	6852      	ldr	r2, [r2, #4]
  4021e6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  4021ea:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
  4021ec:	f04f 32ff 	mov.w	r2, #4294967295
  4021f0:	4b01      	ldr	r3, [pc, #4]	; (4021f8 <prvResetNextTaskUnblockTime+0x28>)
  4021f2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  4021f6:	4770      	bx	lr
  4021f8:	20400a34 	.word	0x20400a34

004021fc <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
  4021fc:	b570      	push	{r4, r5, r6, lr}
  4021fe:	4604      	mov	r4, r0
  402200:	460e      	mov	r6, r1
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
  402202:	4b19      	ldr	r3, [pc, #100]	; (402268 <prvAddCurrentTaskToDelayedList+0x6c>)
  402204:	f8d3 5094 	ldr.w	r5, [r3, #148]	; 0x94
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
  402208:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
  40220c:	3004      	adds	r0, #4
  40220e:	4b17      	ldr	r3, [pc, #92]	; (40226c <prvAddCurrentTaskToDelayedList+0x70>)
  402210:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
  402212:	f1b4 3fff 	cmp.w	r4, #4294967295
  402216:	d100      	bne.n	40221a <prvAddCurrentTaskToDelayedList+0x1e>
  402218:	b9ae      	cbnz	r6, 402246 <prvAddCurrentTaskToDelayedList+0x4a>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
		} else {
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
  40221a:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
  40221c:	4b12      	ldr	r3, [pc, #72]	; (402268 <prvAddCurrentTaskToDelayedList+0x6c>)
  40221e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  402222:	605c      	str	r4, [r3, #4]

			if (xTimeToWake < xConstTickCount) {
  402224:	42a5      	cmp	r5, r4
  402226:	d815      	bhi.n	402254 <prvAddCurrentTaskToDelayedList+0x58>
				list. */
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
			} else {
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
  402228:	4d0f      	ldr	r5, [pc, #60]	; (402268 <prvAddCurrentTaskToDelayedList+0x6c>)
  40222a:	f8d5 008c 	ldr.w	r0, [r5, #140]	; 0x8c
  40222e:	f8d5 1098 	ldr.w	r1, [r5, #152]	; 0x98
  402232:	3104      	adds	r1, #4
  402234:	4b0e      	ldr	r3, [pc, #56]	; (402270 <prvAddCurrentTaskToDelayedList+0x74>)
  402236:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if (xTimeToWake < xNextTaskUnblockTime) {
  402238:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
  40223c:	429c      	cmp	r4, r3
  40223e:	d201      	bcs.n	402244 <prvAddCurrentTaskToDelayedList+0x48>
					xNextTaskUnblockTime = xTimeToWake;
  402240:	f8c5 4090 	str.w	r4, [r5, #144]	; 0x90
  402244:	bd70      	pop	{r4, r5, r6, pc}
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
  402246:	4808      	ldr	r0, [pc, #32]	; (402268 <prvAddCurrentTaskToDelayedList+0x6c>)
  402248:	f8d0 1098 	ldr.w	r1, [r0, #152]	; 0x98
  40224c:	3104      	adds	r1, #4
  40224e:	4b09      	ldr	r3, [pc, #36]	; (402274 <prvAddCurrentTaskToDelayedList+0x78>)
  402250:	4798      	blx	r3
  402252:	bd70      	pop	{r4, r5, r6, pc}
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
  402254:	4b04      	ldr	r3, [pc, #16]	; (402268 <prvAddCurrentTaskToDelayedList+0x6c>)
  402256:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
  40225a:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
  40225e:	3104      	adds	r1, #4
  402260:	4b03      	ldr	r3, [pc, #12]	; (402270 <prvAddCurrentTaskToDelayedList+0x74>)
  402262:	4798      	blx	r3
  402264:	bd70      	pop	{r4, r5, r6, pc}
  402266:	bf00      	nop
  402268:	20400a34 	.word	0x20400a34
  40226c:	00401171 	.word	0x00401171
  402270:	0040113d 	.word	0x0040113d
  402274:	00401125 	.word	0x00401125

00402278 <xTaskCreate>:
{
  402278:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40227c:	b083      	sub	sp, #12
  40227e:	4683      	mov	fp, r0
  402280:	460d      	mov	r5, r1
  402282:	9301      	str	r3, [sp, #4]
  402284:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
		pxStack = (StackType_t *)pvPortMalloc(
  402288:	0096      	lsls	r6, r2, #2
  40228a:	4630      	mov	r0, r6
  40228c:	4b66      	ldr	r3, [pc, #408]	; (402428 <xTaskCreate+0x1b0>)
  40228e:	4798      	blx	r3
		if (pxStack != NULL) {
  402290:	2800      	cmp	r0, #0
  402292:	f000 8096 	beq.w	4023c2 <xTaskCreate+0x14a>
  402296:	4607      	mov	r7, r0
			pxNewTCB = (TCB_t *)pvPortMalloc(
  402298:	2054      	movs	r0, #84	; 0x54
  40229a:	4b63      	ldr	r3, [pc, #396]	; (402428 <xTaskCreate+0x1b0>)
  40229c:	4798      	blx	r3
			if (pxNewTCB != NULL) {
  40229e:	4604      	mov	r4, r0
  4022a0:	2800      	cmp	r0, #0
  4022a2:	f000 808b 	beq.w	4023bc <xTaskCreate+0x144>
				pxNewTCB->pxStack = pxStack;
  4022a6:	6307      	str	r7, [r0, #48]	; 0x30
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
  4022a8:	4632      	mov	r2, r6
  4022aa:	21a5      	movs	r1, #165	; 0xa5
  4022ac:	4638      	mov	r0, r7
  4022ae:	4b5f      	ldr	r3, [pc, #380]	; (40242c <xTaskCreate+0x1b4>)
  4022b0:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
  4022b2:	3e04      	subs	r6, #4
  4022b4:	6b23      	ldr	r3, [r4, #48]	; 0x30
  4022b6:	441e      	add	r6, r3
		                      & (~(
  4022b8:	f026 0607 	bic.w	r6, r6, #7
		pxNewTCB->pcTaskName[x] = pcName[x];
  4022bc:	782b      	ldrb	r3, [r5, #0]
  4022be:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
		if (pcName[x] == 0x00) {
  4022c2:	782b      	ldrb	r3, [r5, #0]
  4022c4:	b15b      	cbz	r3, 4022de <xTaskCreate+0x66>
  4022c6:	462b      	mov	r3, r5
  4022c8:	f104 0235 	add.w	r2, r4, #53	; 0x35
  4022cc:	1de9      	adds	r1, r5, #7
		pxNewTCB->pcTaskName[x] = pcName[x];
  4022ce:	7858      	ldrb	r0, [r3, #1]
  4022d0:	f802 0b01 	strb.w	r0, [r2], #1
		if (pcName[x] == 0x00) {
  4022d4:	f813 0f01 	ldrb.w	r0, [r3, #1]!
  4022d8:	b108      	cbz	r0, 4022de <xTaskCreate+0x66>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
  4022da:	4299      	cmp	r1, r3
  4022dc:	d1f7      	bne.n	4022ce <xTaskCreate+0x56>
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
  4022de:	2700      	movs	r7, #0
  4022e0:	f884 703b 	strb.w	r7, [r4, #59]	; 0x3b
  4022e4:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  4022e6:	2d04      	cmp	r5, #4
  4022e8:	bf28      	it	cs
  4022ea:	2504      	movcs	r5, #4
	pxNewTCB->uxPriority = uxPriority;
  4022ec:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
  4022ee:	6465      	str	r5, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld  = 0;
  4022f0:	64a7      	str	r7, [r4, #72]	; 0x48
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
  4022f2:	f104 0804 	add.w	r8, r4, #4
  4022f6:	4640      	mov	r0, r8
  4022f8:	f8df 9154 	ldr.w	r9, [pc, #340]	; 402450 <xTaskCreate+0x1d8>
  4022fc:	47c8      	blx	r9
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
  4022fe:	f104 0018 	add.w	r0, r4, #24
  402302:	47c8      	blx	r9
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
  402304:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE(
  402306:	f1c5 0505 	rsb	r5, r5, #5
  40230a:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
  40230c:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
  40230e:	64e7      	str	r7, [r4, #76]	; 0x4c
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
  402310:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
  402314:	9a01      	ldr	r2, [sp, #4]
  402316:	4659      	mov	r1, fp
  402318:	4630      	mov	r0, r6
  40231a:	4b45      	ldr	r3, [pc, #276]	; (402430 <xTaskCreate+0x1b8>)
  40231c:	4798      	blx	r3
  40231e:	6020      	str	r0, [r4, #0]
	if ((void *)pxCreatedTask != NULL) {
  402320:	f1ba 0f00 	cmp.w	sl, #0
  402324:	d001      	beq.n	40232a <xTaskCreate+0xb2>
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
  402326:	f8ca 4000 	str.w	r4, [sl]
	taskENTER_CRITICAL();
  40232a:	4b42      	ldr	r3, [pc, #264]	; (402434 <xTaskCreate+0x1bc>)
  40232c:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
  40232e:	4b42      	ldr	r3, [pc, #264]	; (402438 <xTaskCreate+0x1c0>)
  402330:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
  402334:	3201      	adds	r2, #1
  402336:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		if (pxCurrentTCB == NULL) {
  40233a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  40233e:	2b00      	cmp	r3, #0
  402340:	d042      	beq.n	4023c8 <xTaskCreate+0x150>
			if (xSchedulerRunning == pdFALSE) {
  402342:	4b3d      	ldr	r3, [pc, #244]	; (402438 <xTaskCreate+0x1c0>)
  402344:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
  402348:	b94b      	cbnz	r3, 40235e <xTaskCreate+0xe6>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
  40234a:	4b3b      	ldr	r3, [pc, #236]	; (402438 <xTaskCreate+0x1c0>)
  40234c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  402350:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402352:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  402354:	429a      	cmp	r2, r3
  402356:	d802      	bhi.n	40235e <xTaskCreate+0xe6>
					pxCurrentTCB = pxNewTCB;
  402358:	4b37      	ldr	r3, [pc, #220]	; (402438 <xTaskCreate+0x1c0>)
  40235a:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
		uxTaskNumber++;
  40235e:	4a36      	ldr	r2, [pc, #216]	; (402438 <xTaskCreate+0x1c0>)
  402360:	f8d2 30d0 	ldr.w	r3, [r2, #208]	; 0xd0
  402364:	3301      	adds	r3, #1
  402366:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0
			pxNewTCB->uxTCBNumber = uxTaskNumber;
  40236a:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList(pxNewTCB);
  40236c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  40236e:	f8d2 20d4 	ldr.w	r2, [r2, #212]	; 0xd4
  402372:	4293      	cmp	r3, r2
  402374:	d902      	bls.n	40237c <xTaskCreate+0x104>
  402376:	4a30      	ldr	r2, [pc, #192]	; (402438 <xTaskCreate+0x1c0>)
  402378:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
  40237c:	4d2e      	ldr	r5, [pc, #184]	; (402438 <xTaskCreate+0x1c0>)
  40237e:	f105 0028 	add.w	r0, r5, #40	; 0x28
  402382:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  402386:	4641      	mov	r1, r8
  402388:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  40238c:	4b2b      	ldr	r3, [pc, #172]	; (40243c <xTaskCreate+0x1c4>)
  40238e:	4798      	blx	r3
	taskEXIT_CRITICAL();
  402390:	4b2b      	ldr	r3, [pc, #172]	; (402440 <xTaskCreate+0x1c8>)
  402392:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
  402394:	f8d5 30cc 	ldr.w	r3, [r5, #204]	; 0xcc
  402398:	2b00      	cmp	r3, #0
  40239a:	d03f      	beq.n	40241c <xTaskCreate+0x1a4>
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
  40239c:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
  4023a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  4023a2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  4023a4:	429a      	cmp	r2, r3
  4023a6:	d23d      	bcs.n	402424 <xTaskCreate+0x1ac>
			taskYIELD_IF_USING_PREEMPTION();
  4023a8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4023ac:	4b25      	ldr	r3, [pc, #148]	; (402444 <xTaskCreate+0x1cc>)
  4023ae:	601a      	str	r2, [r3, #0]
  4023b0:	f3bf 8f4f 	dsb	sy
  4023b4:	f3bf 8f6f 	isb	sy
		xReturn = pdPASS;
  4023b8:	2001      	movs	r0, #1
  4023ba:	e030      	b.n	40241e <xTaskCreate+0x1a6>
				vPortFree(pxStack);
  4023bc:	4638      	mov	r0, r7
  4023be:	4b22      	ldr	r3, [pc, #136]	; (402448 <xTaskCreate+0x1d0>)
  4023c0:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  4023c2:	f04f 30ff 	mov.w	r0, #4294967295
  4023c6:	e02a      	b.n	40241e <xTaskCreate+0x1a6>
			pxCurrentTCB = pxNewTCB;
  4023c8:	4b1b      	ldr	r3, [pc, #108]	; (402438 <xTaskCreate+0x1c0>)
  4023ca:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
  4023ce:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
  4023d2:	2b01      	cmp	r3, #1
  4023d4:	d1c3      	bne.n	40235e <xTaskCreate+0xe6>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
  4023d6:	4d18      	ldr	r5, [pc, #96]	; (402438 <xTaskCreate+0x1c0>)
  4023d8:	f105 0028 	add.w	r0, r5, #40	; 0x28
  4023dc:	4e1b      	ldr	r6, [pc, #108]	; (40244c <xTaskCreate+0x1d4>)
  4023de:	47b0      	blx	r6
  4023e0:	f105 003c 	add.w	r0, r5, #60	; 0x3c
  4023e4:	47b0      	blx	r6
  4023e6:	f105 0050 	add.w	r0, r5, #80	; 0x50
  4023ea:	47b0      	blx	r6
  4023ec:	f105 0064 	add.w	r0, r5, #100	; 0x64
  4023f0:	47b0      	blx	r6
  4023f2:	f105 0078 	add.w	r0, r5, #120	; 0x78
  4023f6:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList1);
  4023f8:	f105 09a4 	add.w	r9, r5, #164	; 0xa4
  4023fc:	4648      	mov	r0, r9
  4023fe:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList2);
  402400:	f105 07b8 	add.w	r7, r5, #184	; 0xb8
  402404:	4638      	mov	r0, r7
  402406:	47b0      	blx	r6
	vListInitialise(&xPendingReadyList);
  402408:	f105 0014 	add.w	r0, r5, #20
  40240c:	47b0      	blx	r6
		vListInitialise(&xSuspendedTaskList);
  40240e:	4628      	mov	r0, r5
  402410:	47b0      	blx	r6
	pxDelayedTaskList         = &xDelayedTaskList1;
  402412:	f8c5 908c 	str.w	r9, [r5, #140]	; 0x8c
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  402416:	f8c5 709c 	str.w	r7, [r5, #156]	; 0x9c
  40241a:	e7a0      	b.n	40235e <xTaskCreate+0xe6>
		xReturn = pdPASS;
  40241c:	2001      	movs	r0, #1
}
  40241e:	b003      	add	sp, #12
  402420:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		xReturn = pdPASS;
  402424:	2001      	movs	r0, #1
	return xReturn;
  402426:	e7fa      	b.n	40241e <xTaskCreate+0x1a6>
  402428:	004014f5 	.word	0x004014f5
  40242c:	00403553 	.word	0x00403553
  402430:	0040121d 	.word	0x0040121d
  402434:	00401275 	.word	0x00401275
  402438:	20400a34 	.word	0x20400a34
  40243c:	00401125 	.word	0x00401125
  402440:	004012c1 	.word	0x004012c1
  402444:	e000ed04 	.word	0xe000ed04
  402448:	004015c5 	.word	0x004015c5
  40244c:	00401109 	.word	0x00401109
  402450:	0040111f 	.word	0x0040111f

00402454 <eTaskGetState>:
{
  402454:	b538      	push	{r3, r4, r5, lr}
	configASSERT(pxTCB);
  402456:	b1c8      	cbz	r0, 40248c <eTaskGetState+0x38>
  402458:	4604      	mov	r4, r0
	if (pxTCB == pxCurrentTCB) {
  40245a:	4b18      	ldr	r3, [pc, #96]	; (4024bc <eTaskGetState+0x68>)
  40245c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  402460:	4298      	cmp	r0, r3
  402462:	d024      	beq.n	4024ae <eTaskGetState+0x5a>
		taskENTER_CRITICAL();
  402464:	4b16      	ldr	r3, [pc, #88]	; (4024c0 <eTaskGetState+0x6c>)
  402466:	4798      	blx	r3
			pxStateList = (List_t *)listLIST_ITEM_CONTAINER(&(pxTCB->xStateListItem));
  402468:	6965      	ldr	r5, [r4, #20]
		taskEXIT_CRITICAL();
  40246a:	4b16      	ldr	r3, [pc, #88]	; (4024c4 <eTaskGetState+0x70>)
  40246c:	4798      	blx	r3
		if ((pxStateList == pxDelayedTaskList) || (pxStateList == pxOverflowDelayedTaskList)) {
  40246e:	4b13      	ldr	r3, [pc, #76]	; (4024bc <eTaskGetState+0x68>)
  402470:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  402474:	429d      	cmp	r5, r3
  402476:	d01c      	beq.n	4024b2 <eTaskGetState+0x5e>
  402478:	4b10      	ldr	r3, [pc, #64]	; (4024bc <eTaskGetState+0x68>)
  40247a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
  40247e:	429d      	cmp	r5, r3
  402480:	d019      	beq.n	4024b6 <eTaskGetState+0x62>
		else if (pxStateList == &xSuspendedTaskList) {
  402482:	4b0e      	ldr	r3, [pc, #56]	; (4024bc <eTaskGetState+0x68>)
  402484:	429d      	cmp	r5, r3
  402486:	d00c      	beq.n	4024a2 <eTaskGetState+0x4e>
			eReturn = eReady;
  402488:	2001      	movs	r0, #1
} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
  40248a:	bd38      	pop	{r3, r4, r5, pc}
  40248c:	f04f 0380 	mov.w	r3, #128	; 0x80
  402490:	b672      	cpsid	i
  402492:	f383 8811 	msr	BASEPRI, r3
  402496:	f3bf 8f6f 	isb	sy
  40249a:	f3bf 8f4f 	dsb	sy
  40249e:	b662      	cpsie	i
  4024a0:	e7fe      	b.n	4024a0 <eTaskGetState+0x4c>
			if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL) {
  4024a2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
				eReturn = eBlocked;
  4024a4:	2b00      	cmp	r3, #0
  4024a6:	bf0c      	ite	eq
  4024a8:	2003      	moveq	r0, #3
  4024aa:	2002      	movne	r0, #2
  4024ac:	bd38      	pop	{r3, r4, r5, pc}
		eReturn = eRunning;
  4024ae:	2000      	movs	r0, #0
  4024b0:	bd38      	pop	{r3, r4, r5, pc}
			eReturn = eBlocked;
  4024b2:	2002      	movs	r0, #2
  4024b4:	bd38      	pop	{r3, r4, r5, pc}
  4024b6:	2002      	movs	r0, #2
  4024b8:	bd38      	pop	{r3, r4, r5, pc}
  4024ba:	bf00      	nop
  4024bc:	20400a34 	.word	0x20400a34
  4024c0:	00401275 	.word	0x00401275
  4024c4:	004012c1 	.word	0x004012c1

004024c8 <vTaskResume>:
	configASSERT(xTaskToResume);
  4024c8:	b178      	cbz	r0, 4024ea <vTaskResume+0x22>
{
  4024ca:	b570      	push	{r4, r5, r6, lr}
  4024cc:	4604      	mov	r4, r0
	if ((pxTCB != NULL) && (pxTCB != pxCurrentTCB)) {
  4024ce:	4b1f      	ldr	r3, [pc, #124]	; (40254c <vTaskResume+0x84>)
  4024d0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  4024d4:	4298      	cmp	r0, r3
  4024d6:	d007      	beq.n	4024e8 <vTaskResume+0x20>
		taskENTER_CRITICAL();
  4024d8:	4b1d      	ldr	r3, [pc, #116]	; (402550 <vTaskResume+0x88>)
  4024da:	4798      	blx	r3
			if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE) {
  4024dc:	4620      	mov	r0, r4
  4024de:	4b1d      	ldr	r3, [pc, #116]	; (402554 <vTaskResume+0x8c>)
  4024e0:	4798      	blx	r3
  4024e2:	b968      	cbnz	r0, 402500 <vTaskResume+0x38>
		taskEXIT_CRITICAL();
  4024e4:	4b1c      	ldr	r3, [pc, #112]	; (402558 <vTaskResume+0x90>)
  4024e6:	4798      	blx	r3
  4024e8:	bd70      	pop	{r4, r5, r6, pc}
  4024ea:	f04f 0380 	mov.w	r3, #128	; 0x80
  4024ee:	b672      	cpsid	i
  4024f0:	f383 8811 	msr	BASEPRI, r3
  4024f4:	f3bf 8f6f 	isb	sy
  4024f8:	f3bf 8f4f 	dsb	sy
  4024fc:	b662      	cpsie	i
  4024fe:	e7fe      	b.n	4024fe <vTaskResume+0x36>
				(void)uxListRemove(&(pxTCB->xStateListItem));
  402500:	1d26      	adds	r6, r4, #4
  402502:	4630      	mov	r0, r6
  402504:	4b15      	ldr	r3, [pc, #84]	; (40255c <vTaskResume+0x94>)
  402506:	4798      	blx	r3
				prvAddTaskToReadyList(pxTCB);
  402508:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  40250a:	4a10      	ldr	r2, [pc, #64]	; (40254c <vTaskResume+0x84>)
  40250c:	f8d2 20d4 	ldr.w	r2, [r2, #212]	; 0xd4
  402510:	4293      	cmp	r3, r2
  402512:	d902      	bls.n	40251a <vTaskResume+0x52>
  402514:	4a0d      	ldr	r2, [pc, #52]	; (40254c <vTaskResume+0x84>)
  402516:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
  40251a:	4d0c      	ldr	r5, [pc, #48]	; (40254c <vTaskResume+0x84>)
  40251c:	f105 0028 	add.w	r0, r5, #40	; 0x28
  402520:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  402524:	4631      	mov	r1, r6
  402526:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  40252a:	4b0d      	ldr	r3, [pc, #52]	; (402560 <vTaskResume+0x98>)
  40252c:	4798      	blx	r3
				if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
  40252e:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
  402532:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  402534:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402536:	429a      	cmp	r2, r3
  402538:	d3d4      	bcc.n	4024e4 <vTaskResume+0x1c>
					taskYIELD_IF_USING_PREEMPTION();
  40253a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40253e:	4b09      	ldr	r3, [pc, #36]	; (402564 <vTaskResume+0x9c>)
  402540:	601a      	str	r2, [r3, #0]
  402542:	f3bf 8f4f 	dsb	sy
  402546:	f3bf 8f6f 	isb	sy
  40254a:	e7cb      	b.n	4024e4 <vTaskResume+0x1c>
  40254c:	20400a34 	.word	0x20400a34
  402550:	00401275 	.word	0x00401275
  402554:	0040216d 	.word	0x0040216d
  402558:	004012c1 	.word	0x004012c1
  40255c:	00401171 	.word	0x00401171
  402560:	00401125 	.word	0x00401125
  402564:	e000ed04 	.word	0xe000ed04

00402568 <vTaskStartScheduler>:
{
  402568:	b510      	push	{r4, lr}
  40256a:	b082      	sub	sp, #8
		xReturn = xTaskCreate(prvIdleTask,
  40256c:	4b1b      	ldr	r3, [pc, #108]	; (4025dc <vTaskStartScheduler+0x74>)
  40256e:	9301      	str	r3, [sp, #4]
  402570:	2300      	movs	r3, #0
  402572:	9300      	str	r3, [sp, #0]
  402574:	2240      	movs	r2, #64	; 0x40
  402576:	491a      	ldr	r1, [pc, #104]	; (4025e0 <vTaskStartScheduler+0x78>)
  402578:	481a      	ldr	r0, [pc, #104]	; (4025e4 <vTaskStartScheduler+0x7c>)
  40257a:	4c1b      	ldr	r4, [pc, #108]	; (4025e8 <vTaskStartScheduler+0x80>)
  40257c:	47a0      	blx	r4
		if (xReturn == pdPASS) {
  40257e:	2801      	cmp	r0, #1
  402580:	d004      	beq.n	40258c <vTaskStartScheduler+0x24>
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
  402582:	f1b0 3fff 	cmp.w	r0, #4294967295
  402586:	d01d      	beq.n	4025c4 <vTaskStartScheduler+0x5c>
}
  402588:	b002      	add	sp, #8
  40258a:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
  40258c:	4b17      	ldr	r3, [pc, #92]	; (4025ec <vTaskStartScheduler+0x84>)
  40258e:	4798      	blx	r3
	if (xReturn == pdPASS) {
  402590:	2801      	cmp	r0, #1
  402592:	d1f6      	bne.n	402582 <vTaskStartScheduler+0x1a>
  402594:	f04f 0380 	mov.w	r3, #128	; 0x80
  402598:	b672      	cpsid	i
  40259a:	f383 8811 	msr	BASEPRI, r3
  40259e:	f3bf 8f6f 	isb	sy
  4025a2:	f3bf 8f4f 	dsb	sy
  4025a6:	b662      	cpsie	i
		xNextTaskUnblockTime = portMAX_DELAY;
  4025a8:	4b11      	ldr	r3, [pc, #68]	; (4025f0 <vTaskStartScheduler+0x88>)
  4025aa:	f04f 32ff 	mov.w	r2, #4294967295
  4025ae:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
		xSchedulerRunning    = pdTRUE;
  4025b2:	2201      	movs	r2, #1
  4025b4:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
		xTickCount           = (TickType_t)0U;
  4025b8:	2200      	movs	r2, #0
  4025ba:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
		if (xPortStartScheduler() != pdFALSE) {
  4025be:	4b0d      	ldr	r3, [pc, #52]	; (4025f4 <vTaskStartScheduler+0x8c>)
  4025c0:	4798      	blx	r3
  4025c2:	e7e1      	b.n	402588 <vTaskStartScheduler+0x20>
  4025c4:	f04f 0380 	mov.w	r3, #128	; 0x80
  4025c8:	b672      	cpsid	i
  4025ca:	f383 8811 	msr	BASEPRI, r3
  4025ce:	f3bf 8f6f 	isb	sy
  4025d2:	f3bf 8f4f 	dsb	sy
  4025d6:	b662      	cpsie	i
  4025d8:	e7fe      	b.n	4025d8 <vTaskStartScheduler+0x70>
  4025da:	bf00      	nop
  4025dc:	20400b10 	.word	0x20400b10
  4025e0:	004037c8 	.word	0x004037c8
  4025e4:	004021ad 	.word	0x004021ad
  4025e8:	00402279 	.word	0x00402279
  4025ec:	004031a1 	.word	0x004031a1
  4025f0:	20400a34 	.word	0x20400a34
  4025f4:	004013b1 	.word	0x004013b1

004025f8 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
  4025f8:	4a03      	ldr	r2, [pc, #12]	; (402608 <vTaskSuspendAll+0x10>)
  4025fa:	f8d2 30d8 	ldr.w	r3, [r2, #216]	; 0xd8
  4025fe:	3301      	adds	r3, #1
  402600:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
  402604:	4770      	bx	lr
  402606:	bf00      	nop
  402608:	20400a34 	.word	0x20400a34

0040260c <xTaskGetTickCount>:
		xTicks = xTickCount;
  40260c:	4b01      	ldr	r3, [pc, #4]	; (402614 <xTaskGetTickCount+0x8>)
  40260e:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
}
  402612:	4770      	bx	lr
  402614:	20400a34 	.word	0x20400a34

00402618 <uxTaskGetNumberOfTasks>:
	return uxCurrentNumberOfTasks;
  402618:	4b01      	ldr	r3, [pc, #4]	; (402620 <uxTaskGetNumberOfTasks+0x8>)
  40261a:	f8d3 00a0 	ldr.w	r0, [r3, #160]	; 0xa0
}
  40261e:	4770      	bx	lr
  402620:	20400a34 	.word	0x20400a34

00402624 <xTaskIncrementTick>:
{
  402624:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
  402628:	4b44      	ldr	r3, [pc, #272]	; (40273c <xTaskIncrementTick+0x118>)
  40262a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  40262e:	2b00      	cmp	r3, #0
  402630:	d174      	bne.n	40271c <xTaskIncrementTick+0xf8>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
  402632:	4b42      	ldr	r3, [pc, #264]	; (40273c <xTaskIncrementTick+0x118>)
  402634:	f8d3 6094 	ldr.w	r6, [r3, #148]	; 0x94
  402638:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
  40263a:	f8c3 6094 	str.w	r6, [r3, #148]	; 0x94
		if (xConstTickCount
  40263e:	b9f6      	cbnz	r6, 40267e <xTaskIncrementTick+0x5a>
			taskSWITCH_DELAYED_LISTS();
  402640:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  402644:	681b      	ldr	r3, [r3, #0]
  402646:	b153      	cbz	r3, 40265e <xTaskIncrementTick+0x3a>
  402648:	f04f 0380 	mov.w	r3, #128	; 0x80
  40264c:	b672      	cpsid	i
  40264e:	f383 8811 	msr	BASEPRI, r3
  402652:	f3bf 8f6f 	isb	sy
  402656:	f3bf 8f4f 	dsb	sy
  40265a:	b662      	cpsie	i
  40265c:	e7fe      	b.n	40265c <xTaskIncrementTick+0x38>
  40265e:	4b37      	ldr	r3, [pc, #220]	; (40273c <xTaskIncrementTick+0x118>)
  402660:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
  402664:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
  402668:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
  40266c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  402670:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
  402674:	3201      	adds	r2, #1
  402676:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
  40267a:	4b31      	ldr	r3, [pc, #196]	; (402740 <xTaskIncrementTick+0x11c>)
  40267c:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
  40267e:	4b2f      	ldr	r3, [pc, #188]	; (40273c <xTaskIncrementTick+0x118>)
  402680:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  402684:	429e      	cmp	r6, r3
  402686:	d20d      	bcs.n	4026a4 <xTaskIncrementTick+0x80>
	BaseType_t xSwitchRequired = pdFALSE;
  402688:	2400      	movs	r4, #0
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
  40268a:	4b2c      	ldr	r3, [pc, #176]	; (40273c <xTaskIncrementTick+0x118>)
  40268c:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
  402690:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  402692:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  402696:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  40269a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
				xSwitchRequired = pdTRUE;
  40269c:	2b02      	cmp	r3, #2
  40269e:	bf28      	it	cs
  4026a0:	2401      	movcs	r4, #1
  4026a2:	e042      	b.n	40272a <xTaskIncrementTick+0x106>
  4026a4:	2400      	movs	r4, #0
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
  4026a6:	4d25      	ldr	r5, [pc, #148]	; (40273c <xTaskIncrementTick+0x118>)
					(void)uxListRemove(&(pxTCB->xStateListItem));
  4026a8:	f8df 809c 	ldr.w	r8, [pc, #156]	; 402748 <xTaskIncrementTick+0x124>
					prvAddTaskToReadyList(pxTCB);
  4026ac:	f105 0a28 	add.w	sl, r5, #40	; 0x28
  4026b0:	e017      	b.n	4026e2 <xTaskIncrementTick+0xbe>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  4026b2:	f04f 32ff 	mov.w	r2, #4294967295
  4026b6:	4b21      	ldr	r3, [pc, #132]	; (40273c <xTaskIncrementTick+0x118>)
  4026b8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
					break;
  4026bc:	e7e5      	b.n	40268a <xTaskIncrementTick+0x66>
						xNextTaskUnblockTime = xItemValue;
  4026be:	4a1f      	ldr	r2, [pc, #124]	; (40273c <xTaskIncrementTick+0x118>)
  4026c0:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
						break;
  4026c4:	e7e1      	b.n	40268a <xTaskIncrementTick+0x66>
					prvAddTaskToReadyList(pxTCB);
  4026c6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4026ca:	4649      	mov	r1, r9
  4026cc:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
  4026d0:	4b1c      	ldr	r3, [pc, #112]	; (402744 <xTaskIncrementTick+0x120>)
  4026d2:	4798      	blx	r3
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
  4026d4:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
  4026d8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  4026da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
  4026dc:	429a      	cmp	r2, r3
  4026de:	bf28      	it	cs
  4026e0:	2401      	movcs	r4, #1
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
  4026e2:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
  4026e6:	681b      	ldr	r3, [r3, #0]
  4026e8:	2b00      	cmp	r3, #0
  4026ea:	d0e2      	beq.n	4026b2 <xTaskIncrementTick+0x8e>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
  4026ec:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
  4026f0:	68db      	ldr	r3, [r3, #12]
  4026f2:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
  4026f4:	687b      	ldr	r3, [r7, #4]
					if (xConstTickCount < xItemValue) {
  4026f6:	429e      	cmp	r6, r3
  4026f8:	d3e1      	bcc.n	4026be <xTaskIncrementTick+0x9a>
					(void)uxListRemove(&(pxTCB->xStateListItem));
  4026fa:	f107 0904 	add.w	r9, r7, #4
  4026fe:	4648      	mov	r0, r9
  402700:	47c0      	blx	r8
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
  402702:	6abb      	ldr	r3, [r7, #40]	; 0x28
  402704:	b113      	cbz	r3, 40270c <xTaskIncrementTick+0xe8>
						(void)uxListRemove(&(pxTCB->xEventListItem));
  402706:	f107 0018 	add.w	r0, r7, #24
  40270a:	47c0      	blx	r8
					prvAddTaskToReadyList(pxTCB);
  40270c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  40270e:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
  402712:	4298      	cmp	r0, r3
  402714:	d9d7      	bls.n	4026c6 <xTaskIncrementTick+0xa2>
  402716:	f8c5 00d4 	str.w	r0, [r5, #212]	; 0xd4
  40271a:	e7d4      	b.n	4026c6 <xTaskIncrementTick+0xa2>
		++uxPendedTicks;
  40271c:	4a07      	ldr	r2, [pc, #28]	; (40273c <xTaskIncrementTick+0x118>)
  40271e:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
  402722:	3301      	adds	r3, #1
  402724:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
	BaseType_t xSwitchRequired = pdFALSE;
  402728:	2400      	movs	r4, #0
		if (xYieldPending != pdFALSE) {
  40272a:	4b04      	ldr	r3, [pc, #16]	; (40273c <xTaskIncrementTick+0x118>)
  40272c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
			xSwitchRequired = pdTRUE;
  402730:	2b00      	cmp	r3, #0
}
  402732:	bf0c      	ite	eq
  402734:	4620      	moveq	r0, r4
  402736:	2001      	movne	r0, #1
  402738:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40273c:	20400a34 	.word	0x20400a34
  402740:	004021d1 	.word	0x004021d1
  402744:	00401125 	.word	0x00401125
  402748:	00401171 	.word	0x00401171

0040274c <xTaskResumeAll>:
	configASSERT(uxSchedulerSuspended);
  40274c:	4b3b      	ldr	r3, [pc, #236]	; (40283c <xTaskResumeAll+0xf0>)
  40274e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  402752:	b953      	cbnz	r3, 40276a <xTaskResumeAll+0x1e>
  402754:	f04f 0380 	mov.w	r3, #128	; 0x80
  402758:	b672      	cpsid	i
  40275a:	f383 8811 	msr	BASEPRI, r3
  40275e:	f3bf 8f6f 	isb	sy
  402762:	f3bf 8f4f 	dsb	sy
  402766:	b662      	cpsie	i
  402768:	e7fe      	b.n	402768 <xTaskResumeAll+0x1c>
{
  40276a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	taskENTER_CRITICAL();
  40276e:	4b34      	ldr	r3, [pc, #208]	; (402840 <xTaskResumeAll+0xf4>)
  402770:	4798      	blx	r3
		--uxSchedulerSuspended;
  402772:	4b32      	ldr	r3, [pc, #200]	; (40283c <xTaskResumeAll+0xf0>)
  402774:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
  402778:	3a01      	subs	r2, #1
  40277a:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
  40277e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  402782:	2b00      	cmp	r3, #0
  402784:	d155      	bne.n	402832 <xTaskResumeAll+0xe6>
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
  402786:	4b2d      	ldr	r3, [pc, #180]	; (40283c <xTaskResumeAll+0xf0>)
  402788:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
  40278c:	b92b      	cbnz	r3, 40279a <xTaskResumeAll+0x4e>
	BaseType_t xAlreadyYielded = pdFALSE;
  40278e:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
  402790:	4b2c      	ldr	r3, [pc, #176]	; (402844 <xTaskResumeAll+0xf8>)
  402792:	4798      	blx	r3
}
  402794:	4620      	mov	r0, r4
  402796:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40279a:	2500      	movs	r5, #0
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
  40279c:	4c27      	ldr	r4, [pc, #156]	; (40283c <xTaskResumeAll+0xf0>)
					(void)uxListRemove(&(pxTCB->xEventListItem));
  40279e:	4e2a      	ldr	r6, [pc, #168]	; (402848 <xTaskResumeAll+0xfc>)
					prvAddTaskToReadyList(pxTCB);
  4027a0:	f104 0828 	add.w	r8, r4, #40	; 0x28
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
  4027a4:	6963      	ldr	r3, [r4, #20]
  4027a6:	b1fb      	cbz	r3, 4027e8 <xTaskResumeAll+0x9c>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
  4027a8:	6a23      	ldr	r3, [r4, #32]
  4027aa:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
  4027ac:	f105 0018 	add.w	r0, r5, #24
  4027b0:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xStateListItem));
  4027b2:	1d2f      	adds	r7, r5, #4
  4027b4:	4638      	mov	r0, r7
  4027b6:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
  4027b8:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
  4027ba:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
  4027be:	4298      	cmp	r0, r3
  4027c0:	d901      	bls.n	4027c6 <xTaskResumeAll+0x7a>
  4027c2:	f8c4 00d4 	str.w	r0, [r4, #212]	; 0xd4
  4027c6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4027ca:	4639      	mov	r1, r7
  4027cc:	eb08 0080 	add.w	r0, r8, r0, lsl #2
  4027d0:	4b1e      	ldr	r3, [pc, #120]	; (40284c <xTaskResumeAll+0x100>)
  4027d2:	4798      	blx	r3
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
  4027d4:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
  4027d8:	6aea      	ldr	r2, [r5, #44]	; 0x2c
  4027da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4027dc:	429a      	cmp	r2, r3
  4027de:	d3e1      	bcc.n	4027a4 <xTaskResumeAll+0x58>
						xYieldPending = pdTRUE;
  4027e0:	2301      	movs	r3, #1
  4027e2:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
  4027e6:	e7dd      	b.n	4027a4 <xTaskResumeAll+0x58>
				if (pxTCB != NULL) {
  4027e8:	b10d      	cbz	r5, 4027ee <xTaskResumeAll+0xa2>
					prvResetNextTaskUnblockTime();
  4027ea:	4b19      	ldr	r3, [pc, #100]	; (402850 <xTaskResumeAll+0x104>)
  4027ec:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
  4027ee:	4b13      	ldr	r3, [pc, #76]	; (40283c <xTaskResumeAll+0xf0>)
  4027f0:	f8d3 40e4 	ldr.w	r4, [r3, #228]	; 0xe4
					if (uxPendedCounts > (UBaseType_t)0U) {
  4027f4:	b17c      	cbz	r4, 402816 <xTaskResumeAll+0xca>
							if (xTaskIncrementTick() != pdFALSE) {
  4027f6:	4f17      	ldr	r7, [pc, #92]	; (402854 <xTaskResumeAll+0x108>)
								xYieldPending = pdTRUE;
  4027f8:	461e      	mov	r6, r3
  4027fa:	2501      	movs	r5, #1
  4027fc:	e001      	b.n	402802 <xTaskResumeAll+0xb6>
						} while (uxPendedCounts > (UBaseType_t)0U);
  4027fe:	3c01      	subs	r4, #1
  402800:	d005      	beq.n	40280e <xTaskResumeAll+0xc2>
							if (xTaskIncrementTick() != pdFALSE) {
  402802:	47b8      	blx	r7
  402804:	2800      	cmp	r0, #0
  402806:	d0fa      	beq.n	4027fe <xTaskResumeAll+0xb2>
								xYieldPending = pdTRUE;
  402808:	f8c6 50e8 	str.w	r5, [r6, #232]	; 0xe8
  40280c:	e7f7      	b.n	4027fe <xTaskResumeAll+0xb2>
						uxPendedTicks = 0;
  40280e:	2200      	movs	r2, #0
  402810:	4b0a      	ldr	r3, [pc, #40]	; (40283c <xTaskResumeAll+0xf0>)
  402812:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
				if (xYieldPending != pdFALSE) {
  402816:	4b09      	ldr	r3, [pc, #36]	; (40283c <xTaskResumeAll+0xf0>)
  402818:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
  40281c:	b15b      	cbz	r3, 402836 <xTaskResumeAll+0xea>
					taskYIELD_IF_USING_PREEMPTION();
  40281e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402822:	4b0d      	ldr	r3, [pc, #52]	; (402858 <xTaskResumeAll+0x10c>)
  402824:	601a      	str	r2, [r3, #0]
  402826:	f3bf 8f4f 	dsb	sy
  40282a:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
  40282e:	2401      	movs	r4, #1
  402830:	e7ae      	b.n	402790 <xTaskResumeAll+0x44>
	BaseType_t xAlreadyYielded = pdFALSE;
  402832:	2400      	movs	r4, #0
  402834:	e7ac      	b.n	402790 <xTaskResumeAll+0x44>
  402836:	2400      	movs	r4, #0
  402838:	e7aa      	b.n	402790 <xTaskResumeAll+0x44>
  40283a:	bf00      	nop
  40283c:	20400a34 	.word	0x20400a34
  402840:	00401275 	.word	0x00401275
  402844:	004012c1 	.word	0x004012c1
  402848:	00401171 	.word	0x00401171
  40284c:	00401125 	.word	0x00401125
  402850:	004021d1 	.word	0x004021d1
  402854:	00402625 	.word	0x00402625
  402858:	e000ed04 	.word	0xe000ed04

0040285c <vTaskDelay>:
{
  40285c:	b510      	push	{r4, lr}
	if (xTicksToDelay > (TickType_t)0U) {
  40285e:	b1c0      	cbz	r0, 402892 <vTaskDelay+0x36>
  402860:	4604      	mov	r4, r0
		configASSERT(uxSchedulerSuspended == 0);
  402862:	4b10      	ldr	r3, [pc, #64]	; (4028a4 <vTaskDelay+0x48>)
  402864:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  402868:	b153      	cbz	r3, 402880 <vTaskDelay+0x24>
  40286a:	f04f 0380 	mov.w	r3, #128	; 0x80
  40286e:	b672      	cpsid	i
  402870:	f383 8811 	msr	BASEPRI, r3
  402874:	f3bf 8f6f 	isb	sy
  402878:	f3bf 8f4f 	dsb	sy
  40287c:	b662      	cpsie	i
  40287e:	e7fe      	b.n	40287e <vTaskDelay+0x22>
		vTaskSuspendAll();
  402880:	4b09      	ldr	r3, [pc, #36]	; (4028a8 <vTaskDelay+0x4c>)
  402882:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
  402884:	2100      	movs	r1, #0
  402886:	4620      	mov	r0, r4
  402888:	4b08      	ldr	r3, [pc, #32]	; (4028ac <vTaskDelay+0x50>)
  40288a:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
  40288c:	4b08      	ldr	r3, [pc, #32]	; (4028b0 <vTaskDelay+0x54>)
  40288e:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
  402890:	b938      	cbnz	r0, 4028a2 <vTaskDelay+0x46>
		portYIELD_WITHIN_API();
  402892:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402896:	4b07      	ldr	r3, [pc, #28]	; (4028b4 <vTaskDelay+0x58>)
  402898:	601a      	str	r2, [r3, #0]
  40289a:	f3bf 8f4f 	dsb	sy
  40289e:	f3bf 8f6f 	isb	sy
  4028a2:	bd10      	pop	{r4, pc}
  4028a4:	20400a34 	.word	0x20400a34
  4028a8:	004025f9 	.word	0x004025f9
  4028ac:	004021fd 	.word	0x004021fd
  4028b0:	0040274d 	.word	0x0040274d
  4028b4:	e000ed04 	.word	0xe000ed04

004028b8 <vTaskSwitchContext>:
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
  4028b8:	4b26      	ldr	r3, [pc, #152]	; (402954 <vTaskSwitchContext+0x9c>)
  4028ba:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  4028be:	bb0b      	cbnz	r3, 402904 <vTaskSwitchContext+0x4c>
		xYieldPending = pdFALSE;
  4028c0:	4a24      	ldr	r2, [pc, #144]	; (402954 <vTaskSwitchContext+0x9c>)
  4028c2:	2300      	movs	r3, #0
  4028c4:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
		taskSELECT_HIGHEST_PRIORITY_TASK();
  4028c8:	f8d2 30d4 	ldr.w	r3, [r2, #212]	; 0xd4
  4028cc:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  4028d0:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  4028d4:	6a92      	ldr	r2, [r2, #40]	; 0x28
  4028d6:	b9d2      	cbnz	r2, 40290e <vTaskSwitchContext+0x56>
  4028d8:	b14b      	cbz	r3, 4028ee <vTaskSwitchContext+0x36>
  4028da:	491e      	ldr	r1, [pc, #120]	; (402954 <vTaskSwitchContext+0x9c>)
  4028dc:	3b01      	subs	r3, #1
  4028de:	eb03 0283 	add.w	r2, r3, r3, lsl #2
  4028e2:	eb01 0282 	add.w	r2, r1, r2, lsl #2
  4028e6:	6a92      	ldr	r2, [r2, #40]	; 0x28
  4028e8:	b98a      	cbnz	r2, 40290e <vTaskSwitchContext+0x56>
  4028ea:	2b00      	cmp	r3, #0
  4028ec:	d1f6      	bne.n	4028dc <vTaskSwitchContext+0x24>
  4028ee:	f04f 0380 	mov.w	r3, #128	; 0x80
  4028f2:	b672      	cpsid	i
  4028f4:	f383 8811 	msr	BASEPRI, r3
  4028f8:	f3bf 8f6f 	isb	sy
  4028fc:	f3bf 8f4f 	dsb	sy
  402900:	b662      	cpsie	i
  402902:	e7fe      	b.n	402902 <vTaskSwitchContext+0x4a>
		xYieldPending = pdTRUE;
  402904:	2201      	movs	r2, #1
  402906:	4b13      	ldr	r3, [pc, #76]	; (402954 <vTaskSwitchContext+0x9c>)
  402908:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
  40290c:	4770      	bx	lr
{
  40290e:	b410      	push	{r4}
		taskSELECT_HIGHEST_PRIORITY_TASK();
  402910:	4a10      	ldr	r2, [pc, #64]	; (402954 <vTaskSwitchContext+0x9c>)
  402912:	0099      	lsls	r1, r3, #2
  402914:	18c8      	adds	r0, r1, r3
  402916:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  40291a:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
  40291c:	6864      	ldr	r4, [r4, #4]
  40291e:	62c4      	str	r4, [r0, #44]	; 0x2c
  402920:	4419      	add	r1, r3
  402922:	4602      	mov	r2, r0
  402924:	3230      	adds	r2, #48	; 0x30
  402926:	4294      	cmp	r4, r2
  402928:	d00d      	beq.n	402946 <vTaskSwitchContext+0x8e>
  40292a:	4a0a      	ldr	r2, [pc, #40]	; (402954 <vTaskSwitchContext+0x9c>)
  40292c:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  402930:	eb02 0181 	add.w	r1, r2, r1, lsl #2
  402934:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  402936:	68c9      	ldr	r1, [r1, #12]
  402938:	f8c2 1098 	str.w	r1, [r2, #152]	; 0x98
  40293c:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
}
  402940:	f85d 4b04 	ldr.w	r4, [sp], #4
  402944:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK();
  402946:	6860      	ldr	r0, [r4, #4]
  402948:	4a02      	ldr	r2, [pc, #8]	; (402954 <vTaskSwitchContext+0x9c>)
  40294a:	eb02 0281 	add.w	r2, r2, r1, lsl #2
  40294e:	62d0      	str	r0, [r2, #44]	; 0x2c
  402950:	e7eb      	b.n	40292a <vTaskSwitchContext+0x72>
  402952:	bf00      	nop
  402954:	20400a34 	.word	0x20400a34

00402958 <vTaskSuspend>:
{
  402958:	b538      	push	{r3, r4, r5, lr}
  40295a:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
  40295c:	4b2d      	ldr	r3, [pc, #180]	; (402a14 <vTaskSuspend+0xbc>)
  40295e:	4798      	blx	r3
		pxTCB = prvGetTCBFromHandle(xTaskToSuspend);
  402960:	b1f4      	cbz	r4, 4029a0 <vTaskSuspend+0x48>
		if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
  402962:	1d25      	adds	r5, r4, #4
  402964:	4628      	mov	r0, r5
  402966:	4b2c      	ldr	r3, [pc, #176]	; (402a18 <vTaskSuspend+0xc0>)
  402968:	4798      	blx	r3
		if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
  40296a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  40296c:	b11b      	cbz	r3, 402976 <vTaskSuspend+0x1e>
			(void)uxListRemove(&(pxTCB->xEventListItem));
  40296e:	f104 0018 	add.w	r0, r4, #24
  402972:	4b29      	ldr	r3, [pc, #164]	; (402a18 <vTaskSuspend+0xc0>)
  402974:	4798      	blx	r3
		vListInsertEnd(&xSuspendedTaskList, &(pxTCB->xStateListItem));
  402976:	4629      	mov	r1, r5
  402978:	4828      	ldr	r0, [pc, #160]	; (402a1c <vTaskSuspend+0xc4>)
  40297a:	4b29      	ldr	r3, [pc, #164]	; (402a20 <vTaskSuspend+0xc8>)
  40297c:	4798      	blx	r3
			if (pxTCB->ucNotifyState == taskWAITING_NOTIFICATION) {
  40297e:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
  402982:	b2db      	uxtb	r3, r3
  402984:	2b01      	cmp	r3, #1
  402986:	d00f      	beq.n	4029a8 <vTaskSuspend+0x50>
	taskEXIT_CRITICAL();
  402988:	4b26      	ldr	r3, [pc, #152]	; (402a24 <vTaskSuspend+0xcc>)
  40298a:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
  40298c:	4b23      	ldr	r3, [pc, #140]	; (402a1c <vTaskSuspend+0xc4>)
  40298e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
  402992:	b96b      	cbnz	r3, 4029b0 <vTaskSuspend+0x58>
	if (pxTCB == pxCurrentTCB) {
  402994:	4b21      	ldr	r3, [pc, #132]	; (402a1c <vTaskSuspend+0xc4>)
  402996:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  40299a:	429c      	cmp	r4, r3
  40299c:	d00f      	beq.n	4029be <vTaskSuspend+0x66>
  40299e:	bd38      	pop	{r3, r4, r5, pc}
		pxTCB = prvGetTCBFromHandle(xTaskToSuspend);
  4029a0:	4b1e      	ldr	r3, [pc, #120]	; (402a1c <vTaskSuspend+0xc4>)
  4029a2:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
  4029a6:	e7dc      	b.n	402962 <vTaskSuspend+0xa>
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  4029a8:	2300      	movs	r3, #0
  4029aa:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  4029ae:	e7eb      	b.n	402988 <vTaskSuspend+0x30>
		taskENTER_CRITICAL();
  4029b0:	4b18      	ldr	r3, [pc, #96]	; (402a14 <vTaskSuspend+0xbc>)
  4029b2:	4798      	blx	r3
			prvResetNextTaskUnblockTime();
  4029b4:	4b1c      	ldr	r3, [pc, #112]	; (402a28 <vTaskSuspend+0xd0>)
  4029b6:	4798      	blx	r3
		taskEXIT_CRITICAL();
  4029b8:	4b1a      	ldr	r3, [pc, #104]	; (402a24 <vTaskSuspend+0xcc>)
  4029ba:	4798      	blx	r3
  4029bc:	e7ea      	b.n	402994 <vTaskSuspend+0x3c>
		if (xSchedulerRunning != pdFALSE) {
  4029be:	4b17      	ldr	r3, [pc, #92]	; (402a1c <vTaskSuspend+0xc4>)
  4029c0:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
  4029c4:	b1bb      	cbz	r3, 4029f6 <vTaskSuspend+0x9e>
			configASSERT(uxSchedulerSuspended == 0);
  4029c6:	4b15      	ldr	r3, [pc, #84]	; (402a1c <vTaskSuspend+0xc4>)
  4029c8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  4029cc:	b153      	cbz	r3, 4029e4 <vTaskSuspend+0x8c>
  4029ce:	f04f 0380 	mov.w	r3, #128	; 0x80
  4029d2:	b672      	cpsid	i
  4029d4:	f383 8811 	msr	BASEPRI, r3
  4029d8:	f3bf 8f6f 	isb	sy
  4029dc:	f3bf 8f4f 	dsb	sy
  4029e0:	b662      	cpsie	i
  4029e2:	e7fe      	b.n	4029e2 <vTaskSuspend+0x8a>
			portYIELD_WITHIN_API();
  4029e4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4029e8:	4b10      	ldr	r3, [pc, #64]	; (402a2c <vTaskSuspend+0xd4>)
  4029ea:	601a      	str	r2, [r3, #0]
  4029ec:	f3bf 8f4f 	dsb	sy
  4029f0:	f3bf 8f6f 	isb	sy
  4029f4:	bd38      	pop	{r3, r4, r5, pc}
			if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) == uxCurrentNumberOfTasks) {
  4029f6:	4b09      	ldr	r3, [pc, #36]	; (402a1c <vTaskSuspend+0xc4>)
  4029f8:	681a      	ldr	r2, [r3, #0]
  4029fa:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
  4029fe:	429a      	cmp	r2, r3
  402a00:	d104      	bne.n	402a0c <vTaskSuspend+0xb4>
				pxCurrentTCB = NULL;
  402a02:	2200      	movs	r2, #0
  402a04:	4b05      	ldr	r3, [pc, #20]	; (402a1c <vTaskSuspend+0xc4>)
  402a06:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  402a0a:	bd38      	pop	{r3, r4, r5, pc}
				vTaskSwitchContext();
  402a0c:	4b08      	ldr	r3, [pc, #32]	; (402a30 <vTaskSuspend+0xd8>)
  402a0e:	4798      	blx	r3
}
  402a10:	e7c5      	b.n	40299e <vTaskSuspend+0x46>
  402a12:	bf00      	nop
  402a14:	00401275 	.word	0x00401275
  402a18:	00401171 	.word	0x00401171
  402a1c:	20400a34 	.word	0x20400a34
  402a20:	00401125 	.word	0x00401125
  402a24:	004012c1 	.word	0x004012c1
  402a28:	004021d1 	.word	0x004021d1
  402a2c:	e000ed04 	.word	0xe000ed04
  402a30:	004028b9 	.word	0x004028b9

00402a34 <vTaskPlaceOnEventList>:
	configASSERT(pxEventList);
  402a34:	b950      	cbnz	r0, 402a4c <vTaskPlaceOnEventList+0x18>
  402a36:	f04f 0380 	mov.w	r3, #128	; 0x80
  402a3a:	b672      	cpsid	i
  402a3c:	f383 8811 	msr	BASEPRI, r3
  402a40:	f3bf 8f6f 	isb	sy
  402a44:	f3bf 8f4f 	dsb	sy
  402a48:	b662      	cpsie	i
  402a4a:	e7fe      	b.n	402a4a <vTaskPlaceOnEventList+0x16>
{
  402a4c:	b510      	push	{r4, lr}
  402a4e:	460c      	mov	r4, r1
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
  402a50:	4b05      	ldr	r3, [pc, #20]	; (402a68 <vTaskPlaceOnEventList+0x34>)
  402a52:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
  402a56:	3118      	adds	r1, #24
  402a58:	4b04      	ldr	r3, [pc, #16]	; (402a6c <vTaskPlaceOnEventList+0x38>)
  402a5a:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
  402a5c:	2101      	movs	r1, #1
  402a5e:	4620      	mov	r0, r4
  402a60:	4b03      	ldr	r3, [pc, #12]	; (402a70 <vTaskPlaceOnEventList+0x3c>)
  402a62:	4798      	blx	r3
  402a64:	bd10      	pop	{r4, pc}
  402a66:	bf00      	nop
  402a68:	20400a34 	.word	0x20400a34
  402a6c:	0040113d 	.word	0x0040113d
  402a70:	004021fd 	.word	0x004021fd

00402a74 <vTaskPlaceOnEventListRestricted>:
{
  402a74:	b538      	push	{r3, r4, r5, lr}
	configASSERT(pxEventList);
  402a76:	b180      	cbz	r0, 402a9a <vTaskPlaceOnEventListRestricted+0x26>
  402a78:	4614      	mov	r4, r2
  402a7a:	460d      	mov	r5, r1
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
  402a7c:	4b0c      	ldr	r3, [pc, #48]	; (402ab0 <vTaskPlaceOnEventListRestricted+0x3c>)
  402a7e:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
  402a82:	3118      	adds	r1, #24
  402a84:	4b0b      	ldr	r3, [pc, #44]	; (402ab4 <vTaskPlaceOnEventListRestricted+0x40>)
  402a86:	4798      	blx	r3
		xTicksToWait = portMAX_DELAY;
  402a88:	2c00      	cmp	r4, #0
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
  402a8a:	4621      	mov	r1, r4
  402a8c:	bf0c      	ite	eq
  402a8e:	4628      	moveq	r0, r5
  402a90:	f04f 30ff 	movne.w	r0, #4294967295
  402a94:	4b08      	ldr	r3, [pc, #32]	; (402ab8 <vTaskPlaceOnEventListRestricted+0x44>)
  402a96:	4798      	blx	r3
  402a98:	bd38      	pop	{r3, r4, r5, pc}
  402a9a:	f04f 0380 	mov.w	r3, #128	; 0x80
  402a9e:	b672      	cpsid	i
  402aa0:	f383 8811 	msr	BASEPRI, r3
  402aa4:	f3bf 8f6f 	isb	sy
  402aa8:	f3bf 8f4f 	dsb	sy
  402aac:	b662      	cpsie	i
  402aae:	e7fe      	b.n	402aae <vTaskPlaceOnEventListRestricted+0x3a>
  402ab0:	20400a34 	.word	0x20400a34
  402ab4:	00401125 	.word	0x00401125
  402ab8:	004021fd 	.word	0x004021fd

00402abc <xTaskRemoveFromEventList>:
{
  402abc:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
  402abe:	68c3      	ldr	r3, [r0, #12]
  402ac0:	68dc      	ldr	r4, [r3, #12]
	configASSERT(pxUnblockedTCB);
  402ac2:	b34c      	cbz	r4, 402b18 <xTaskRemoveFromEventList+0x5c>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
  402ac4:	f104 0518 	add.w	r5, r4, #24
  402ac8:	4628      	mov	r0, r5
  402aca:	4b1c      	ldr	r3, [pc, #112]	; (402b3c <xTaskRemoveFromEventList+0x80>)
  402acc:	4798      	blx	r3
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
  402ace:	4b1c      	ldr	r3, [pc, #112]	; (402b40 <xTaskRemoveFromEventList+0x84>)
  402ad0:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
  402ad4:	bb5b      	cbnz	r3, 402b2e <xTaskRemoveFromEventList+0x72>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
  402ad6:	1d25      	adds	r5, r4, #4
  402ad8:	4628      	mov	r0, r5
  402ada:	4b18      	ldr	r3, [pc, #96]	; (402b3c <xTaskRemoveFromEventList+0x80>)
  402adc:	4798      	blx	r3
		prvAddTaskToReadyList(pxUnblockedTCB);
  402ade:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  402ae0:	4b17      	ldr	r3, [pc, #92]	; (402b40 <xTaskRemoveFromEventList+0x84>)
  402ae2:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  402ae6:	4298      	cmp	r0, r3
  402ae8:	d902      	bls.n	402af0 <xTaskRemoveFromEventList+0x34>
  402aea:	4b15      	ldr	r3, [pc, #84]	; (402b40 <xTaskRemoveFromEventList+0x84>)
  402aec:	f8c3 00d4 	str.w	r0, [r3, #212]	; 0xd4
  402af0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  402af4:	4629      	mov	r1, r5
  402af6:	4b13      	ldr	r3, [pc, #76]	; (402b44 <xTaskRemoveFromEventList+0x88>)
  402af8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  402afc:	4b12      	ldr	r3, [pc, #72]	; (402b48 <xTaskRemoveFromEventList+0x8c>)
  402afe:	4798      	blx	r3
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
  402b00:	4b0f      	ldr	r3, [pc, #60]	; (402b40 <xTaskRemoveFromEventList+0x84>)
  402b02:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  402b06:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  402b08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  402b0a:	429a      	cmp	r2, r3
  402b0c:	d914      	bls.n	402b38 <xTaskRemoveFromEventList+0x7c>
		xYieldPending = pdTRUE;
  402b0e:	2001      	movs	r0, #1
  402b10:	4b0b      	ldr	r3, [pc, #44]	; (402b40 <xTaskRemoveFromEventList+0x84>)
  402b12:	f8c3 00e8 	str.w	r0, [r3, #232]	; 0xe8
  402b16:	bd38      	pop	{r3, r4, r5, pc}
  402b18:	f04f 0380 	mov.w	r3, #128	; 0x80
  402b1c:	b672      	cpsid	i
  402b1e:	f383 8811 	msr	BASEPRI, r3
  402b22:	f3bf 8f6f 	isb	sy
  402b26:	f3bf 8f4f 	dsb	sy
  402b2a:	b662      	cpsie	i
  402b2c:	e7fe      	b.n	402b2c <xTaskRemoveFromEventList+0x70>
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
  402b2e:	4629      	mov	r1, r5
  402b30:	4806      	ldr	r0, [pc, #24]	; (402b4c <xTaskRemoveFromEventList+0x90>)
  402b32:	4b05      	ldr	r3, [pc, #20]	; (402b48 <xTaskRemoveFromEventList+0x8c>)
  402b34:	4798      	blx	r3
  402b36:	e7e3      	b.n	402b00 <xTaskRemoveFromEventList+0x44>
		xReturn = pdFALSE;
  402b38:	2000      	movs	r0, #0
}
  402b3a:	bd38      	pop	{r3, r4, r5, pc}
  402b3c:	00401171 	.word	0x00401171
  402b40:	20400a34 	.word	0x20400a34
  402b44:	20400a5c 	.word	0x20400a5c
  402b48:	00401125 	.word	0x00401125
  402b4c:	20400a48 	.word	0x20400a48

00402b50 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
  402b50:	4b03      	ldr	r3, [pc, #12]	; (402b60 <vTaskInternalSetTimeOutState+0x10>)
  402b52:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
  402b56:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  402b58:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
  402b5c:	6043      	str	r3, [r0, #4]
  402b5e:	4770      	bx	lr
  402b60:	20400a34 	.word	0x20400a34

00402b64 <xTaskCheckForTimeOut>:
	configASSERT(pxTimeOut);
  402b64:	b1b8      	cbz	r0, 402b96 <xTaskCheckForTimeOut+0x32>
{
  402b66:	b570      	push	{r4, r5, r6, lr}
  402b68:	4605      	mov	r5, r0
	configASSERT(pxTicksToWait);
  402b6a:	b1f9      	cbz	r1, 402bac <xTaskCheckForTimeOut+0x48>
  402b6c:	460c      	mov	r4, r1
	taskENTER_CRITICAL();
  402b6e:	4b1e      	ldr	r3, [pc, #120]	; (402be8 <xTaskCheckForTimeOut+0x84>)
  402b70:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
  402b72:	4b1e      	ldr	r3, [pc, #120]	; (402bec <xTaskCheckForTimeOut+0x88>)
  402b74:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
  402b78:	6869      	ldr	r1, [r5, #4]
		    if (*pxTicksToWait == portMAX_DELAY) {
  402b7a:	6823      	ldr	r3, [r4, #0]
  402b7c:	f1b3 3fff 	cmp.w	r3, #4294967295
  402b80:	d030      	beq.n	402be4 <xTaskCheckForTimeOut+0x80>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
  402b82:	481a      	ldr	r0, [pc, #104]	; (402bec <xTaskCheckForTimeOut+0x88>)
  402b84:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
  402b88:	682e      	ldr	r6, [r5, #0]
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
  402b8a:	4286      	cmp	r6, r0
  402b8c:	d019      	beq.n	402bc2 <xTaskCheckForTimeOut+0x5e>
  402b8e:	428a      	cmp	r2, r1
  402b90:	d317      	bcc.n	402bc2 <xTaskCheckForTimeOut+0x5e>
			xReturn = pdTRUE;
  402b92:	2401      	movs	r4, #1
  402b94:	e01b      	b.n	402bce <xTaskCheckForTimeOut+0x6a>
  402b96:	f04f 0380 	mov.w	r3, #128	; 0x80
  402b9a:	b672      	cpsid	i
  402b9c:	f383 8811 	msr	BASEPRI, r3
  402ba0:	f3bf 8f6f 	isb	sy
  402ba4:	f3bf 8f4f 	dsb	sy
  402ba8:	b662      	cpsie	i
  402baa:	e7fe      	b.n	402baa <xTaskCheckForTimeOut+0x46>
  402bac:	f04f 0380 	mov.w	r3, #128	; 0x80
  402bb0:	b672      	cpsid	i
  402bb2:	f383 8811 	msr	BASEPRI, r3
  402bb6:	f3bf 8f6f 	isb	sy
  402bba:	f3bf 8f4f 	dsb	sy
  402bbe:	b662      	cpsie	i
  402bc0:	e7fe      	b.n	402bc0 <xTaskCheckForTimeOut+0x5c>
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
  402bc2:	1a52      	subs	r2, r2, r1
		} else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers,
  402bc4:	429a      	cmp	r2, r3
  402bc6:	d306      	bcc.n	402bd6 <xTaskCheckForTimeOut+0x72>
			*pxTicksToWait = 0;
  402bc8:	2300      	movs	r3, #0
  402bca:	6023      	str	r3, [r4, #0]
			xReturn        = pdTRUE;
  402bcc:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
  402bce:	4b08      	ldr	r3, [pc, #32]	; (402bf0 <xTaskCheckForTimeOut+0x8c>)
  402bd0:	4798      	blx	r3
}
  402bd2:	4620      	mov	r0, r4
  402bd4:	bd70      	pop	{r4, r5, r6, pc}
			*pxTicksToWait -= xElapsedTime;
  402bd6:	1a9b      	subs	r3, r3, r2
  402bd8:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState(pxTimeOut);
  402bda:	4628      	mov	r0, r5
  402bdc:	4b05      	ldr	r3, [pc, #20]	; (402bf4 <xTaskCheckForTimeOut+0x90>)
  402bde:	4798      	blx	r3
			xReturn = pdFALSE;
  402be0:	2400      	movs	r4, #0
  402be2:	e7f4      	b.n	402bce <xTaskCheckForTimeOut+0x6a>
			xReturn = pdFALSE;
  402be4:	2400      	movs	r4, #0
  402be6:	e7f2      	b.n	402bce <xTaskCheckForTimeOut+0x6a>
  402be8:	00401275 	.word	0x00401275
  402bec:	20400a34 	.word	0x20400a34
  402bf0:	004012c1 	.word	0x004012c1
  402bf4:	00402b51 	.word	0x00402b51

00402bf8 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
  402bf8:	2201      	movs	r2, #1
  402bfa:	4b02      	ldr	r3, [pc, #8]	; (402c04 <vTaskMissedYield+0xc>)
  402bfc:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
  402c00:	4770      	bx	lr
  402c02:	bf00      	nop
  402c04:	20400a34 	.word	0x20400a34

00402c08 <vTaskGetInfo>:
{
  402c08:	b570      	push	{r4, r5, r6, lr}
  402c0a:	460d      	mov	r5, r1
  402c0c:	4616      	mov	r6, r2
	pxTCB = prvGetTCBFromHandle(xTask);
  402c0e:	4604      	mov	r4, r0
  402c10:	b1d8      	cbz	r0, 402c4a <vTaskGetInfo+0x42>
	pxTaskStatus->xHandle           = (TaskHandle_t)pxTCB;
  402c12:	602c      	str	r4, [r5, #0]
	pxTaskStatus->pcTaskName        = (const char *)&(pxTCB->pcTaskName[0]);
  402c14:	f104 0234 	add.w	r2, r4, #52	; 0x34
  402c18:	606a      	str	r2, [r5, #4]
	pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
  402c1a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  402c1c:	612a      	str	r2, [r5, #16]
	pxTaskStatus->pxStackBase       = pxTCB->pxStack;
  402c1e:	6b22      	ldr	r2, [r4, #48]	; 0x30
  402c20:	61ea      	str	r2, [r5, #28]
	pxTaskStatus->xTaskNumber       = pxTCB->uxTCBNumber;
  402c22:	6be2      	ldr	r2, [r4, #60]	; 0x3c
  402c24:	60aa      	str	r2, [r5, #8]
		pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
  402c26:	6c62      	ldr	r2, [r4, #68]	; 0x44
  402c28:	616a      	str	r2, [r5, #20]
		pxTaskStatus->ulRunTimeCounter = 0;
  402c2a:	2200      	movs	r2, #0
  402c2c:	61aa      	str	r2, [r5, #24]
	if (eState != eInvalid) {
  402c2e:	2b05      	cmp	r3, #5
  402c30:	d01b      	beq.n	402c6a <vTaskGetInfo+0x62>
		if (pxTCB == pxCurrentTCB) {
  402c32:	4a18      	ldr	r2, [pc, #96]	; (402c94 <vTaskGetInfo+0x8c>)
  402c34:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
  402c38:	4294      	cmp	r4, r2
  402c3a:	d00a      	beq.n	402c52 <vTaskGetInfo+0x4a>
			pxTaskStatus->eCurrentState = eState;
  402c3c:	732b      	strb	r3, [r5, #12]
				if (eState == eSuspended) {
  402c3e:	2b03      	cmp	r3, #3
  402c40:	d00a      	beq.n	402c58 <vTaskGetInfo+0x50>
	if (xGetFreeStackSpace != pdFALSE) {
  402c42:	b9be      	cbnz	r6, 402c74 <vTaskGetInfo+0x6c>
		pxTaskStatus->usStackHighWaterMark = 0;
  402c44:	2300      	movs	r3, #0
  402c46:	842b      	strh	r3, [r5, #32]
  402c48:	bd70      	pop	{r4, r5, r6, pc}
	pxTCB = prvGetTCBFromHandle(xTask);
  402c4a:	4a12      	ldr	r2, [pc, #72]	; (402c94 <vTaskGetInfo+0x8c>)
  402c4c:	f8d2 4098 	ldr.w	r4, [r2, #152]	; 0x98
  402c50:	e7df      	b.n	402c12 <vTaskGetInfo+0xa>
			pxTaskStatus->eCurrentState = eRunning;
  402c52:	2300      	movs	r3, #0
  402c54:	732b      	strb	r3, [r5, #12]
  402c56:	e7f4      	b.n	402c42 <vTaskGetInfo+0x3a>
					vTaskSuspendAll();
  402c58:	4b0f      	ldr	r3, [pc, #60]	; (402c98 <vTaskGetInfo+0x90>)
  402c5a:	4798      	blx	r3
						if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
  402c5c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  402c5e:	b10b      	cbz	r3, 402c64 <vTaskGetInfo+0x5c>
							pxTaskStatus->eCurrentState = eBlocked;
  402c60:	2302      	movs	r3, #2
  402c62:	732b      	strb	r3, [r5, #12]
					(void)xTaskResumeAll();
  402c64:	4b0d      	ldr	r3, [pc, #52]	; (402c9c <vTaskGetInfo+0x94>)
  402c66:	4798      	blx	r3
  402c68:	e7eb      	b.n	402c42 <vTaskGetInfo+0x3a>
		pxTaskStatus->eCurrentState = eTaskGetState(pxTCB);
  402c6a:	4620      	mov	r0, r4
  402c6c:	4b0c      	ldr	r3, [pc, #48]	; (402ca0 <vTaskGetInfo+0x98>)
  402c6e:	4798      	blx	r3
  402c70:	7328      	strb	r0, [r5, #12]
  402c72:	e7e6      	b.n	402c42 <vTaskGetInfo+0x3a>
			pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);
  402c74:	6b20      	ldr	r0, [r4, #48]	; 0x30
	while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
  402c76:	7803      	ldrb	r3, [r0, #0]
  402c78:	2ba5      	cmp	r3, #165	; 0xa5
  402c7a:	d108      	bne.n	402c8e <vTaskGetInfo+0x86>
  402c7c:	1c43      	adds	r3, r0, #1
  402c7e:	1a19      	subs	r1, r3, r0
  402c80:	f813 2b01 	ldrb.w	r2, [r3], #1
  402c84:	2aa5      	cmp	r2, #165	; 0xa5
  402c86:	d0fa      	beq.n	402c7e <vTaskGetInfo+0x76>
	ulCount /= (uint32_t)sizeof(StackType_t); /*lint !e961 Casting is not redundant on smaller architectures. */
  402c88:	0889      	lsrs	r1, r1, #2
	return (uint16_t)ulCount;
  402c8a:	8429      	strh	r1, [r5, #32]
  402c8c:	bd70      	pop	{r4, r5, r6, pc}
	uint32_t ulCount = 0U;
  402c8e:	2100      	movs	r1, #0
  402c90:	e7fa      	b.n	402c88 <vTaskGetInfo+0x80>
  402c92:	bf00      	nop
  402c94:	20400a34 	.word	0x20400a34
  402c98:	004025f9 	.word	0x004025f9
  402c9c:	0040274d 	.word	0x0040274d
  402ca0:	00402455 	.word	0x00402455

00402ca4 <prvListTasksWithinSingleList>:
{
  402ca4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402ca8:	b083      	sub	sp, #12
	if (listCURRENT_LIST_LENGTH(pxList) > (UBaseType_t)0) {
  402caa:	680b      	ldr	r3, [r1, #0]
  402cac:	b343      	cbz	r3, 402d00 <prvListTasksWithinSingleList+0x5c>
		listGET_OWNER_OF_NEXT_ENTRY(pxFirstTCB, pxList);
  402cae:	684b      	ldr	r3, [r1, #4]
  402cb0:	685b      	ldr	r3, [r3, #4]
  402cb2:	604b      	str	r3, [r1, #4]
  402cb4:	f101 0808 	add.w	r8, r1, #8
  402cb8:	4543      	cmp	r3, r8
  402cba:	d00b      	beq.n	402cd4 <prvListTasksWithinSingleList+0x30>
  402cbc:	9201      	str	r2, [sp, #4]
  402cbe:	460c      	mov	r4, r1
  402cc0:	684b      	ldr	r3, [r1, #4]
  402cc2:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  402cc6:	4605      	mov	r5, r0
	UBaseType_t                uxTask = 0;
  402cc8:	2700      	movs	r7, #0
			vTaskGetInfo((TaskHandle_t)pxNextTCB, &(pxTaskStatusArray[uxTask]), pdTRUE, eState);
  402cca:	f04f 0a01 	mov.w	sl, #1
  402cce:	f8df 903c 	ldr.w	r9, [pc, #60]	; 402d0c <prvListTasksWithinSingleList+0x68>
  402cd2:	e00d      	b.n	402cf0 <prvListTasksWithinSingleList+0x4c>
		listGET_OWNER_OF_NEXT_ENTRY(pxFirstTCB, pxList);
  402cd4:	68cb      	ldr	r3, [r1, #12]
  402cd6:	604b      	str	r3, [r1, #4]
  402cd8:	e7f0      	b.n	402cbc <prvListTasksWithinSingleList+0x18>
			listGET_OWNER_OF_NEXT_ENTRY(pxNextTCB, pxList);
  402cda:	6863      	ldr	r3, [r4, #4]
  402cdc:	68de      	ldr	r6, [r3, #12]
			vTaskGetInfo((TaskHandle_t)pxNextTCB, &(pxTaskStatusArray[uxTask]), pdTRUE, eState);
  402cde:	9b01      	ldr	r3, [sp, #4]
  402ce0:	4652      	mov	r2, sl
  402ce2:	4629      	mov	r1, r5
  402ce4:	4630      	mov	r0, r6
  402ce6:	47c8      	blx	r9
			uxTask++;
  402ce8:	3701      	adds	r7, #1
  402cea:	3524      	adds	r5, #36	; 0x24
		} while (pxNextTCB != pxFirstTCB);
  402cec:	45b3      	cmp	fp, r6
  402cee:	d008      	beq.n	402d02 <prvListTasksWithinSingleList+0x5e>
			listGET_OWNER_OF_NEXT_ENTRY(pxNextTCB, pxList);
  402cf0:	6863      	ldr	r3, [r4, #4]
  402cf2:	685b      	ldr	r3, [r3, #4]
  402cf4:	6063      	str	r3, [r4, #4]
  402cf6:	4598      	cmp	r8, r3
  402cf8:	d1ef      	bne.n	402cda <prvListTasksWithinSingleList+0x36>
  402cfa:	68e3      	ldr	r3, [r4, #12]
  402cfc:	6063      	str	r3, [r4, #4]
  402cfe:	e7ec      	b.n	402cda <prvListTasksWithinSingleList+0x36>
	UBaseType_t                uxTask = 0;
  402d00:	2700      	movs	r7, #0
}
  402d02:	4638      	mov	r0, r7
  402d04:	b003      	add	sp, #12
  402d06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402d0a:	bf00      	nop
  402d0c:	00402c09 	.word	0x00402c09

00402d10 <uxTaskGetSystemState>:
{
  402d10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402d14:	4606      	mov	r6, r0
  402d16:	460c      	mov	r4, r1
  402d18:	4617      	mov	r7, r2
	vTaskSuspendAll();
  402d1a:	4b21      	ldr	r3, [pc, #132]	; (402da0 <uxTaskGetSystemState+0x90>)
  402d1c:	4798      	blx	r3
		if (uxArraySize >= uxCurrentNumberOfTasks) {
  402d1e:	4b21      	ldr	r3, [pc, #132]	; (402da4 <uxTaskGetSystemState+0x94>)
  402d20:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
  402d24:	42a3      	cmp	r3, r4
  402d26:	d839      	bhi.n	402d9c <uxTaskGetSystemState+0x8c>
  402d28:	4b1e      	ldr	r3, [pc, #120]	; (402da4 <uxTaskGetSystemState+0x94>)
  402d2a:	f103 0578 	add.w	r5, r3, #120	; 0x78
  402d2e:	f103 0814 	add.w	r8, r3, #20
  402d32:	2400      	movs	r4, #0
				uxTask += prvListTasksWithinSingleList(
  402d34:	f04f 0a01 	mov.w	sl, #1
  402d38:	f8df 906c 	ldr.w	r9, [pc, #108]	; 402da8 <uxTaskGetSystemState+0x98>
				    &(pxTaskStatusArray[uxTask]), &(pxReadyTasksLists[uxQueue]), eReady);
  402d3c:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
				uxTask += prvListTasksWithinSingleList(
  402d40:	4652      	mov	r2, sl
  402d42:	4629      	mov	r1, r5
  402d44:	eb06 0080 	add.w	r0, r6, r0, lsl #2
  402d48:	47c8      	blx	r9
  402d4a:	4404      	add	r4, r0
  402d4c:	3d14      	subs	r5, #20
			          tskIDLE_PRIORITY); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  402d4e:	4545      	cmp	r5, r8
  402d50:	d1f4      	bne.n	402d3c <uxTaskGetSystemState+0x2c>
			uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), (List_t *)pxDelayedTaskList, eBlocked);
  402d52:	f8df 8050 	ldr.w	r8, [pc, #80]	; 402da4 <uxTaskGetSystemState+0x94>
  402d56:	f8d8 108c 	ldr.w	r1, [r8, #140]	; 0x8c
  402d5a:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
  402d5e:	2202      	movs	r2, #2
  402d60:	eb06 0080 	add.w	r0, r6, r0, lsl #2
  402d64:	4d10      	ldr	r5, [pc, #64]	; (402da8 <uxTaskGetSystemState+0x98>)
  402d66:	47a8      	blx	r5
  402d68:	4404      	add	r4, r0
			uxTask += prvListTasksWithinSingleList(
  402d6a:	f8d8 109c 	ldr.w	r1, [r8, #156]	; 0x9c
			    &(pxTaskStatusArray[uxTask]), (List_t *)pxOverflowDelayedTaskList, eBlocked);
  402d6e:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
			uxTask += prvListTasksWithinSingleList(
  402d72:	2202      	movs	r2, #2
  402d74:	eb06 0080 	add.w	r0, r6, r0, lsl #2
  402d78:	47a8      	blx	r5
  402d7a:	4404      	add	r4, r0
				uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), &xSuspendedTaskList, eSuspended);
  402d7c:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
  402d80:	2203      	movs	r2, #3
  402d82:	4641      	mov	r1, r8
  402d84:	eb06 0080 	add.w	r0, r6, r0, lsl #2
  402d88:	47a8      	blx	r5
  402d8a:	4404      	add	r4, r0
				if (pulTotalRunTime != NULL) {
  402d8c:	b10f      	cbz	r7, 402d92 <uxTaskGetSystemState+0x82>
					*pulTotalRunTime = 0;
  402d8e:	2300      	movs	r3, #0
  402d90:	603b      	str	r3, [r7, #0]
	(void)xTaskResumeAll();
  402d92:	4b06      	ldr	r3, [pc, #24]	; (402dac <uxTaskGetSystemState+0x9c>)
  402d94:	4798      	blx	r3
}
  402d96:	4620      	mov	r0, r4
  402d98:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
  402d9c:	2400      	movs	r4, #0
  402d9e:	e7f8      	b.n	402d92 <uxTaskGetSystemState+0x82>
  402da0:	004025f9 	.word	0x004025f9
  402da4:	20400a34 	.word	0x20400a34
  402da8:	00402ca5 	.word	0x00402ca5
  402dac:	0040274d 	.word	0x0040274d

00402db0 <xTaskGetSchedulerState>:
	if (xSchedulerRunning == pdFALSE) {
  402db0:	4b06      	ldr	r3, [pc, #24]	; (402dcc <xTaskGetSchedulerState+0x1c>)
  402db2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
  402db6:	b13b      	cbz	r3, 402dc8 <xTaskGetSchedulerState+0x18>
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
  402db8:	4b04      	ldr	r3, [pc, #16]	; (402dcc <xTaskGetSchedulerState+0x1c>)
  402dba:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
			xReturn = taskSCHEDULER_SUSPENDED;
  402dbe:	2b00      	cmp	r3, #0
  402dc0:	bf0c      	ite	eq
  402dc2:	2002      	moveq	r0, #2
  402dc4:	2000      	movne	r0, #0
  402dc6:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
  402dc8:	2001      	movs	r0, #1
}
  402dca:	4770      	bx	lr
  402dcc:	20400a34 	.word	0x20400a34

00402dd0 <xTaskPriorityInherit>:
	if (pxMutexHolder != NULL) {
  402dd0:	2800      	cmp	r0, #0
  402dd2:	d045      	beq.n	402e60 <xTaskPriorityInherit+0x90>
{
  402dd4:	b538      	push	{r3, r4, r5, lr}
  402dd6:	4605      	mov	r5, r0
		if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority) {
  402dd8:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  402dda:	4922      	ldr	r1, [pc, #136]	; (402e64 <xTaskPriorityInherit+0x94>)
  402ddc:	f8d1 1098 	ldr.w	r1, [r1, #152]	; 0x98
  402de0:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  402de2:	428a      	cmp	r2, r1
  402de4:	d232      	bcs.n	402e4c <xTaskPriorityInherit+0x7c>
			if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE)
  402de6:	6981      	ldr	r1, [r0, #24]
  402de8:	2900      	cmp	r1, #0
  402dea:	db06      	blt.n	402dfa <xTaskPriorityInherit+0x2a>
				listSET_LIST_ITEM_VALUE(
  402dec:	491d      	ldr	r1, [pc, #116]	; (402e64 <xTaskPriorityInherit+0x94>)
  402dee:	f8d1 1098 	ldr.w	r1, [r1, #152]	; 0x98
  402df2:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  402df4:	f1c1 0105 	rsb	r1, r1, #5
  402df8:	6181      	str	r1, [r0, #24]
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxMutexHolderTCB->uxPriority]),
  402dfa:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  402dfe:	491a      	ldr	r1, [pc, #104]	; (402e68 <xTaskPriorityInherit+0x98>)
  402e00:	eb01 0282 	add.w	r2, r1, r2, lsl #2
  402e04:	6969      	ldr	r1, [r5, #20]
  402e06:	4291      	cmp	r1, r2
  402e08:	d006      	beq.n	402e18 <xTaskPriorityInherit+0x48>
				pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  402e0a:	4a16      	ldr	r2, [pc, #88]	; (402e64 <xTaskPriorityInherit+0x94>)
  402e0c:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
  402e10:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  402e12:	62ea      	str	r2, [r5, #44]	; 0x2c
			xReturn = pdTRUE;
  402e14:	2001      	movs	r0, #1
  402e16:	bd38      	pop	{r3, r4, r5, pc}
				if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) == (UBaseType_t)0) {
  402e18:	1d2c      	adds	r4, r5, #4
  402e1a:	4620      	mov	r0, r4
  402e1c:	4b13      	ldr	r3, [pc, #76]	; (402e6c <xTaskPriorityInherit+0x9c>)
  402e1e:	4798      	blx	r3
				pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  402e20:	4b10      	ldr	r3, [pc, #64]	; (402e64 <xTaskPriorityInherit+0x94>)
  402e22:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
  402e26:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
  402e28:	62e8      	str	r0, [r5, #44]	; 0x2c
				prvAddTaskToReadyList(pxMutexHolderTCB);
  402e2a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  402e2e:	4298      	cmp	r0, r3
  402e30:	d902      	bls.n	402e38 <xTaskPriorityInherit+0x68>
  402e32:	4b0c      	ldr	r3, [pc, #48]	; (402e64 <xTaskPriorityInherit+0x94>)
  402e34:	f8c3 00d4 	str.w	r0, [r3, #212]	; 0xd4
  402e38:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  402e3c:	4621      	mov	r1, r4
  402e3e:	4b0a      	ldr	r3, [pc, #40]	; (402e68 <xTaskPriorityInherit+0x98>)
  402e40:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  402e44:	4b0a      	ldr	r3, [pc, #40]	; (402e70 <xTaskPriorityInherit+0xa0>)
  402e46:	4798      	blx	r3
			xReturn = pdTRUE;
  402e48:	2001      	movs	r0, #1
  402e4a:	bd38      	pop	{r3, r4, r5, pc}
			if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority) {
  402e4c:	4a05      	ldr	r2, [pc, #20]	; (402e64 <xTaskPriorityInherit+0x94>)
  402e4e:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
  402e52:	6c40      	ldr	r0, [r0, #68]	; 0x44
  402e54:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
  402e56:	4298      	cmp	r0, r3
  402e58:	bf2c      	ite	cs
  402e5a:	2000      	movcs	r0, #0
  402e5c:	2001      	movcc	r0, #1
  402e5e:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t   xReturn          = pdFALSE;
  402e60:	2000      	movs	r0, #0
	return xReturn;
  402e62:	4770      	bx	lr
  402e64:	20400a34 	.word	0x20400a34
  402e68:	20400a5c 	.word	0x20400a5c
  402e6c:	00401171 	.word	0x00401171
  402e70:	00401125 	.word	0x00401125

00402e74 <xTaskPriorityDisinherit>:
	if (pxMutexHolder != NULL) {
  402e74:	2800      	cmp	r0, #0
  402e76:	d040      	beq.n	402efa <xTaskPriorityDisinherit+0x86>
{
  402e78:	b538      	push	{r3, r4, r5, lr}
  402e7a:	4604      	mov	r4, r0
		configASSERT(pxTCB == pxCurrentTCB);
  402e7c:	4a21      	ldr	r2, [pc, #132]	; (402f04 <xTaskPriorityDisinherit+0x90>)
  402e7e:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
  402e82:	4290      	cmp	r0, r2
  402e84:	d00a      	beq.n	402e9c <xTaskPriorityDisinherit+0x28>
  402e86:	f04f 0380 	mov.w	r3, #128	; 0x80
  402e8a:	b672      	cpsid	i
  402e8c:	f383 8811 	msr	BASEPRI, r3
  402e90:	f3bf 8f6f 	isb	sy
  402e94:	f3bf 8f4f 	dsb	sy
  402e98:	b662      	cpsie	i
  402e9a:	e7fe      	b.n	402e9a <xTaskPriorityDisinherit+0x26>
		configASSERT(pxTCB->uxMutexesHeld);
  402e9c:	6c82      	ldr	r2, [r0, #72]	; 0x48
  402e9e:	b952      	cbnz	r2, 402eb6 <xTaskPriorityDisinherit+0x42>
  402ea0:	f04f 0380 	mov.w	r3, #128	; 0x80
  402ea4:	b672      	cpsid	i
  402ea6:	f383 8811 	msr	BASEPRI, r3
  402eaa:	f3bf 8f6f 	isb	sy
  402eae:	f3bf 8f4f 	dsb	sy
  402eb2:	b662      	cpsie	i
  402eb4:	e7fe      	b.n	402eb4 <xTaskPriorityDisinherit+0x40>
		(pxTCB->uxMutexesHeld)--;
  402eb6:	3a01      	subs	r2, #1
  402eb8:	6482      	str	r2, [r0, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
  402eba:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
  402ebc:	6c61      	ldr	r1, [r4, #68]	; 0x44
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
  402ebe:	4288      	cmp	r0, r1
  402ec0:	d01d      	beq.n	402efe <xTaskPriorityDisinherit+0x8a>
  402ec2:	b9e2      	cbnz	r2, 402efe <xTaskPriorityDisinherit+0x8a>
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
  402ec4:	1d25      	adds	r5, r4, #4
  402ec6:	4628      	mov	r0, r5
  402ec8:	4b0f      	ldr	r3, [pc, #60]	; (402f08 <xTaskPriorityDisinherit+0x94>)
  402eca:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  402ecc:	6c60      	ldr	r0, [r4, #68]	; 0x44
  402ece:	62e0      	str	r0, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
  402ed0:	f1c0 0305 	rsb	r3, r0, #5
  402ed4:	61a3      	str	r3, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
  402ed6:	4b0b      	ldr	r3, [pc, #44]	; (402f04 <xTaskPriorityDisinherit+0x90>)
  402ed8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  402edc:	4298      	cmp	r0, r3
  402ede:	d902      	bls.n	402ee6 <xTaskPriorityDisinherit+0x72>
  402ee0:	4b08      	ldr	r3, [pc, #32]	; (402f04 <xTaskPriorityDisinherit+0x90>)
  402ee2:	f8c3 00d4 	str.w	r0, [r3, #212]	; 0xd4
  402ee6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  402eea:	4629      	mov	r1, r5
  402eec:	4b07      	ldr	r3, [pc, #28]	; (402f0c <xTaskPriorityDisinherit+0x98>)
  402eee:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  402ef2:	4b07      	ldr	r3, [pc, #28]	; (402f10 <xTaskPriorityDisinherit+0x9c>)
  402ef4:	4798      	blx	r3
				xReturn = pdTRUE;
  402ef6:	2001      	movs	r0, #1
  402ef8:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t   xReturn = pdFALSE;
  402efa:	2000      	movs	r0, #0
  402efc:	4770      	bx	lr
  402efe:	2000      	movs	r0, #0
}
  402f00:	bd38      	pop	{r3, r4, r5, pc}
  402f02:	bf00      	nop
  402f04:	20400a34 	.word	0x20400a34
  402f08:	00401171 	.word	0x00401171
  402f0c:	20400a5c 	.word	0x20400a5c
  402f10:	00401125 	.word	0x00401125

00402f14 <vTaskPriorityDisinheritAfterTimeout>:
	if (pxMutexHolder != NULL) {
  402f14:	2800      	cmp	r0, #0
  402f16:	d04c      	beq.n	402fb2 <vTaskPriorityDisinheritAfterTimeout+0x9e>
{
  402f18:	b538      	push	{r3, r4, r5, lr}
  402f1a:	4604      	mov	r4, r0
		configASSERT(pxTCB->uxMutexesHeld);
  402f1c:	6c80      	ldr	r0, [r0, #72]	; 0x48
  402f1e:	b950      	cbnz	r0, 402f36 <vTaskPriorityDisinheritAfterTimeout+0x22>
  402f20:	f04f 0380 	mov.w	r3, #128	; 0x80
  402f24:	b672      	cpsid	i
  402f26:	f383 8811 	msr	BASEPRI, r3
  402f2a:	f3bf 8f6f 	isb	sy
  402f2e:	f3bf 8f4f 	dsb	sy
  402f32:	b662      	cpsie	i
  402f34:	e7fe      	b.n	402f34 <vTaskPriorityDisinheritAfterTimeout+0x20>
  402f36:	6c62      	ldr	r2, [r4, #68]	; 0x44
  402f38:	428a      	cmp	r2, r1
  402f3a:	bf38      	it	cc
  402f3c:	460a      	movcc	r2, r1
		if (pxTCB->uxPriority != uxPriorityToUse) {
  402f3e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
			if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld) {
  402f40:	2801      	cmp	r0, #1
  402f42:	d135      	bne.n	402fb0 <vTaskPriorityDisinheritAfterTimeout+0x9c>
  402f44:	4291      	cmp	r1, r2
  402f46:	d033      	beq.n	402fb0 <vTaskPriorityDisinheritAfterTimeout+0x9c>
				configASSERT(pxTCB != pxCurrentTCB);
  402f48:	481a      	ldr	r0, [pc, #104]	; (402fb4 <vTaskPriorityDisinheritAfterTimeout+0xa0>)
  402f4a:	f8d0 0098 	ldr.w	r0, [r0, #152]	; 0x98
  402f4e:	4284      	cmp	r4, r0
  402f50:	d10a      	bne.n	402f68 <vTaskPriorityDisinheritAfterTimeout+0x54>
  402f52:	f04f 0380 	mov.w	r3, #128	; 0x80
  402f56:	b672      	cpsid	i
  402f58:	f383 8811 	msr	BASEPRI, r3
  402f5c:	f3bf 8f6f 	isb	sy
  402f60:	f3bf 8f4f 	dsb	sy
  402f64:	b662      	cpsie	i
  402f66:	e7fe      	b.n	402f66 <vTaskPriorityDisinheritAfterTimeout+0x52>
				pxTCB->uxPriority     = uxPriorityToUse;
  402f68:	62e2      	str	r2, [r4, #44]	; 0x2c
				if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
  402f6a:	69a0      	ldr	r0, [r4, #24]
  402f6c:	2800      	cmp	r0, #0
  402f6e:	db02      	blt.n	402f76 <vTaskPriorityDisinheritAfterTimeout+0x62>
					listSET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem),
  402f70:	f1c2 0205 	rsb	r2, r2, #5
  402f74:	61a2      	str	r2, [r4, #24]
				if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]), &(pxTCB->xStateListItem))
  402f76:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  402f7a:	4a0f      	ldr	r2, [pc, #60]	; (402fb8 <vTaskPriorityDisinheritAfterTimeout+0xa4>)
  402f7c:	eb02 0181 	add.w	r1, r2, r1, lsl #2
  402f80:	6962      	ldr	r2, [r4, #20]
  402f82:	428a      	cmp	r2, r1
  402f84:	d114      	bne.n	402fb0 <vTaskPriorityDisinheritAfterTimeout+0x9c>
					if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
  402f86:	1d25      	adds	r5, r4, #4
  402f88:	4628      	mov	r0, r5
  402f8a:	4b0c      	ldr	r3, [pc, #48]	; (402fbc <vTaskPriorityDisinheritAfterTimeout+0xa8>)
  402f8c:	4798      	blx	r3
					prvAddTaskToReadyList(pxTCB);
  402f8e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  402f90:	4b08      	ldr	r3, [pc, #32]	; (402fb4 <vTaskPriorityDisinheritAfterTimeout+0xa0>)
  402f92:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  402f96:	4298      	cmp	r0, r3
  402f98:	d902      	bls.n	402fa0 <vTaskPriorityDisinheritAfterTimeout+0x8c>
  402f9a:	4b06      	ldr	r3, [pc, #24]	; (402fb4 <vTaskPriorityDisinheritAfterTimeout+0xa0>)
  402f9c:	f8c3 00d4 	str.w	r0, [r3, #212]	; 0xd4
  402fa0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  402fa4:	4629      	mov	r1, r5
  402fa6:	4b04      	ldr	r3, [pc, #16]	; (402fb8 <vTaskPriorityDisinheritAfterTimeout+0xa4>)
  402fa8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  402fac:	4b04      	ldr	r3, [pc, #16]	; (402fc0 <vTaskPriorityDisinheritAfterTimeout+0xac>)
  402fae:	4798      	blx	r3
  402fb0:	bd38      	pop	{r3, r4, r5, pc}
  402fb2:	4770      	bx	lr
  402fb4:	20400a34 	.word	0x20400a34
  402fb8:	20400a5c 	.word	0x20400a5c
  402fbc:	00401171 	.word	0x00401171
  402fc0:	00401125 	.word	0x00401125

00402fc4 <vTaskList>:
{
  402fc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402fc8:	b084      	sub	sp, #16
  402fca:	4604      	mov	r4, r0
	*pcWriteBuffer = 0x00;
  402fcc:	2300      	movs	r3, #0
  402fce:	7003      	strb	r3, [r0, #0]
	uxArraySize = uxCurrentNumberOfTasks;
  402fd0:	4b3e      	ldr	r3, [pc, #248]	; (4030cc <vTaskList+0x108>)
  402fd2:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
  402fd6:	9203      	str	r2, [sp, #12]
	pxTaskStatusArray = pvPortMalloc(uxCurrentNumberOfTasks * sizeof(TaskStatus_t));
  402fd8:	f8d3 00a0 	ldr.w	r0, [r3, #160]	; 0xa0
  402fdc:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
  402fe0:	0080      	lsls	r0, r0, #2
  402fe2:	4b3b      	ldr	r3, [pc, #236]	; (4030d0 <vTaskList+0x10c>)
  402fe4:	4798      	blx	r3
	if (pxTaskStatusArray != NULL) {
  402fe6:	2800      	cmp	r0, #0
  402fe8:	d06d      	beq.n	4030c6 <vTaskList+0x102>
  402fea:	4605      	mov	r5, r0
		uxArraySize = uxTaskGetSystemState(pxTaskStatusArray, uxArraySize, NULL);
  402fec:	9903      	ldr	r1, [sp, #12]
  402fee:	2200      	movs	r2, #0
  402ff0:	4b38      	ldr	r3, [pc, #224]	; (4030d4 <vTaskList+0x110>)
  402ff2:	4798      	blx	r3
  402ff4:	9003      	str	r0, [sp, #12]
		for (x = 0; x < uxArraySize; x++) {
  402ff6:	2300      	movs	r3, #0
  402ff8:	9302      	str	r3, [sp, #8]
  402ffa:	9a02      	ldr	r2, [sp, #8]
  402ffc:	9b03      	ldr	r3, [sp, #12]
  402ffe:	429a      	cmp	r2, r3
  403000:	d25e      	bcs.n	4030c0 <vTaskList+0xfc>
				cStatus = 0x00;
  403002:	f04f 0800 	mov.w	r8, #0
	strcpy(pcBuffer, pcTaskName);
  403006:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 4030e8 <vTaskList+0x124>
	for (x = strlen(pcBuffer); x < (size_t)(configMAX_TASK_NAME_LEN - 1); x++) {
  40300a:	4e33      	ldr	r6, [pc, #204]	; (4030d8 <vTaskList+0x114>)
  40300c:	e044      	b.n	403098 <vTaskList+0xd4>
				cStatus = tskBLOCKED_CHAR;
  40300e:	2742      	movs	r7, #66	; 0x42
  403010:	e006      	b.n	403020 <vTaskList+0x5c>
				cStatus = tskSUSPENDED_CHAR;
  403012:	2753      	movs	r7, #83	; 0x53
				break;
  403014:	e004      	b.n	403020 <vTaskList+0x5c>
				cStatus = tskDELETED_CHAR;
  403016:	2744      	movs	r7, #68	; 0x44
				break;
  403018:	e002      	b.n	403020 <vTaskList+0x5c>
				cStatus = 0x00;
  40301a:	4647      	mov	r7, r8
				break;
  40301c:	e000      	b.n	403020 <vTaskList+0x5c>
				cStatus = tskREADY_CHAR;
  40301e:	2752      	movs	r7, #82	; 0x52
			pcWriteBuffer = prvWriteNameToBuffer(pcWriteBuffer, pxTaskStatusArray[x].pcTaskName);
  403020:	9b02      	ldr	r3, [sp, #8]
  403022:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
  403026:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	strcpy(pcBuffer, pcTaskName);
  40302a:	6859      	ldr	r1, [r3, #4]
  40302c:	4620      	mov	r0, r4
  40302e:	47c8      	blx	r9
	for (x = strlen(pcBuffer); x < (size_t)(configMAX_TASK_NAME_LEN - 1); x++) {
  403030:	4620      	mov	r0, r4
  403032:	47b0      	blx	r6
  403034:	2806      	cmp	r0, #6
  403036:	d807      	bhi.n	403048 <vTaskList+0x84>
  403038:	4420      	add	r0, r4
  40303a:	1de2      	adds	r2, r4, #7
		pcBuffer[x] = ' ';
  40303c:	2320      	movs	r3, #32
  40303e:	f800 3b01 	strb.w	r3, [r0], #1
	for (x = strlen(pcBuffer); x < (size_t)(configMAX_TASK_NAME_LEN - 1); x++) {
  403042:	4282      	cmp	r2, r0
  403044:	d1fb      	bne.n	40303e <vTaskList+0x7a>
  403046:	2007      	movs	r0, #7
	pcBuffer[x] = 0x00;
  403048:	eb04 0a00 	add.w	sl, r4, r0
  40304c:	f804 8000 	strb.w	r8, [r4, r0]
			        (unsigned int)pxTaskStatusArray[x].uxCurrentPriority,
  403050:	9b02      	ldr	r3, [sp, #8]
			        (unsigned int)pxTaskStatusArray[x].usStackHighWaterMark,
  403052:	9a02      	ldr	r2, [sp, #8]
			        (unsigned int)pxTaskStatusArray[x].xTaskNumber);
  403054:	9902      	ldr	r1, [sp, #8]
			        (unsigned int)pxTaskStatusArray[x].uxCurrentPriority,
  403056:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
  40305a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
			sprintf(pcWriteBuffer,
  40305e:	691b      	ldr	r3, [r3, #16]
			        (unsigned int)pxTaskStatusArray[x].xTaskNumber);
  403060:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
  403064:	eb05 0181 	add.w	r1, r5, r1, lsl #2
			sprintf(pcWriteBuffer,
  403068:	6889      	ldr	r1, [r1, #8]
  40306a:	9101      	str	r1, [sp, #4]
			        (unsigned int)pxTaskStatusArray[x].usStackHighWaterMark,
  40306c:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
  403070:	eb05 0282 	add.w	r2, r5, r2, lsl #2
			sprintf(pcWriteBuffer,
  403074:	8c12      	ldrh	r2, [r2, #32]
  403076:	9200      	str	r2, [sp, #0]
  403078:	463a      	mov	r2, r7
  40307a:	4918      	ldr	r1, [pc, #96]	; (4030dc <vTaskList+0x118>)
  40307c:	4650      	mov	r0, sl
  40307e:	4c18      	ldr	r4, [pc, #96]	; (4030e0 <vTaskList+0x11c>)
  403080:	47a0      	blx	r4
			pcWriteBuffer += strlen(pcWriteBuffer);
  403082:	4650      	mov	r0, sl
  403084:	47b0      	blx	r6
  403086:	eb0a 0400 	add.w	r4, sl, r0
		for (x = 0; x < uxArraySize; x++) {
  40308a:	9b02      	ldr	r3, [sp, #8]
  40308c:	3301      	adds	r3, #1
  40308e:	9302      	str	r3, [sp, #8]
  403090:	9a02      	ldr	r2, [sp, #8]
  403092:	9b03      	ldr	r3, [sp, #12]
  403094:	429a      	cmp	r2, r3
  403096:	d213      	bcs.n	4030c0 <vTaskList+0xfc>
			switch (pxTaskStatusArray[x].eCurrentState) {
  403098:	9b02      	ldr	r3, [sp, #8]
  40309a:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
  40309e:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  4030a2:	7b1b      	ldrb	r3, [r3, #12]
  4030a4:	3b01      	subs	r3, #1
  4030a6:	2b03      	cmp	r3, #3
  4030a8:	d8b7      	bhi.n	40301a <vTaskList+0x56>
  4030aa:	a201      	add	r2, pc, #4	; (adr r2, 4030b0 <vTaskList+0xec>)
  4030ac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4030b0:	0040301f 	.word	0x0040301f
  4030b4:	0040300f 	.word	0x0040300f
  4030b8:	00403013 	.word	0x00403013
  4030bc:	00403017 	.word	0x00403017
		vPortFree(pxTaskStatusArray);
  4030c0:	4628      	mov	r0, r5
  4030c2:	4b08      	ldr	r3, [pc, #32]	; (4030e4 <vTaskList+0x120>)
  4030c4:	4798      	blx	r3
}
  4030c6:	b004      	add	sp, #16
  4030c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4030cc:	20400a34 	.word	0x20400a34
  4030d0:	004014f5 	.word	0x004014f5
  4030d4:	00402d11 	.word	0x00402d11
  4030d8:	00403573 	.word	0x00403573
  4030dc:	004037d0 	.word	0x004037d0
  4030e0:	00400ecd 	.word	0x00400ecd
  4030e4:	004015c5 	.word	0x004015c5
  4030e8:	00403563 	.word	0x00403563

004030ec <pvTaskIncrementMutexHeldCount>:
	if (pxCurrentTCB != NULL) {
  4030ec:	4b06      	ldr	r3, [pc, #24]	; (403108 <pvTaskIncrementMutexHeldCount+0x1c>)
  4030ee:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  4030f2:	b12b      	cbz	r3, 403100 <pvTaskIncrementMutexHeldCount+0x14>
		(pxCurrentTCB->uxMutexesHeld)++;
  4030f4:	4b04      	ldr	r3, [pc, #16]	; (403108 <pvTaskIncrementMutexHeldCount+0x1c>)
  4030f6:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
  4030fa:	6c93      	ldr	r3, [r2, #72]	; 0x48
  4030fc:	3301      	adds	r3, #1
  4030fe:	6493      	str	r3, [r2, #72]	; 0x48
	return pxCurrentTCB;
  403100:	4b01      	ldr	r3, [pc, #4]	; (403108 <pvTaskIncrementMutexHeldCount+0x1c>)
  403102:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
}
  403106:	4770      	bx	lr
  403108:	20400a34 	.word	0x20400a34

0040310c <prvInsertTimerInActiveList>:
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList(Timer_t *const pxTimer, const TickType_t xNextExpiryTime,
                                             const TickType_t xTimeNow, const TickType_t xCommandTime)
{
  40310c:	b508      	push	{r3, lr}
	BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
  40310e:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
  403110:	6100      	str	r0, [r0, #16]

	if (xNextExpiryTime <= xTimeNow) {
  403112:	4291      	cmp	r1, r2
  403114:	d80c      	bhi.n	403130 <prvInsertTimerInActiveList+0x24>
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if (((TickType_t)(xTimeNow - xCommandTime))
  403116:	1ad2      	subs	r2, r2, r3
  403118:	6983      	ldr	r3, [r0, #24]
  40311a:	429a      	cmp	r2, r3
  40311c:	d301      	bcc.n	403122 <prvInsertTimerInActiveList+0x16>
		    >= pxTimer->xTimerPeriodInTicks) /*lint !e961 MISRA exception as the casts are only redundant for some
		                                        ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  40311e:	2001      	movs	r0, #1
  403120:	bd08      	pop	{r3, pc}
		} else {
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
  403122:	1d01      	adds	r1, r0, #4
  403124:	4b09      	ldr	r3, [pc, #36]	; (40314c <prvInsertTimerInActiveList+0x40>)
  403126:	6818      	ldr	r0, [r3, #0]
  403128:	4b09      	ldr	r3, [pc, #36]	; (403150 <prvInsertTimerInActiveList+0x44>)
  40312a:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
  40312c:	2000      	movs	r0, #0
  40312e:	bd08      	pop	{r3, pc}
		}
	} else {
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
  403130:	429a      	cmp	r2, r3
  403132:	d203      	bcs.n	40313c <prvInsertTimerInActiveList+0x30>
  403134:	4299      	cmp	r1, r3
  403136:	d301      	bcc.n	40313c <prvInsertTimerInActiveList+0x30>
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
  403138:	2001      	movs	r0, #1
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
		}
	}

	return xProcessTimerNow;
}
  40313a:	bd08      	pop	{r3, pc}
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
  40313c:	1d01      	adds	r1, r0, #4
  40313e:	4b03      	ldr	r3, [pc, #12]	; (40314c <prvInsertTimerInActiveList+0x40>)
  403140:	6858      	ldr	r0, [r3, #4]
  403142:	4b03      	ldr	r3, [pc, #12]	; (403150 <prvInsertTimerInActiveList+0x44>)
  403144:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
  403146:	2000      	movs	r0, #0
  403148:	bd08      	pop	{r3, pc}
  40314a:	bf00      	nop
  40314c:	20400b20 	.word	0x20400b20
  403150:	0040113d 	.word	0x0040113d

00403154 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
  403154:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  403156:	4b0d      	ldr	r3, [pc, #52]	; (40318c <prvCheckForValidListAndQueue+0x38>)
  403158:	4798      	blx	r3
	{
		if (xTimerQueue == NULL) {
  40315a:	4b0d      	ldr	r3, [pc, #52]	; (403190 <prvCheckForValidListAndQueue+0x3c>)
  40315c:	689b      	ldr	r3, [r3, #8]
  40315e:	b113      	cbz	r3, 403166 <prvCheckForValidListAndQueue+0x12>
#endif /* configQUEUE_REGISTRY_SIZE */
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
  403160:	4b0c      	ldr	r3, [pc, #48]	; (403194 <prvCheckForValidListAndQueue+0x40>)
  403162:	4798      	blx	r3
  403164:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise(&xActiveTimerList1);
  403166:	4c0a      	ldr	r4, [pc, #40]	; (403190 <prvCheckForValidListAndQueue+0x3c>)
  403168:	f104 060c 	add.w	r6, r4, #12
  40316c:	4630      	mov	r0, r6
  40316e:	4f0a      	ldr	r7, [pc, #40]	; (403198 <prvCheckForValidListAndQueue+0x44>)
  403170:	47b8      	blx	r7
			vListInitialise(&xActiveTimerList2);
  403172:	f104 0520 	add.w	r5, r4, #32
  403176:	4628      	mov	r0, r5
  403178:	47b8      	blx	r7
			pxCurrentTimerList  = &xActiveTimerList1;
  40317a:	6066      	str	r6, [r4, #4]
			pxOverflowTimerList = &xActiveTimerList2;
  40317c:	6025      	str	r5, [r4, #0]
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
  40317e:	2200      	movs	r2, #0
  403180:	210c      	movs	r1, #12
  403182:	2002      	movs	r0, #2
  403184:	4b05      	ldr	r3, [pc, #20]	; (40319c <prvCheckForValidListAndQueue+0x48>)
  403186:	4798      	blx	r3
  403188:	60a0      	str	r0, [r4, #8]
  40318a:	e7e9      	b.n	403160 <prvCheckForValidListAndQueue+0xc>
  40318c:	00401275 	.word	0x00401275
  403190:	20400b20 	.word	0x20400b20
  403194:	004012c1 	.word	0x004012c1
  403198:	00401109 	.word	0x00401109
  40319c:	0040189d 	.word	0x0040189d

004031a0 <xTimerCreateTimerTask>:
{
  4031a0:	b510      	push	{r4, lr}
  4031a2:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
  4031a4:	4b0e      	ldr	r3, [pc, #56]	; (4031e0 <xTimerCreateTimerTask+0x40>)
  4031a6:	4798      	blx	r3
	if (xTimerQueue != NULL) {
  4031a8:	4b0e      	ldr	r3, [pc, #56]	; (4031e4 <xTimerCreateTimerTask+0x44>)
  4031aa:	689b      	ldr	r3, [r3, #8]
  4031ac:	b163      	cbz	r3, 4031c8 <xTimerCreateTimerTask+0x28>
			xReturn = xTaskCreate(prvTimerTask,
  4031ae:	4b0e      	ldr	r3, [pc, #56]	; (4031e8 <xTimerCreateTimerTask+0x48>)
  4031b0:	9301      	str	r3, [sp, #4]
  4031b2:	2302      	movs	r3, #2
  4031b4:	9300      	str	r3, [sp, #0]
  4031b6:	2300      	movs	r3, #0
  4031b8:	2240      	movs	r2, #64	; 0x40
  4031ba:	490c      	ldr	r1, [pc, #48]	; (4031ec <xTimerCreateTimerTask+0x4c>)
  4031bc:	480c      	ldr	r0, [pc, #48]	; (4031f0 <xTimerCreateTimerTask+0x50>)
  4031be:	4c0d      	ldr	r4, [pc, #52]	; (4031f4 <xTimerCreateTimerTask+0x54>)
  4031c0:	47a0      	blx	r4
	configASSERT(xReturn);
  4031c2:	b108      	cbz	r0, 4031c8 <xTimerCreateTimerTask+0x28>
}
  4031c4:	b002      	add	sp, #8
  4031c6:	bd10      	pop	{r4, pc}
  4031c8:	f04f 0380 	mov.w	r3, #128	; 0x80
  4031cc:	b672      	cpsid	i
  4031ce:	f383 8811 	msr	BASEPRI, r3
  4031d2:	f3bf 8f6f 	isb	sy
  4031d6:	f3bf 8f4f 	dsb	sy
  4031da:	b662      	cpsie	i
  4031dc:	e7fe      	b.n	4031dc <xTimerCreateTimerTask+0x3c>
  4031de:	bf00      	nop
  4031e0:	00403155 	.word	0x00403155
  4031e4:	20400b20 	.word	0x20400b20
  4031e8:	20400b54 	.word	0x20400b54
  4031ec:	004037e0 	.word	0x004037e0
  4031f0:	00403319 	.word	0x00403319
  4031f4:	00402279 	.word	0x00402279

004031f8 <xTimerGenericCommand>:
	configASSERT(xTimer);
  4031f8:	b1d8      	cbz	r0, 403232 <xTimerGenericCommand+0x3a>
{
  4031fa:	b530      	push	{r4, r5, lr}
  4031fc:	b085      	sub	sp, #20
  4031fe:	4615      	mov	r5, r2
  403200:	4604      	mov	r4, r0
	if (xTimerQueue != NULL) {
  403202:	4a15      	ldr	r2, [pc, #84]	; (403258 <xTimerGenericCommand+0x60>)
  403204:	6890      	ldr	r0, [r2, #8]
  403206:	b320      	cbz	r0, 403252 <xTimerGenericCommand+0x5a>
  403208:	461a      	mov	r2, r3
		xMessage.xMessageID                       = xCommandID;
  40320a:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
  40320c:	9502      	str	r5, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
  40320e:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
  403210:	2905      	cmp	r1, #5
  403212:	dc19      	bgt.n	403248 <xTimerGenericCommand+0x50>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
  403214:	4b11      	ldr	r3, [pc, #68]	; (40325c <xTimerGenericCommand+0x64>)
  403216:	4798      	blx	r3
  403218:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
  40321a:	f04f 0300 	mov.w	r3, #0
  40321e:	bf0c      	ite	eq
  403220:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
  403222:	461a      	movne	r2, r3
  403224:	a901      	add	r1, sp, #4
  403226:	480c      	ldr	r0, [pc, #48]	; (403258 <xTimerGenericCommand+0x60>)
  403228:	6880      	ldr	r0, [r0, #8]
  40322a:	4c0d      	ldr	r4, [pc, #52]	; (403260 <xTimerGenericCommand+0x68>)
  40322c:	47a0      	blx	r4
}
  40322e:	b005      	add	sp, #20
  403230:	bd30      	pop	{r4, r5, pc}
  403232:	f04f 0380 	mov.w	r3, #128	; 0x80
  403236:	b672      	cpsid	i
  403238:	f383 8811 	msr	BASEPRI, r3
  40323c:	f3bf 8f6f 	isb	sy
  403240:	f3bf 8f4f 	dsb	sy
  403244:	b662      	cpsie	i
  403246:	e7fe      	b.n	403246 <xTimerGenericCommand+0x4e>
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
  403248:	2300      	movs	r3, #0
  40324a:	a901      	add	r1, sp, #4
  40324c:	4c05      	ldr	r4, [pc, #20]	; (403264 <xTimerGenericCommand+0x6c>)
  40324e:	47a0      	blx	r4
  403250:	e7ed      	b.n	40322e <xTimerGenericCommand+0x36>
	BaseType_t          xReturn = pdFAIL;
  403252:	2000      	movs	r0, #0
	return xReturn;
  403254:	e7eb      	b.n	40322e <xTimerGenericCommand+0x36>
  403256:	bf00      	nop
  403258:	20400b20 	.word	0x20400b20
  40325c:	00402db1 	.word	0x00402db1
  403260:	00401945 	.word	0x00401945
  403264:	00401b61 	.word	0x00401b61

00403268 <prvSampleTimeNow>:
{
  403268:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40326c:	b082      	sub	sp, #8
  40326e:	4680      	mov	r8, r0
	xTimeNow = xTaskGetTickCount();
  403270:	4b24      	ldr	r3, [pc, #144]	; (403304 <prvSampleTimeNow+0x9c>)
  403272:	4798      	blx	r3
  403274:	4607      	mov	r7, r0
	if (xTimeNow < xLastTime) {
  403276:	4b24      	ldr	r3, [pc, #144]	; (403308 <prvSampleTimeNow+0xa0>)
  403278:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  40327a:	4298      	cmp	r0, r3
  40327c:	d31b      	bcc.n	4032b6 <prvSampleTimeNow+0x4e>
		*pxTimerListsWereSwitched = pdFALSE;
  40327e:	2300      	movs	r3, #0
  403280:	f8c8 3000 	str.w	r3, [r8]
	xLastTime = xTimeNow;
  403284:	4b20      	ldr	r3, [pc, #128]	; (403308 <prvSampleTimeNow+0xa0>)
  403286:	639f      	str	r7, [r3, #56]	; 0x38
}
  403288:	4638      	mov	r0, r7
  40328a:	b002      	add	sp, #8
  40328c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
  403290:	2100      	movs	r1, #0
  403292:	9100      	str	r1, [sp, #0]
  403294:	460b      	mov	r3, r1
  403296:	4652      	mov	r2, sl
  403298:	4620      	mov	r0, r4
  40329a:	4c1c      	ldr	r4, [pc, #112]	; (40330c <prvSampleTimeNow+0xa4>)
  40329c:	47a0      	blx	r4
				configASSERT(xResult);
  40329e:	b960      	cbnz	r0, 4032ba <prvSampleTimeNow+0x52>
  4032a0:	f04f 0380 	mov.w	r3, #128	; 0x80
  4032a4:	b672      	cpsid	i
  4032a6:	f383 8811 	msr	BASEPRI, r3
  4032aa:	f3bf 8f6f 	isb	sy
  4032ae:	f3bf 8f4f 	dsb	sy
  4032b2:	b662      	cpsie	i
  4032b4:	e7fe      	b.n	4032b4 <prvSampleTimeNow+0x4c>
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
  4032b6:	4d14      	ldr	r5, [pc, #80]	; (403308 <prvSampleTimeNow+0xa0>)
		(void)uxListRemove(&(pxTimer->xTimerListItem));
  4032b8:	4e15      	ldr	r6, [pc, #84]	; (403310 <prvSampleTimeNow+0xa8>)
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
  4032ba:	686b      	ldr	r3, [r5, #4]
  4032bc:	681a      	ldr	r2, [r3, #0]
  4032be:	b1c2      	cbz	r2, 4032f2 <prvSampleTimeNow+0x8a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
  4032c0:	68db      	ldr	r3, [r3, #12]
  4032c2:	f8d3 a000 	ldr.w	sl, [r3]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
  4032c6:	68dc      	ldr	r4, [r3, #12]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
  4032c8:	f104 0904 	add.w	r9, r4, #4
  4032cc:	4648      	mov	r0, r9
  4032ce:	47b0      	blx	r6
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
  4032d0:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4032d2:	4620      	mov	r0, r4
  4032d4:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
  4032d6:	69e3      	ldr	r3, [r4, #28]
  4032d8:	2b01      	cmp	r3, #1
  4032da:	d1ee      	bne.n	4032ba <prvSampleTimeNow+0x52>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
  4032dc:	69a3      	ldr	r3, [r4, #24]
  4032de:	4453      	add	r3, sl
			if (xReloadTime > xNextExpireTime) {
  4032e0:	459a      	cmp	sl, r3
  4032e2:	d2d5      	bcs.n	403290 <prvSampleTimeNow+0x28>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
  4032e4:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
  4032e6:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
  4032e8:	4649      	mov	r1, r9
  4032ea:	6868      	ldr	r0, [r5, #4]
  4032ec:	4b09      	ldr	r3, [pc, #36]	; (403314 <prvSampleTimeNow+0xac>)
  4032ee:	4798      	blx	r3
  4032f0:	e7e3      	b.n	4032ba <prvSampleTimeNow+0x52>
	pxCurrentTimerList  = pxOverflowTimerList;
  4032f2:	4a05      	ldr	r2, [pc, #20]	; (403308 <prvSampleTimeNow+0xa0>)
  4032f4:	6811      	ldr	r1, [r2, #0]
  4032f6:	6051      	str	r1, [r2, #4]
	pxOverflowTimerList = pxTemp;
  4032f8:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
  4032fa:	2301      	movs	r3, #1
  4032fc:	f8c8 3000 	str.w	r3, [r8]
  403300:	e7c0      	b.n	403284 <prvSampleTimeNow+0x1c>
  403302:	bf00      	nop
  403304:	0040260d 	.word	0x0040260d
  403308:	20400b20 	.word	0x20400b20
  40330c:	004031f9 	.word	0x004031f9
  403310:	00401171 	.word	0x00401171
  403314:	0040113d 	.word	0x0040113d

00403318 <prvTimerTask>:
{
  403318:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40331c:	b086      	sub	sp, #24
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
  40331e:	4c6a      	ldr	r4, [pc, #424]	; (4034c8 <prvTimerTask+0x1b0>)
	vTaskSuspendAll();
  403320:	4f6a      	ldr	r7, [pc, #424]	; (4034cc <prvTimerTask+0x1b4>)
					portYIELD_WITHIN_API();
  403322:	f8df 91c8 	ldr.w	r9, [pc, #456]	; 4034ec <prvTimerTask+0x1d4>
	(void)uxListRemove(&(pxTimer->xTimerListItem));
  403326:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 4034f0 <prvTimerTask+0x1d8>
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
  40332a:	6863      	ldr	r3, [r4, #4]
  40332c:	681a      	ldr	r2, [r3, #0]
	if (*pxListWasEmpty == pdFALSE) {
  40332e:	2a00      	cmp	r2, #0
  403330:	f000 80bb 	beq.w	4034aa <prvTimerTask+0x192>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
  403334:	68db      	ldr	r3, [r3, #12]
  403336:	681d      	ldr	r5, [r3, #0]
	vTaskSuspendAll();
  403338:	47b8      	blx	r7
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
  40333a:	a803      	add	r0, sp, #12
  40333c:	4b64      	ldr	r3, [pc, #400]	; (4034d0 <prvTimerTask+0x1b8>)
  40333e:	4798      	blx	r3
  403340:	4606      	mov	r6, r0
		if (xTimerListsWereSwitched == pdFALSE) {
  403342:	9b03      	ldr	r3, [sp, #12]
  403344:	2b00      	cmp	r3, #0
  403346:	d143      	bne.n	4033d0 <prvTimerTask+0xb8>
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
  403348:	42a8      	cmp	r0, r5
  40334a:	d211      	bcs.n	403370 <prvTimerTask+0x58>
  40334c:	2200      	movs	r2, #0
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
  40334e:	1ba9      	subs	r1, r5, r6
  403350:	68a0      	ldr	r0, [r4, #8]
  403352:	4b60      	ldr	r3, [pc, #384]	; (4034d4 <prvTimerTask+0x1bc>)
  403354:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
  403356:	4b60      	ldr	r3, [pc, #384]	; (4034d8 <prvTimerTask+0x1c0>)
  403358:	4798      	blx	r3
  40335a:	2800      	cmp	r0, #0
  40335c:	d13a      	bne.n	4033d4 <prvTimerTask+0xbc>
					portYIELD_WITHIN_API();
  40335e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  403362:	f8c9 3000 	str.w	r3, [r9]
  403366:	f3bf 8f4f 	dsb	sy
  40336a:	f3bf 8f6f 	isb	sy
  40336e:	e031      	b.n	4033d4 <prvTimerTask+0xbc>
				(void)xTaskResumeAll();
  403370:	4b59      	ldr	r3, [pc, #356]	; (4034d8 <prvTimerTask+0x1c0>)
  403372:	4798      	blx	r3
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
  403374:	6863      	ldr	r3, [r4, #4]
  403376:	68db      	ldr	r3, [r3, #12]
  403378:	f8d3 a00c 	ldr.w	sl, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
  40337c:	f10a 0004 	add.w	r0, sl, #4
  403380:	47c0      	blx	r8
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
  403382:	f8da 301c 	ldr.w	r3, [sl, #28]
  403386:	2b01      	cmp	r3, #1
  403388:	d004      	beq.n	403394 <prvTimerTask+0x7c>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
  40338a:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
  40338e:	4650      	mov	r0, sl
  403390:	4798      	blx	r3
  403392:	e01f      	b.n	4033d4 <prvTimerTask+0xbc>
		if (prvInsertTimerInActiveList(
  403394:	f8da 1018 	ldr.w	r1, [sl, #24]
  403398:	462b      	mov	r3, r5
  40339a:	4632      	mov	r2, r6
  40339c:	4429      	add	r1, r5
  40339e:	4650      	mov	r0, sl
  4033a0:	4e4e      	ldr	r6, [pc, #312]	; (4034dc <prvTimerTask+0x1c4>)
  4033a2:	47b0      	blx	r6
  4033a4:	2800      	cmp	r0, #0
  4033a6:	d0f0      	beq.n	40338a <prvTimerTask+0x72>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
  4033a8:	2100      	movs	r1, #0
  4033aa:	9100      	str	r1, [sp, #0]
  4033ac:	460b      	mov	r3, r1
  4033ae:	462a      	mov	r2, r5
  4033b0:	4650      	mov	r0, sl
  4033b2:	4d4b      	ldr	r5, [pc, #300]	; (4034e0 <prvTimerTask+0x1c8>)
  4033b4:	47a8      	blx	r5
			configASSERT(xResult);
  4033b6:	2800      	cmp	r0, #0
  4033b8:	d1e7      	bne.n	40338a <prvTimerTask+0x72>
  4033ba:	f04f 0380 	mov.w	r3, #128	; 0x80
  4033be:	b672      	cpsid	i
  4033c0:	f383 8811 	msr	BASEPRI, r3
  4033c4:	f3bf 8f6f 	isb	sy
  4033c8:	f3bf 8f4f 	dsb	sy
  4033cc:	b662      	cpsie	i
  4033ce:	e7fe      	b.n	4033ce <prvTimerTask+0xb6>
			(void)xTaskResumeAll();
  4033d0:	4b41      	ldr	r3, [pc, #260]	; (4034d8 <prvTimerTask+0x1c0>)
  4033d2:	4798      	blx	r3
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
  4033d4:	4d43      	ldr	r5, [pc, #268]	; (4034e4 <prvTimerTask+0x1cc>)
  4033d6:	2200      	movs	r2, #0
  4033d8:	a903      	add	r1, sp, #12
  4033da:	68a0      	ldr	r0, [r4, #8]
  4033dc:	47a8      	blx	r5
  4033de:	2800      	cmp	r0, #0
  4033e0:	d0a3      	beq.n	40332a <prvTimerTask+0x12>
		if (xMessage.xMessageID >= (BaseType_t)0) {
  4033e2:	9b03      	ldr	r3, [sp, #12]
  4033e4:	2b00      	cmp	r3, #0
  4033e6:	dbf6      	blt.n	4033d6 <prvTimerTask+0xbe>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
  4033e8:	9e05      	ldr	r6, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem))
  4033ea:	6973      	ldr	r3, [r6, #20]
  4033ec:	b10b      	cbz	r3, 4033f2 <prvTimerTask+0xda>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
  4033ee:	1d30      	adds	r0, r6, #4
  4033f0:	47c0      	blx	r8
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
  4033f2:	a802      	add	r0, sp, #8
  4033f4:	4b36      	ldr	r3, [pc, #216]	; (4034d0 <prvTimerTask+0x1b8>)
  4033f6:	4798      	blx	r3
			switch (xMessage.xMessageID) {
  4033f8:	9b03      	ldr	r3, [sp, #12]
  4033fa:	2b09      	cmp	r3, #9
  4033fc:	d8eb      	bhi.n	4033d6 <prvTimerTask+0xbe>
  4033fe:	a201      	add	r2, pc, #4	; (adr r2, 403404 <prvTimerTask+0xec>)
  403400:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  403404:	0040342d 	.word	0x0040342d
  403408:	0040342d 	.word	0x0040342d
  40340c:	0040342d 	.word	0x0040342d
  403410:	004033d7 	.word	0x004033d7
  403414:	00403479 	.word	0x00403479
  403418:	004034a3 	.word	0x004034a3
  40341c:	0040342d 	.word	0x0040342d
  403420:	0040342d 	.word	0x0040342d
  403424:	004033d7 	.word	0x004033d7
  403428:	00403479 	.word	0x00403479
				                               xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks,
  40342c:	9d04      	ldr	r5, [sp, #16]
				if (prvInsertTimerInActiveList(pxTimer,
  40342e:	69b1      	ldr	r1, [r6, #24]
  403430:	462b      	mov	r3, r5
  403432:	4602      	mov	r2, r0
  403434:	4429      	add	r1, r5
  403436:	4630      	mov	r0, r6
  403438:	4d28      	ldr	r5, [pc, #160]	; (4034dc <prvTimerTask+0x1c4>)
  40343a:	47a8      	blx	r5
  40343c:	2800      	cmp	r0, #0
  40343e:	d0c9      	beq.n	4033d4 <prvTimerTask+0xbc>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
  403440:	6a73      	ldr	r3, [r6, #36]	; 0x24
  403442:	4630      	mov	r0, r6
  403444:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
  403446:	69f3      	ldr	r3, [r6, #28]
  403448:	2b01      	cmp	r3, #1
  40344a:	d1c3      	bne.n	4033d4 <prvTimerTask+0xbc>
						xResult = xTimerGenericCommand(pxTimer,
  40344c:	69b2      	ldr	r2, [r6, #24]
  40344e:	2100      	movs	r1, #0
  403450:	9100      	str	r1, [sp, #0]
  403452:	460b      	mov	r3, r1
  403454:	9804      	ldr	r0, [sp, #16]
  403456:	4402      	add	r2, r0
  403458:	4630      	mov	r0, r6
  40345a:	4d21      	ldr	r5, [pc, #132]	; (4034e0 <prvTimerTask+0x1c8>)
  40345c:	47a8      	blx	r5
						configASSERT(xResult);
  40345e:	2800      	cmp	r0, #0
  403460:	d1b8      	bne.n	4033d4 <prvTimerTask+0xbc>
  403462:	f04f 0380 	mov.w	r3, #128	; 0x80
  403466:	b672      	cpsid	i
  403468:	f383 8811 	msr	BASEPRI, r3
  40346c:	f3bf 8f6f 	isb	sy
  403470:	f3bf 8f4f 	dsb	sy
  403474:	b662      	cpsie	i
  403476:	e7fe      	b.n	403476 <prvTimerTask+0x15e>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
  403478:	9904      	ldr	r1, [sp, #16]
  40347a:	61b1      	str	r1, [r6, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
  40347c:	b131      	cbz	r1, 40348c <prvTimerTask+0x174>
				(void)prvInsertTimerInActiveList(
  40347e:	4603      	mov	r3, r0
  403480:	4602      	mov	r2, r0
  403482:	4401      	add	r1, r0
  403484:	4630      	mov	r0, r6
  403486:	4d15      	ldr	r5, [pc, #84]	; (4034dc <prvTimerTask+0x1c4>)
  403488:	47a8      	blx	r5
  40348a:	e7a3      	b.n	4033d4 <prvTimerTask+0xbc>
  40348c:	f04f 0380 	mov.w	r3, #128	; 0x80
  403490:	b672      	cpsid	i
  403492:	f383 8811 	msr	BASEPRI, r3
  403496:	f3bf 8f6f 	isb	sy
  40349a:	f3bf 8f4f 	dsb	sy
  40349e:	b662      	cpsie	i
  4034a0:	e7fe      	b.n	4034a0 <prvTimerTask+0x188>
				vPortFree(pxTimer);
  4034a2:	4630      	mov	r0, r6
  4034a4:	4b10      	ldr	r3, [pc, #64]	; (4034e8 <prvTimerTask+0x1d0>)
  4034a6:	4798      	blx	r3
  4034a8:	e794      	b.n	4033d4 <prvTimerTask+0xbc>
	vTaskSuspendAll();
  4034aa:	47b8      	blx	r7
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
  4034ac:	a803      	add	r0, sp, #12
  4034ae:	4b08      	ldr	r3, [pc, #32]	; (4034d0 <prvTimerTask+0x1b8>)
  4034b0:	4798      	blx	r3
  4034b2:	4606      	mov	r6, r0
		if (xTimerListsWereSwitched == pdFALSE) {
  4034b4:	9b03      	ldr	r3, [sp, #12]
  4034b6:	2b00      	cmp	r3, #0
  4034b8:	d18a      	bne.n	4033d0 <prvTimerTask+0xb8>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
  4034ba:	6823      	ldr	r3, [r4, #0]
  4034bc:	681a      	ldr	r2, [r3, #0]
  4034be:	fab2 f282 	clz	r2, r2
  4034c2:	0952      	lsrs	r2, r2, #5
  4034c4:	2500      	movs	r5, #0
  4034c6:	e742      	b.n	40334e <prvTimerTask+0x36>
  4034c8:	20400b20 	.word	0x20400b20
  4034cc:	004025f9 	.word	0x004025f9
  4034d0:	00403269 	.word	0x00403269
  4034d4:	00402109 	.word	0x00402109
  4034d8:	0040274d 	.word	0x0040274d
  4034dc:	0040310d 	.word	0x0040310d
  4034e0:	004031f9 	.word	0x004031f9
  4034e4:	00401d59 	.word	0x00401d59
  4034e8:	004015c5 	.word	0x004015c5
  4034ec:	e000ed04 	.word	0xe000ed04
  4034f0:	00401171 	.word	0x00401171

004034f4 <__libc_init_array>:
  4034f4:	b570      	push	{r4, r5, r6, lr}
  4034f6:	4e0d      	ldr	r6, [pc, #52]	; (40352c <__libc_init_array+0x38>)
  4034f8:	4c0d      	ldr	r4, [pc, #52]	; (403530 <__libc_init_array+0x3c>)
  4034fa:	1ba4      	subs	r4, r4, r6
  4034fc:	10a4      	asrs	r4, r4, #2
  4034fe:	2500      	movs	r5, #0
  403500:	42a5      	cmp	r5, r4
  403502:	d109      	bne.n	403518 <__libc_init_array+0x24>
  403504:	4e0b      	ldr	r6, [pc, #44]	; (403534 <__libc_init_array+0x40>)
  403506:	4c0c      	ldr	r4, [pc, #48]	; (403538 <__libc_init_array+0x44>)
  403508:	f000 f96e 	bl	4037e8 <_init>
  40350c:	1ba4      	subs	r4, r4, r6
  40350e:	10a4      	asrs	r4, r4, #2
  403510:	2500      	movs	r5, #0
  403512:	42a5      	cmp	r5, r4
  403514:	d105      	bne.n	403522 <__libc_init_array+0x2e>
  403516:	bd70      	pop	{r4, r5, r6, pc}
  403518:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  40351c:	4798      	blx	r3
  40351e:	3501      	adds	r5, #1
  403520:	e7ee      	b.n	403500 <__libc_init_array+0xc>
  403522:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  403526:	4798      	blx	r3
  403528:	3501      	adds	r5, #1
  40352a:	e7f2      	b.n	403512 <__libc_init_array+0x1e>
  40352c:	004037f4 	.word	0x004037f4
  403530:	004037f4 	.word	0x004037f4
  403534:	004037f4 	.word	0x004037f4
  403538:	004037f8 	.word	0x004037f8

0040353c <memcpy>:
  40353c:	b510      	push	{r4, lr}
  40353e:	1e43      	subs	r3, r0, #1
  403540:	440a      	add	r2, r1
  403542:	4291      	cmp	r1, r2
  403544:	d100      	bne.n	403548 <memcpy+0xc>
  403546:	bd10      	pop	{r4, pc}
  403548:	f811 4b01 	ldrb.w	r4, [r1], #1
  40354c:	f803 4f01 	strb.w	r4, [r3, #1]!
  403550:	e7f7      	b.n	403542 <memcpy+0x6>

00403552 <memset>:
  403552:	4402      	add	r2, r0
  403554:	4603      	mov	r3, r0
  403556:	4293      	cmp	r3, r2
  403558:	d100      	bne.n	40355c <memset+0xa>
  40355a:	4770      	bx	lr
  40355c:	f803 1b01 	strb.w	r1, [r3], #1
  403560:	e7f9      	b.n	403556 <memset+0x4>

00403562 <strcpy>:
  403562:	4603      	mov	r3, r0
  403564:	f811 2b01 	ldrb.w	r2, [r1], #1
  403568:	f803 2b01 	strb.w	r2, [r3], #1
  40356c:	2a00      	cmp	r2, #0
  40356e:	d1f9      	bne.n	403564 <strcpy+0x2>
  403570:	4770      	bx	lr

00403572 <strlen>:
  403572:	4603      	mov	r3, r0
  403574:	f813 2b01 	ldrb.w	r2, [r3], #1
  403578:	2a00      	cmp	r2, #0
  40357a:	d1fb      	bne.n	403574 <strlen+0x2>
  40357c:	1a18      	subs	r0, r3, r0
  40357e:	3801      	subs	r0, #1
  403580:	4770      	bx	lr
  403582:	0000      	movs	r0, r0
  403584:	682f2e2e 	.word	0x682f2e2e
  403588:	732f6c61 	.word	0x732f6c61
  40358c:	682f6372 	.word	0x682f6372
  403590:	695f6c61 	.word	0x695f6c61
  403594:	00632e6f 	.word	0x00632e6f
  403598:	682f2e2e 	.word	0x682f2e2e
  40359c:	732f6c61 	.word	0x732f6c61
  4035a0:	682f6372 	.word	0x682f6372
  4035a4:	755f6c61 	.word	0x755f6c61
  4035a8:	74726173 	.word	0x74726173
  4035ac:	2e736f5f 	.word	0x2e736f5f
  4035b0:	00000063 	.word	0x00000063
  4035b4:	682f2e2e 	.word	0x682f2e2e
  4035b8:	752f6c61 	.word	0x752f6c61
  4035bc:	736c6974 	.word	0x736c6974
  4035c0:	6372732f 	.word	0x6372732f
  4035c4:	6974752f 	.word	0x6974752f
  4035c8:	725f736c 	.word	0x725f736c
  4035cc:	62676e69 	.word	0x62676e69
  4035d0:	65666675 	.word	0x65666675
  4035d4:	00632e72 	.word	0x00632e72

004035d8 <_usarts>:
  4035d8:	00000001 001008c0 000403d0 682f2e2e     ............../h
  4035e8:	752f6c70 74726173 6c70682f 6173755f     pl/usart/hpl_usa
  4035f8:	632e7472 00000000                       rt.c....

00403600 <m_val>:
  403600:	3b9aca00 05f5e100 00989680 000f4240     ...;........@B..
  403610:	000186a0 00002710 000003e8 00000064     .....'......d...
  403620:	0000000a 00000001 454c202d 6c622044     ........- LED bl
  403630:	206b6e69 6b736174 74636120 2e657669     ink task active.
  403640:	00000a0d 454c202d 464f2044 6e612046     ....- LED OFF an
  403650:	6c622064 206b6e69 6b736174 73757320     d blink task sus
  403660:	646e6570 0d2e6465 0000000a 6f4d202d     pended......- Mo
  403670:	6f74696e 61742072 61206b73 76697463     nitor task activ
  403680:	0a0d2e65 00000000 6f4d202d 6f74696e     e.......- Monito
  403690:	61742072 73206b73 65707375 6465646e     r task suspended
  4036a0:	000a0d2e 696e6f4d 00726f74 0064654c     ....Monitor.Led.
  4036b0:	736e6f43 00656c6f 63256325 63256325     Console.%c%c%c%c
  4036c0:	00000000 202d2d2d 626d754e 6f207265     ....--- Number o
  4036d0:	61742066 3a736b73 0d752520 0000000a     f tasks: %u.....
  4036e0:	6154203e 09736b73 74617453 72500965     > Tasks.State.Pr
  4036f0:	74530969 096b6361 0d6d754e 0000000a     i.Stack.Num.....
  403700:	2a2a2a2a 2a2a2a2a 2a2a2a2a 2a2a2a2a     ****************
  403710:	2a2a2a2a 2a2a2a2a 2a2a2a2a 2a2a2a2a     ****************
  403720:	0d2a2a2a 0000000a 202d2d2d 73657250     ***.....--- Pres
  403730:	20612073 3a79656b 61200a0d 454c203a     s a key:.. a: LE
  403740:	6c622044 206b6e69 6b736174 74636120     D blink task act
  403750:	0d657669 3a73200a 44454c20 46464f20     ive.. s: LED OFF
  403760:	646e6120 696c6220 74206b6e 206b7361      and blink task 
  403770:	70737573 0d646e65 746f200a 73726568     suspend.. others
  403780:	6345203a 62206f68 0d6b6361 0000230a     : Echo back..#..
  403790:	742f2e2e 64726968 74726170 54522f79     ../thirdparty/RT
  4037a0:	662f534f 72656572 2f736f74 65657246     OS/freertos/Free
  4037b0:	534f5452 2e303156 2f302e30 736f7472     RTOSV10.0.0/rtos
  4037c0:	726f705f 00632e74 454c4449 00000000     _port.c.IDLE....
  4037d0:	09632509 25097525 75250975 00000a0d     .%c.%u.%u.%u....
  4037e0:	20726d54 00637653                       Tmr Svc.

004037e8 <_init>:
  4037e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4037ea:	bf00      	nop
  4037ec:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4037ee:	bc08      	pop	{r3}
  4037f0:	469e      	mov	lr, r3
  4037f2:	4770      	bx	lr

004037f4 <__init_array_start>:
  4037f4:	0040018d 	.word	0x0040018d

004037f8 <_fini>:
  4037f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4037fa:	bf00      	nop
  4037fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4037fe:	bc08      	pop	{r3}
  403800:	469e      	mov	lr, r3
  403802:	4770      	bx	lr

00403804 <__fini_array_start>:
  403804:	00400169 	.word	0x00400169
